/*
 Verilog-A definition of BSIM3 v3.25 updated to v3.3
 This code was based on the BSIM3v3.2.5 released 11/12/2004 by UC Berkeley.
Enhancements List:
1. All parameters of this model should be in lower case
2. ACM=0~13 with calcacm=0,1 for junction and S/D resistance model
3. Junction breakmod model
4. BSIM4 (v4.3) gate current model
5. BSIM4 built-in STI model as well as tsmc stimod (WPE model not included)
6. delta model instance params supported: delvto,mulu0,mulua,mulub,deltox,delk1

Limitations:
PNlim, Fetlim, such junction/fet current limitation function not implemented
noise:lintnoi, tnoic, rnoic not required to support
.option scale, scalem not impact this VA model 

Extra model parameters:
_ckt_gmin: model param to pass netlsit level gmin to va for diode current
verbose:   model param to print debug information (default: 0)
type:      polarity 1: nmos(default), -1:pmos

Golden Simulator: 
HSPICE -- J-2014.09-SP2-1 for testing
*/

//  To enable noise code
`define NOISE

`include "disciplines.vams"   
`include "constants.vams"
`define NOT_GIVEN -9.9999e-99
`define INT_NOT_GIVEN -9999999
`define DEFAULT_TNOM 25
`define N_MINLOG 1.0e-38
`define EXP_THRESHOLD 34.0
`define EXP_THRESHOLD2 40
`define EXPMAX 80
`define MIN_EXP 1.713908431e-15
`define MAX_EXP 5.834617425e14
`define MAX_EXPL 2.688117142e+43
`define MIN_EXPL 3.720075976e-44
`define MIN_EXP2 4.2483542552916e-18
`define EXPL_THRESHOLD 100.0
`define EPSMIN 1.0e-28
`define RESMIX 1.0e-5

`define DELTA  1.0E-9
`define DELTA_1 0.02
`define DELTA_2 0.02
`define DELTA_3 0.02
`define DELTA_4 0.02
`define EPSOX 3.453133e-11
`define EPSSI 1.03594e-10
`define KboQ 8.617087e-5
`define CONSTroot2 sqrt(2.0)
`define CONSTvt0 (`P_K * (27.0 + `P_CELSIUS0) / `P_Q)
`define NMOS 1
`define PMOS -1

`define BSIM3_sqrt(x) (x>0.0? sqrt(x):0.0)
`define max_arg (`CONSTvt0 * ln(`CONSTvt0 / (`CONSTroot2 * 1.0e-14)))
`define DioIjthVjmEval(nvtm, xijth, isb, xexpbv, vjm)     \
       if (isb != 0.0)                                    \
          T1 = 1.0 + xijth / isb - xexpbv;                \
       else                                               \
          T1 = 1.0 - xexpbv;                              \
       if ((T1 * T1 + 4.0 * xexpbv) >= 0.0)               \
          T2 = 0.5 * (T1 + `BSIM3_sqrt(T1 * T1 + 4.0 * xexpbv)); \
       else                                               \
          T2 = 0.5 * (T1 + 0.0);                          \
       vjm = nvtm * log(T2);


module bsim3_va(d, g, s, b);
    inout d, g, s, b;
    electrical d, g, s, b, di, si;
    
     analog function real  exp_lim;
         input x;
         real  x;
         begin
             if (x < `EXPMAX)
                 exp_lim = exp(x);
             else
                 exp_lim = exp(`EXPMAX);
         end
     endfunction
    
    // Default for Instance Parameters
    // The parameter "type" should be set for N/P-MOSFET 
    parameter integer verbose = `INT_NOT_GIVEN;  // debug flag to print DBG msg 
    parameter real w=5e-6; // Default channel width [m]
    parameter real l=5e-6; // Default channel length [m]
    parameter real as=`NOT_GIVEN; // Default area of source diffusion [m^2]
    parameter real ad=`NOT_GIVEN; // Default area of drain diffusion [m^2]
    parameter real ps=`NOT_GIVEN; // Default perimeter of source diffusion [m]
    parameter real pd=`NOT_GIVEN; // Default perimeter of drain diffusion [m]
    parameter real nrd=`NOT_GIVEN; // Default number of squares of drain diffusion [m/m]
    parameter real nrs=`NOT_GIVEN; // Default number of squares of source diffusion [m/m]
    parameter real version=3.3 from [3.00:3.3]; // Model version selector

    parameter integer level=49 from [49:53]; // Spice level (ignored in Verilog-A) 
    parameter integer paramchk=0;         // Model parameter checking selector
    parameter real _ckt_gmin = 1e-12;     // for junction current calc 
    
    // Temperature Effects Parameters
    parameter integer type = `NMOS;     // NMOS=1 PMOS=-1
    
    // Threshold Voltage Parameters
    parameter real vth0 = `NOT_GIVEN; // V-Th zero body bias long-channel device [v]
    parameter real vfb= `NOT_GIVEN;   // Flat-band voltage [v]
    parameter real k1=`NOT_GIVEN;   // Body-effect coefficient 0.5  
    parameter real k2=`NOT_GIVEN;   // Charge-sharing parameter -0.0186
    parameter real k3=80;   // Narrow width coefficient
    parameter real k3b=0;   // Narrow width coefficient [1/V]
    parameter real w0=2.5e-6; // Narrow width coeff [m]
    parameter real nlx=1.74e-7; // Lateral nonuniform doping coeff [m]
    parameter real gamma1 = `NOT_GIVEN; // Body-effectcoeff near the surf
    parameter real gamma2 = 0.0; // Body-effectcoeff in the bulk
    parameter real vbx = `NOT_GIVEN; // Threshold voltage transitionbody voltage [V]
    parameter real vbm=-3; // Maximum applied body voltage [V]
    parameter real dvt0=2.2; // 1st coeff of short-channel effect
    parameter real dvt1=0.53; // 2nd coeff of short-channel effect
    parameter real dvt2=-0.032; // Body-bias coeff of short-channel effect [1/V]
    parameter real dvt0w=0; // 1st coeff of narrow-width effect
    parameter real dvt1w=5.3e6; // 2nd coeff of narrow-width effect
    parameter real dvt2w=-0.032; // Body-bias coeff of narrow-width effect [1/V]
    parameter real a0=1; // Nonuniform depletionwidth effectcoeff
    parameter real b0=0; // Bulk charge coeff due to narrow width effect [m]
    parameter real b1=0; // Bulk charge coeff due to narrow width effect [m]
    parameter real a1=0; // No-saturationcoeff
    parameter real a2=1; // No-saturationcoeff
    parameter real ags=0; // Gate-bias dependence of Abulk [F/m2 V]
    parameter real keta=-0.047; // Body-bias coeff non-unif depl width effect [1/V]
    
    //  Process Parameters
    parameter real nsub=`NOT_GIVEN; // Substrate doping concentration [cm-3]
    parameter real nch=`NOT_GIVEN; // Peak channel doping concentration [cm-3]
    parameter real ngate= 0.0; // Poly-gate doping concentration [cm-3]
    parameter real xj=0.15e-6; // Source/drain junctiondepth [m]
    parameter real lint=0; // Lateral diffusion for one side [m]
    parameter real wint=0; // Width reductionfor one side [m]
    parameter real ll=0; // Length dependence of delta L [m]
    parameter real lln=1; // Length exponent of delta L
    parameter real lw=0; // Width dependence of delta L [m]
    parameter real lwn=1; // Width exponent of delta L
    parameter real lwl=0; // Area dependence of delta L [m2]
    parameter real wl=0; // Length dependence of delta W [m]
    parameter real wln=1; // Length exponent of delta W
    parameter real ww=0; // Width dependence of delta W [m]
    parameter real wwn=1; // Width exponent of delta W
    parameter real wwl=0; // Area dependence of delta W [m2]
    parameter real dwg=0; // Gate-bias dependence of channel width [m/v]
    parameter real dwb=0; // Body-bias dependence of channel width
    parameter real tox=150.0e-10; // Gate oxide thickness [m]
    parameter real toxm=`NOT_GIVEN; // Tox at which parameters were extracted [m]
    parameter real xt=`NOT_GIVEN; // 1.55e-7; // Doping depth [m]
    parameter real rdsw=0; // Width dependence of drain-source resistance [Ohm mm]
    parameter real prwb=0; // Body-effectcoeff for Rds
    parameter real prwg=0; // Gate-effectcoeff for Rds [1/V]
    parameter real wr=1; // Width offset for parasitic resistance
    parameter integer binunit=1; // Bin unit selector  1: microns 2: meters
    
    // Mobility Parameters
    parameter integer mobmod=1; // Mobility model selector
    parameter real u0=`NOT_GIVEN; // Low-field surface mobility at tnom [cm2/V s]
    parameter real vsat=8e4; // Carrier saturationvelocity at tnom [m/s]
    parameter real ua=2.25e-9; // 1st-order mobility reductioncoeff [m/v]
    parameter real ub=5.87e-19; // [m2/v2]
    
    // 2nd-order mobility reductioncoeff
    parameter real uc=`NOT_GIVEN; // Body-bias dependence of mobility [m/v2]
    
    // Output Resistance Parameters
    parameter real drout=0.56; // DIBL effecton output resistance coeff
    parameter real pclm=1.3; // Channel length modulationcoeff
    //parameter real pdibl1=0.39; //Alias for pdiblc1, not implemented
    //parameter real pdibl2=8.6e-3;  //Alias for pdiblc2, not implemented
    //parameter real pdiblb=0;  //Alias for pdiblcb, not implemented

    parameter real pdiblc1=0.39; // 1st coeff of drain-induced barrier lowering
    parameter real pdiblc2=0.0086; // 1st coeff of drain-induced barrier lowering
    parameter real pdiblcb=0.0; // Body-effectcoeff for DIBL [1/V]

    parameter real pscbe1=4.24e8; // 1st coeff of subst current body effect [V/m]
    parameter real pscbe2=1e-5; // 2nd coeff substrate current body effect [m/v]
    parameter real pvag=0; // Gate dependence of Early voltage.
    parameter real delta=0.01; // Effective drain voltage smoothing parameter [V]
   
    // Subthreshold Parameters
    parameter real cdsc=2.4e-4; // Source/drain and channel coupling cap [F/m2]
    parameter real cdscb=0; // Body-bias dependence of cdsc [F/m2 V]
    parameter real cdscd=0; // Drain-bias dependence of cdsc [F/m2 V]
    parameter real nfactor=1; // Subthreshold swing coeff
    parameter real cit=0; // Interface trap parameter for subthreshold swing [F]
    parameter real voff=-0.08; // Threshold voltage offset [V]
    parameter real dsub=drout; // DIBL effectin subthreshold region
    parameter real eta0=0.08; // DIBL coeff subthreshold region
    parameter real etab=-0.07; // Body-bias dependence of et0 [1/V]
    
    // SubstrateCurrent Parameters
    parameter real alpha0=0; // Substrate current impact ionizationcoeff [m/v]
    parameter real alpha1=0; // Substrate current impact ionizationcoeff [1/V]
    parameter real beta0=30; // Substrate current impact ionizationexponent [1/V]
    parameter real ijth=`NOT_GIVEN; //
    
    // Parasitic Resistance Parameters
    parameter real rsh=0; // Source/drain diffusion sheet resistance per square [Ohm]
    parameter real rs=0;   // Source resistance [Ohm]
    parameter real wrs=0;  // Source resistance [Ohm]
    parameter real lrs=0;  // Source resistance [Ohm]
    parameter real prs=0;  // Source resistance [Ohm]
    parameter real rd=0;   // Drain resistance [Ohm]
    parameter real wrd=0;  // Drain resistance [Ohm]
    parameter real lrd=0;  // Drain resistance [Ohm]
    parameter real prd=0;  // Drain resistance [Ohm]
    parameter real lgcs=0; // Gate-to-contact length of source side [m]
    parameter real lgcd=0; // Gate-to-contact length of drain side [m]
    parameter real rsc=0;  // Source contact resistance [Ohm]
    parameter real rdc=0;  // Drain contact resistance [Ohm]
    parameter real sc= `NOT_GIVEN; // Unused: Spacing between contacts [m]
    parameter real ldif=0; // Lateral diffusion beyond the gate [m]
    parameter real hdif=0; // Length of heavily doped diffusion [m]
    parameter real minr=0.1; // Unused: Minimum source/drain resistance [Ohm]
    
    // JunctionDiode Model Parameters
    parameter real js=1e-4; // Bulk junction reverse sat current density [A/m2]
    parameter real jsw=0; // Sidewall junctionreverse sat current density [A/m]
    parameter real jssw=0.0; // Unused: side wall sat current density [A/m]
    parameter real is=1e-14; // Unused: Bulk junctionreverse saturation current [A]
    parameter real nj=1; // Junctionemission coeff
    
    parameter real imelt= `NOT_GIVEN; // Unused: Explosion current
    parameter real jmelt= `NOT_GIVEN; // Unused: Explosion current density
    
    // Overlap Capacitance Parameters
    parameter real cgso=`NOT_GIVEN; // Gate-source overlap capacitance [F/m]
    parameter real cgdo=`NOT_GIVEN; // Gate-drain overlap capacitance [F/m]
    parameter real cgbo=`NOT_GIVEN; // Gate-bulk overlap cap [F/m]
    parameter real xpart=`NOT_GIVEN;
    
    parameter real meto=0; // Unused: Metal overlap in fringing field [m]
    parameter real cgsl=0; // Gate-source overlap capacitance in LDD region [F/m]
    parameter real cgdl=0; // Gate-drain overlap capacitance in LDD region [F/m]
    parameter real ckappa=0.6; // Overlap capacitance fitting parameter
    
    // JunctionCapacitance Model Parameters
    parameter real cbs=0; // Unused: Bulk-source zero-bias junctioncapacitance [F]
    parameter real cbd=0; // Unused: Bulk-drain zero-bias junctioncapacitance [F]
    parameter real cj=5e-4; // Zero-bias junctionbottom capacitance density [F/m2]
    parameter real mj=0.5; // Bulk junctionbottom grading coeff
    parameter real pb=1; // Bulk junctionbuilt-in potential [V]
    parameter real fc=0.5; // Unused: Forward-bias depletioncapacitance threshold
    parameter real cjsw=5e-10; // Zero-bias junctionsidewall cap density [F/m]
    parameter real mjsw=0.33; // Bulk junctionsidewall grading coeff
    parameter real pbsw=1; // Side-wall junctionbuilt-in potential [V]
    parameter real php=1; // Alias to pbsw when ACM=0-3
    parameter real cjswg=cjsw; // Zero-bias gate-side junction cap density [F/m]
    parameter real cjgate=cjsw; // Alias to cjswg when ACM=0-3
    parameter real mjswg=mjsw; // Gate-side junctiongrading coeff
    parameter real pbswg=pbsw; // Gate-side junctionbuilt-in potential [V]
    parameter real fcsw=0.5; // Unused: Side-wall forward-bias depletion cap threshold
    
    // Charge Model SelectionParameters
    parameter integer capmod=3 from [0:3]; // Intrinsic charge model
    parameter integer nqsmod=0; // Non-quasi static model selector (0/1)
    parameter real dwc=wint; // Delta W for capacitance model [m]
    parameter real dlc=`NOT_GIVEN; // Delta L for capacitance model [m]
    parameter real clc=0.1e-6; // Intrinsic capacitance fitting parameter [m]
    parameter real cle=0.6; // Intrinsic capacitance fitting parameter
    parameter real cf=`NOT_GIVEN; // Fringe capacitance parameter [F/m]
    parameter real elm=5; // Elmore constant of the channel
    parameter real vfbcv=-1; // Flat-band voltage for capmod=0
    parameter real acde=1; // CV parameter [1/V]
    parameter real moin=15; // CV parameter [1/V]
    parameter real noff=1; // Transition parameter
    parameter real voffcv=0; // Transition parameter
    //parameter real part=0; // Unused: Drain/source channel charge partitioning
                           // Use 0.0 for 40/60, 0.5 for 50/50, or 1.0 for 0/100
    parameter real llc=ll; // Length dependence of delta L for CV [m]
    parameter real lwc=lw; // Width dependence of delta L for CV [m]
    parameter real lwlc=lwl; // Area dependence of delta L for CV [m2]
    parameter real wlc=wl; // Length dependence of delta W for CV [m]
    parameter real wwc=ww; // Width dependence of delta W for CV [m]
    parameter real wwlc=wwl; // Area dependence of delta W for CV [m2]
    
    parameter real tnom=`DEFAULT_TNOM; // Parameter measurement temperature [C]
    parameter real trise=0; // Unused: Temperature rise from ambient [C]
    parameter real tlev=0; // Unused: DC temperature selector
    parameter real tlevc=0; // Unused: AC temperature selector
    parameter real eg=1.12452; // Unused: Energy band gap [V]
    parameter real gap1=7.02e-4; // Unused: Band gap temperature coeff [V/C]
    parameter real gap2=1108; // Unused: Band gap temperature offset [C deg]
    parameter real kt1=-0.11; // Temperature coeff for threshold voltage [V]
    parameter real kt1l=0; // Temperature coeff for threshold voltage [v m]
    parameter real kt2=0.022; // Temperature coeff for threshold voltage
    parameter real at=3.3e4; //  Temperature coeff for vsat [m/s]
    parameter real ua1=4.31e-9; // Temperature coeff for ua [m/v]
    parameter real ub1=-7.61e-18; // Temperature coeff for ub [m2/v2]
    parameter real uc1=`NOT_GIVEN; // Temperature coeff for uc [m/v2]
    parameter real prt=0; // Temperature coeff for Rds [Ohm]
    parameter real trs=0; // Unused: Temperature parameter for source resistance [1/C]
    parameter real trd=0; // Unused: Temperature parameter for drain resistance [1/C]
    parameter real ute=-1.5; // Mobility temperature exponent
    parameter real xti=3; // Saturationcurrent temperature exponent
    parameter real pta=0; // Junctionpotential temperature coeff [V/C]
    parameter real tpb=0; // Temperature coeff for pb [V/C]
    parameter real ptp=0; // Unused: Sidewall junctionpotential temperature coeff [V/C]
    parameter real tpbsw=0; // Temperature coeff for pbsw [V/C]
    parameter real tpbswg=0; // Temperature coeff for pbswg [V/C]
    parameter real cta=0; // Unused: Junction capacitance temperature coeff [1/C]
    parameter real tcj=0; // Temperature coeff for cj [1/C]
    parameter real ctp=0; // Unused: Sidewall junction capacitance temperature coeff [1/C]
    parameter real tcjsw=0; // Temperature coeff for cjsw [1/C]
    parameter real tcjswg=0; // Temperature coeff for cjswg [1/C]
    
    // Noise Model Parameters
    parameter integer noimod=1; // Noise model selector
    parameter real kf=0; // Flicker (1/f) noise coeff
    parameter real af=1; // Flicker (1/f) noise exponent
    parameter real ef=1; // Flicker (1/f) noise frequency exponent
    parameter real em=`NOT_GIVEN; // Flicker (1/f) noise frequency exponent
    parameter real noia=1e20; // Oxide trap density coeff 
    parameter real noib=5e4; // Oxide trap density coeff 
    parameter real noic=-1.4e-12; // Oxide trap density coeff 
    parameter real wnoi=1e-5; // Unused: Channel width for extracted noise parameters [m]
    parameter real flkmod = 0; // Flicker Noise Model
    
    // Auto Model Selector Parameters
    parameter real wmax=1; // Maximum channel width where model is valid [m]
    parameter real wmin=0; // Minimum channel width where model is valid [m]
    parameter real lmax=1; // Maximum channel length where model is valid [m]
    parameter real lmin=0; // Minimum channel length where model is valid [m]
    
    // Operating Region Warning Control Parameters
    parameter real imax=1; // Unused: Maximum allowable current [A]
    parameter real jmax=1e8; // Unused: Maximum allowable current density [A/m2]
    parameter real bvj= `NOT_GIVEN; // Unused: Junction reverse breakdown voltage [V]
    parameter real vbox=1e9; // Unused: Oxide breakdown voltage [V]
    
    // Length Dependent Parameters
    parameter real xl=0; // Unused: Length variation due to masking and etching [m]
    
    // Width Dependent Parameters
    parameter real xw=0; // Unused: Width variation due to masking and etching [m]
    
    // Geometry dependency parameters
    parameter real lcdsc=0.0; // Length dependence of cdsc
    parameter real lcdscb=0.0; // Length dependence of cdscb
    parameter real lcdscd=0.0; // Length dependence of cdscd
    parameter real lcit=0.0; // Length dependence of cit
    parameter real lnfactor=0.0; // Length dependence of nfactor
    parameter real lxj=0.0; // Length dependence of xj
    parameter real lvsat=0.0; // Length dependence of vsa!w!1
    parameter real lat=0.0; // Length dependence of at
    parameter real la0=0.0; // Length dependence of a0 
    parameter real lags=0.0; // Length dependence of ags 
    parameter real la1=0.0; // Length dependence of a1
    parameter real la2=0.0; // Length dependence of a2
    parameter real lketa=0.0; // Length dependence of keta
    parameter real lnsub=0.0; // Length dependence of nsub
    parameter real lnch=0.0; // Length dependence of nch
    parameter real lngate=0.0; // Length dependence of ngate
    parameter real lgamma1=0.0; // Length dependence of gamma1
    parameter real lgamma2=0.0; // Length dependence of gamma2
    parameter real lvbx=0.0; // Length dependence of vbx
    parameter real lvbm=0.0; // Length dependence of vbm
    parameter real lxt=0.0; // Length dependence of xt
    parameter real lk1=0.0; // Length dependence of k1
    parameter real lkt1=0.0; // Length dependence of kt1
    parameter real lkt1l=0.0; // Length dependence of kt1l
    parameter real lkt2=0.0; // Length dependence of kt2
    parameter real lk2=0.0; // Length dependence of k2
    parameter real lk3=0.0; // Length dependence of k3
    parameter real lk3b=0.0; // Length dependence of k3b
    parameter real lw0=0.0; // Length dependence of w0
    parameter real lnlx=0.0; // Length dependence of nlx
    parameter real ldvt0=0.0; // Length dependence of dvt0
    parameter real ldvt1=0.0; // Length dependence of dvt1
    parameter real ldvt2=0.0; // Length dependence of dvt2
    parameter real ldvt0w=0.0; // Length dependence of dvt0w
    parameter real ldvt1w=0.0; // Length dependence of dvt1w
    parameter real ldvt2w=0.0; // Length dependence of dvt2w
    parameter real ldrout=0.0; // Length dependence of drout
    parameter real ldsub=0.0; // Length dependence of dsub
    parameter real lvth0=0.0; // Length dependence of vto
    parameter real lua=0.0; // Length dependence of ua
    parameter real lua1=0.0; // Length dependence of ua1
    parameter real lub=0.0; // Length dependence of ub
    parameter real lub1=0.0; // Length dependence of ub1
    parameter real luc=0.0; // Length dependence of uc
    parameter real luc1=0.0; // Length dependence of uc1
    parameter real lu0=0.0; // Length dependence of u0
    parameter real lute=0.0; // Length dependence of ute
    parameter real lvoff=0.0; // Length dependence of voff
    parameter real lelm=0.0; // Length dependence of elm
    parameter real ldelta=0.0; // Length dependence of delta
    parameter real lrdsw=0.0; // Length dependence of rdsw     
    parameter real lprwg=0.0; // Length dependence of prwg     
    parameter real lprwb=0.0; // Length dependence of prwb     
    parameter real lprt=0.0; // Length dependence of prt     
    parameter real leta0=0.0; // Length dependence of eta0   
    parameter real letab=-0.0; // Length dependence of etab   
    parameter real lpclm=0.0; // Length dependence of pclm   
    parameter real lpdiblc1=0.0; // Length dependence of pdiblc1   
    parameter real lpdiblc2=0.0; // Length dependence of pdiblc2   
    parameter real lpdiblcb=0.0; // Length dependence of pdiblcb   
    parameter real lpscbe1=0.0; // Length dependence of pscbe1   
    parameter real lpscbe2=0; // Length dependence of pscbe2
    //parameter real lpdibl1=0.0;	// Alias, not implemented
    //parameter real lpdibl2=0.0;	// Alias, not implemented
    //parameter real lpdiblb=0.0;	// Alias, not implemented
    //parameter real wpdibl1=0.0;  // Alias, not implemented
    //parameter real wpdibl2=0.0;  // Alias, not implemented
    //parameter real wpdiblb=0.0;  // Alias, not implemented
    //parameter real ppdibl1=0.0;	  // Alias, not implemented
    //parameter real ppdibl2=0.0;	  // Alias, not implemented
    //parameter real ppdiblb=0.0;	  // Alias, not implemented
    parameter real lpvag=0.0; // Length dependence of pvag   
    parameter real lwr=0.0; // Length dependence of wr
    parameter real ldwg=0.0; // Length dependence of dwg
    parameter real ldwb=0.0; // Length dependence of dwb
    parameter real lb0=0.0; // Length dependence of b0
    parameter real lb1=0.0; // Length dependence of b1
    parameter real lcgsl=0.0; // Length dependence of cgsl
    parameter real lcgdl=0.0; // Length dependence of cgdl
    parameter real lckappa=0.0; // Length dependence of ckappa
    parameter real lcf=0.0; // Length dependence of cf
    parameter real lclc=0.0; // Length dependence of clc
    parameter real lcle=0.0; // Length dependence of cle
    parameter real lalpha0=0.0; // Length dependence of alpha0
    parameter real lalpha1=0.0; // Length dependence of alpha1
    parameter real lbeta0=0.0; // Length dependence of beta0
    parameter real lvfbcv=0.0; // Length dependence of vfbcv
    parameter real lvfb=0.0; // Length dependence of vfb
    parameter real lacde=0.0; // Length dependence of acde
    parameter real lmoin=0.0; // Length dependence of moin
    parameter real lnoff=0.0; // Length dependence of noff
    parameter real lvoffcv=0.0; // Length dependence of voffcv
    parameter real wcdsc=0.0; // Width dependence of cdsc
    parameter real wcdscb=0.0; // Width dependence of cdscb  
    parameter real wcdscd=0.0; // Width dependence of cdscd  
    parameter real wcit=0.0; // Width dependence of cit
    parameter real wnfactor=0.0; // Width dependence of nfactor
    parameter real wxj=0.0; // Width dependence of xj
    parameter real wvsat=0.0; // Width dependence of vsat
    parameter real wat=0.0; // Width dependence of at
    parameter real wa0=0.0; // Width dependence of a0 
    parameter real wags=0.0; // Width dependence of ags 
    parameter real wa1=0.0; // Width dependence of a1
    parameter real wa2=0.0; // Width dependence of a2
    parameter real wketa=0.0; // Width dependence of keta
    parameter real wnsub=0.0; // Width dependence of nsub
    parameter real wnch=0.0; // Width dependence of nch
    parameter real wngate=0.0; // Width dependence of ngate
    parameter real wgamma1=0.0; // Width dependence of gamma1
    parameter real wgamma2=0.0; // Width dependence of gamma2
    parameter real wvbx=0.0; // Width dependence of vbx
    parameter real wvbm=0.0; // Width dependence of vbm
    parameter real wxt=0.0; // Width dependence of xt
    parameter real wk1=0.0; // Width dependence of k1
    parameter real wkt1=0.0; // Width dependence of kt1
    parameter real wkt1l=0.0; // Width dependence of kt1l
    parameter real wkt2=0.0; // Width dependence of kt2
    parameter real wk2=0.0; // Width dependence of k2
    parameter real wk3=0.0; // Width dependence of k3
    parameter real wk3b=0.0; // Width dependence of k3b
    parameter real ww0=0.0; // Width dependence of w0
    parameter real wnlx=0.0; // Width dependence of nlx
    parameter real wdvt0=0.0; // Width dependence of dvt0
    parameter real wdvt1=0.0; // Width dependence of dvt1
    parameter real wdvt2=0.0; // Width dependence of dvt2
    parameter real wdvt0w=0.0; // Width dependence of dvt0w
    parameter real wdvt1w=0.0; // Width dependence of dvt1w
    parameter real wdvt2w=0.0; // Width dependence of dvt2w
    parameter real wdrout=0.0; // Width dependence of drout
    parameter real wdsub=0.0; // Width dependence of dsub
    parameter real wvth0=0.0; // Width dependence of vto
    //parameter real wvtho=0.0; // Alias, unused
    parameter real wua=0.0; // Width dependence of ua
    parameter real wua1=0.0; // Width dependence of ua1
    parameter real wub=0.0; // Width dependence of ub
    parameter real wub1=0.0; // Width dependence of ub1
    parameter real wuc=0.0; // Width dependence of uc
    parameter real wuc1=0.0; // Width dependence of uc1
    parameter real wu0=0.0; // Width dependence of u0
    parameter real wute=0.0; // Width dependence of ute
    parameter real wvoff=0.0; // Width dependence of voff
    parameter real welm=0.0; // Width dependence of elm
    parameter real wdelta=0.0; // Width dependence of delta
    parameter real wrdsw=0.0; // Width dependence of rdsw 
    parameter real wprwg=0.0; // Width dependence of prwg 
    parameter real wprwb=0.0; // Width dependence of prwb 
    parameter real wprt=0.0; // Width dependence of prt
    parameter real weta0=0.0; // Width dependence of eta0   
    parameter real wetab=0.0; // Width dependence of etab   
    parameter real wpclm=0.0; // Width dependence of pclm   
    parameter real wpdiblc1=0.0; // Width dependence of pdiblc1   
    parameter real wpdiblc2=0.0; // Width dependence of pdiblc2   
    parameter real wpdiblcb=0.0; // Width dependence of pdiblcb   
    parameter real wpscbe1=0.0; // Width dependence of pscbe1   
    parameter real wpscbe2=0.0; // Width dependence of pscbe2   
    parameter real wpvag=0.0; // Width dependence of pvag   
    parameter real wwr=0.0; // Width dependence of wr
    parameter real wdwg=0.0; // Width dependence of dwg
    parameter real wdwb=0.0; // Width dependence of dwb
    parameter real wb0=0.0; // Width dependence of b0
    parameter real wb1=0.0; // Width dependence of b1
    parameter real wcgsl=0.0; // Width dependence of cgsl
    parameter real wcgdl=0.0; // Width dependence of cgdl
    parameter real wckappa=0.0; // Width dependence of ckappa
    parameter real wcf=0.0; // Width dependence of cf
    parameter real wclc=0.0; // Width dependence of clc
    parameter real wcle=0.0; // Width dependence of cle
    parameter real walpha0=0.0; // Width dependence of alpha0
    parameter real walpha1=0.0; // Width dependence of alpha1
    parameter real wbeta0=0.0; // Width dependence of beta0
    parameter real wvfbcv=0.0; // Width dependence of vfbcv
    parameter real wvfb=0.0; // Width dependence of vfb
    parameter real wacde=0.0; // Width dependence of acde
    parameter real wmoin=0.0; // Width dependence of moin
    parameter real wnoff=0.0; // Width dependence of noff
    parameter real wvoffcv=0.0; // Width dependence of voffcv
    parameter real pcdsc=0.0; // Cross-term dependence of cdsc
    parameter real pcdscb=0.0; // Cross-term dependence of cdscb 
    parameter real pcdscd=0.0; // Cross-term dependence of cdscd
    parameter real pcit=0.0; // Cross-term dependence of cit
    parameter real pnfactor=0.0; // Cross-term dependence of nfactor
    parameter real pxj=0.0; // Cross-term dependence of xj
    parameter real pvsat=0.0; // Cross-term dependence of vsat
    parameter real pat=0.0; // Cross-term dependence of at
    parameter real pa0=0.0; // Cross-term dependence of a0 
    parameter real pags=0.0; // Cross-term dependence of ags
    parameter real pa1=0.0; // Cross-term dependence of a1
    parameter real pa2=0.0; // Cross-term dependence of a2
    parameter real pketa=0.0; // Cross-term dependence of keta
    parameter real pnsub=0.0; // Cross-term dependence of nsub
    parameter real pnch=0.0; // Cross-term dependence of nch
    parameter real pngate=0.0; // Cross-term dependence of ngate
    parameter real pgamma1=0.0; // Cross-term dependence of gamma1
    parameter real pgamma2=0.0; // Cross-term dependence of gamma2
    parameter real pvbx=0.0; // Cross-term dependence of vbx
    parameter real pvbm=0.0; // Cross-term dependence of vbm
    parameter real pxt=0.0; // Cross-term dependence of xt
    parameter real pk1=0.0; // Cross-term dependence of k1
    parameter real pkt1=0.0; // Cross-term dependence of kt1
    parameter real pkt1l=0.0; // Cross-term dependence of kt1l
    parameter real pkt2=0.0; // Cross-term dependence of kt2
    parameter real pk2=0.0; // Cross-term dependence of k2
    parameter real pk3=0.0; // Cross-term dependence of k3
    parameter real pk3b=0.0; // Cross-term dependence of k3b
    parameter real pw0=0.0; // Cross-term dependence of w0
    parameter real pnlx=0.0; // Cross-term dependence of nlx
    parameter real pdvt0=0.0; // Cross-term dependence of dvt0
    parameter real pdvt1=0.0; // Cross-term dependence of dvt1
    parameter real pdvt2=0.0; // Cross-term dependence of dvt2
    parameter real pdvt0w=0.0; // Cross-term dependence of dvt0w
    parameter real pdvt1w=0.0; // Cross-term dependence of dvt1w
    parameter real pdvt2w=0.0; // Cross-term dependence of dvt2w
    parameter real pdrout=0.0; // Cross-term dependence of drout
    parameter real pdsub=0.0; // Cross-term dependence of dsub
    parameter real pvth0=0.0; // Cross-term dependence of vto
    //parameter real pvtho=0.0; // Alias of pvth0
    parameter real pua=0.0; // Cross-term dependence of ua
    parameter real pua1=0.0; // Cross-term dependence of ua1
    parameter real pub=0.0; // Cross-term dependence of ub
    parameter real pub1=0.0; // Cross-term dependence of ub1
    parameter real puc=0.0; // Cross-term dependence of uc
    parameter real puc1=0.0; // Cross-term dependence of uc1
    parameter real pu0=0.0; // Cross-term dependence of u0
    parameter real pute=0.0; // Cross-term dependence of ute
    parameter real pvoff=0.0; // Cross-term dependence of voff
    parameter real pelm=0.0; // Cross-term dependence of elm
    parameter real pdelta=0.0; // Cross-term dependence of delta
    parameter real prdsw=0.0; // Cross-term dependence of rdsw     
    parameter real pprwg=0.0; // Cross-term dependence of prwg     
    parameter real pprwb=0.0; // Cross-term dependence of prwb     
    parameter real pprt=0.0; // Cross-term dependence of prt 
    parameter real peta0=0.0; // Cross-term dependence of eta0
    parameter real petab=0.0; // Cross-term dependence of etab
    parameter real ppclm=0.0; // Cross-term dependence of pclm
    parameter real ppdiblc1=0.0; // Cross-term dependence of pdiblc1
    parameter real ppdiblc2=0.0; // Cross-term dependence of pdiblc2
    parameter real ppdiblcb=0.0; // Cross-term dependence of pdiblcb
    parameter real ppscbe1=0.0; // Cross-term dependence of pscbe1
    parameter real ppscbe2=0.0; // Cross-term dependence of pscbe2
    parameter real ppvag=0.0; // Cross-term dependence of pvag   
    parameter real pwr=0.0; // Cross-term dependence of wr
    parameter real pdwg=0.0; // Cross-term dependence of dwg
    parameter real pdwb=0.0; // Cross-term dependence of dwb
    parameter real pb0=0.0; // Cross-term dependence of b0
    parameter real pb1=0.0; // Cross-term dependence of b1
    parameter real pcgsl=0.0; // Cross-term dependence of cgsl
    parameter real pcgdl=0.0; // Cross-term dependence of cgdl
    parameter real pckappa=0.0; // Cross-term dependence of ckappa
    parameter real pcf=0.0; // Cross-term dependence of cf
    parameter real pclc=0.0; // Cross-term dependence of clc
    parameter real pcle=0.0; // Cross-term dependence of cle
    parameter real palpha0=0.0; // Cross-term dependence of alpha0
    parameter real palpha1=0.0; // Cross-term dependence of alpha1
    parameter real pbeta0=0.0; // Cross-term dependence of beta0
    parameter real pvfbcv=0.0; // Cross-term dependence of vfbcv
    parameter real pvfb=0.0; // Cross-term dependence of vfb
    parameter real pacde=0.0; // Cross-term dependence of acde
    parameter real pmoin=0.0; // Cross-term dependence of moin
    parameter real pnoff=0.0; // Cross-term dependence of noff
    parameter real pvoffcv=0.0; // Cross-term dependence of voffcv

    parameter real lnpeak=0.0;
    parameter real wnpeak=0.0;
    parameter real pnpeak=0.0;
    //New model: bsim4 igcmod and igbmod as hspice does
    parameter integer igcmod=0.0;
    parameter integer gidlmod=0; // BSIM4 gidlmod flag set to 0 as compatiable to hspice
    parameter integer igbmod=0.0;
    parameter integer tempmod=0.0;
    parameter real agidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lagidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wagidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pagidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real egidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real legidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wegidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pegidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real nigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lnigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wnigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pnigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real aigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real laigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real waigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real paigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcigc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real aigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real laigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real waigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real paigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real aigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real laigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real waigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real paigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real eigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real leigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real weigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real peigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real nigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lnigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wnigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pnigbinv = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real toxe = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real vtm0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real toxref = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real ntox = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lntox = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wntox = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pntox = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pigcd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lpigcd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wpigcd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real ppigcd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real nsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lnsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wnsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pnsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real vfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real tvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real ltvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wtvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real ptvfbsdoff = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real poxedge = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lpoxedge = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wpoxedge = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real ppoxedge = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real dlcig = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real aigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real laigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real waigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real paigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcigsd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real nigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lnigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wnigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pnigbacc = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real agisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wagisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lagisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pagisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real egisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wegisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real legisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pegisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real rgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wrgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lrgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real prgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real kgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wkgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lkgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pkgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real fgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wfgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lfgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pfgisl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real rgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wrgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lrgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real prgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real kgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wkgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lkgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pkgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real fgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wfgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lfgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pfgidl = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real aigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real waigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real laigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real paigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcigs = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real aigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real waigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real laigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real paigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real bigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wbigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lbigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pbigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real cigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wcigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lcigd = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pcigd = `NOT_GIVEN;		//Enh new params version 3.3    
    
    //New model for ACM calculation
    parameter integer acm = `INT_NOT_GIVEN;
    parameter integer calcacm = `INT_NOT_GIVEN;
    parameter integer vfbflag = 0;
    //New model for breakdown diode model
    parameter integer breakmod = 0;
    parameter real bvs = 10.0;
    parameter real bvd = bvs;
    parameter real ijthsrev = 0.1;
    parameter real ijthdrev = ijthsrev;
    parameter real xjbvs = 1.0;
    parameter real xjbvd = xjbvs;
    //New model for stimod (stress model) 
    parameter integer stimod = 0 from [0:2];
    parameter real sa=`NOT_GIVEN; //built-in BSIM4 STI model
    parameter real saref=`NOT_GIVEN; //built-in BSIM4 STI model,default 1u
    parameter real sa0=saref;  //alias to saref
    parameter real sb=`NOT_GIVEN;
    parameter real sbref=`NOT_GIVEN; //built-in BSIM4 STI model,default 1u
    parameter real sb0=sbref;  //alias to sbref
    parameter real sd=0.0;
    parameter real nf=1.0;
    parameter real sa1 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa2 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa3 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa4 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa5 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa6 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa7 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa8 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa9 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sa10 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb1 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb2 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb3 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb4 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb5 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb6 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb7 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb8 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb9 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sb10 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw1 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw2 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw3 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw4 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw5 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw6 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw7 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw8 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw9 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real sw10 = `NOT_GIVEN;		//Enh new params version 3.3

    parameter real wlod = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real ku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real kvsat = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real kvth0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real tku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real llodku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wlodku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real llodvth = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wlodvth = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pku0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lkvth0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real wkvth0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real pkvth0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real stk2 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lodk2 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real steta0 = `NOT_GIVEN;		//Enh new params version 3.3
    parameter real lodeta0 = `NOT_GIVEN;		//Enh new params version 3.3
    
    parameter real vgslim = 0.0;
    parameter real dtoxcv = 0.0;
    //New model binflag
    parameter integer binflag = 0;
    parameter integer geo = 0;
    parameter real lref = 0.0;
    parameter real wref = 0.0;
    parameter real xlref = 0.0;
    parameter real xwref = 0.0;
    parameter real wmlt = 1.0;
    parameter real lmlt = 1.0;
    //parameter real xmlt = 1.0;
    parameter real wd = 0.0;
    parameter real ld = 0.0;
    parameter real del = 0.0;
    //New model delta instances
    parameter real mulu0=1.0;
    parameter real mulua=1.0;
    parameter real mulub=1.0;
    parameter real deltox=0.0;
    parameter real delk1=0.0;
    parameter real delnfct=0.0;
    parameter real delvto=0.0;

    real BSIM3vgslim;
    //New model for breakdown diode model
    real BSIM3bvs,BSIM3bvd,BSIM3ijthsrev,BSIM3ijthdrev,BSIM3xjbvs,BSIM3xjbvd,BSIM3XExpBVD,BSIM3vjdmFwd,BSIM3vjsmFwd;
    real BSIM3DrainSatCurrent,BSIM3IVjdmFwd,BSIM3DslpFwd,BSIM3vjdmRev,BSIM3IVjdmRev;
    real BSIM3DslpRev,BSIM3XExpBVS,BSIM3SourceSatCurrent,BSIM3IVjsmFwd,BSIM3SslpFwd;
    real BSIM3vjsmRev,BSIM3IVjsmRev,BSIM3SslpRev;

    real BSIM3thetavth, BSIM3cgdo, BSIM3cgso, BSIM3drainArea, BSIM3sourceArea;
    real BSIM3drainSquares, BSIM3sourceSquares, BSIM3drainPerimeter;
    real BSIM3sourcePerimeter, BSIM3sourceResistance, BSIM3drainResistance; 
    real BSIM3vjsm, BSIM3IsEvjsm, BSIM3vjdm, BSIM3IsEvjdm;
    
    integer BSIM3mode, BSIM3nqsMod, Fatal_Flag;

    real BSIM3cdsc, BSIM3cdscb, BSIM3cdscd, BSIM3cit, BSIM3nfactor, BSIM3xj;
    real BSIM3vsat, BSIM3at, BSIM3a0, BSIM3ags, BSIM3a1, BSIM3a2, BSIM3keta;
    real BSIM3nsub, BSIM3npeak, BSIM3ngate, BSIM3gamma1, BSIM3gamma2, BSIM3vbx;
    real BSIM3vbi, BSIM3vbm, BSIM3vbsc, BSIM3xt, BSIM3phi, BSIM3litl, BSIM3k1;
    real BSIM3kt1, BSIM3kt1l, BSIM3kt2, BSIM3k2, BSIM3k3, BSIM3k3b, BSIM3w0;
    real BSIM3nlx, BSIM3dvt0, BSIM3dvt1, BSIM3dvt2, BSIM3dvt0w, BSIM3dvt1w;
    real BSIM3dvt2w, BSIM3drout, BSIM3dsub, BSIM3vth0, BSIM3ua, BSIM3ua1;
    real BSIM3ub, BSIM3ub1, BSIM3uc, BSIM3uc1, BSIM3u0, BSIM3ute, BSIM3voff;
    real BSIM3vfb, BSIM3delta, BSIM3rdsw, BSIM3rds0, BSIM3prwg, BSIM3prwb;
    real BSIM3prt, BSIM3eta0, BSIM3etab, BSIM3pclm, BSIM3pdibl1, BSIM3pdibl2;
    real BSIM3pdiblb, BSIM3pscbe1, BSIM3pscbe2, BSIM3pvag, BSIM3wr, BSIM3dwg;
    real BSIM3dwb, BSIM3b0, BSIM3b1, BSIM3alpha0, BSIM3alpha1, BSIM3beta0;

    /* CV model */
    real BSIM3elm, BSIM3lelm, BSIM3pelm, BSIM3welm; 
    real BSIM3cgsl, BSIM3cgdl, BSIM3ckappa, BSIM3cf, BSIM3clc;
    real BSIM3cle, BSIM3vfbcv, BSIM3noff, BSIM3voffcv, BSIM3acde, BSIM3moin;

    /* Pre-calculated constants */
    real BSIM3dw, BSIM3dl, BSIM3leff, BSIM3weff, BSIM3dwc, BSIM3dlc;
    real BSIM3leffCV, BSIM3weffCV, BSIM3abulkCVfactor, BSIM3cgbo;
    real BSIM3u0temp;
    real BSIM3vsattemp,  BSIM3sqrtPhi, BSIM3phis3, BSIM3Xdep0, BSIM3theta0vb0;
    real BSIM3thetaRout, BSIM3cdep0, BSIM3vfbzb, BSIM3ldeb, BSIM3k1ox; 
    real BSIM3k2ox, BSIM3tox, BSIM3toxm, BSIM3ijth;
    real BSIM3tcj, BSIM3tcjsw, BSIM3tcjswg, BSIM3tpb, BSIM3tpbsw, BSIM3tpbswg;

    integer BSIM3type, BSIM3mobMod, BSIM3capMod, BSIM3noiMod;
    integer BSIM3binUnit;

    /* Length Dependence */
    real BSIM3lcdsc, BSIM3lcdscb, BSIM3lcdscd, BSIM3lcit, BSIM3lnfactor;
    real BSIM3lxj, BSIM3lvsat, BSIM3lat, BSIM3la0, BSIM3lags, BSIM3la1;
    real BSIM3la2;
    real BSIM3lketa, BSIM3lnsub, BSIM3lnpeak, BSIM3lngate, BSIM3lgamma1;
    real BSIM3lgamma2, BSIM3lvbx, BSIM3lvbm, BSIM3lxt, BSIM3lk1, BSIM3lkt1;
    real BSIM3lkt1l, BSIM3lkt2, BSIM3lk2, BSIM3lk3, BSIM3lk3b, BSIM3lw0;
    real BSIM3lnlx, BSIM3ldvt0, BSIM3ldvt1, BSIM3ldvt2, BSIM3ldvt0w;
    real BSIM3ldvt1w;
    real BSIM3ldvt2w, BSIM3ldrout, BSIM3ldsub, BSIM3lvth0, BSIM3lua, BSIM3lua1;
    real BSIM3lub, BSIM3lub1, BSIM3luc, BSIM3luc1, BSIM3lu0, BSIM3lute;
    real BSIM3lvoff, BSIM3ldelta, BSIM3lrdsw, BSIM3lprwg, BSIM3lprwb, BSIM3lprt;
    real BSIM3leta0, BSIM3letab, BSIM3lpclm, BSIM3lpdibl1, BSIM3lpdibl2;
    real BSIM3lpdiblb, BSIM3lpscbe1, BSIM3lpscbe2, BSIM3lpvag, BSIM3lwr;
    real BSIM3ldwg, BSIM3ldwb, BSIM3lb0, BSIM3lb1, BSIM3lalpha0, BSIM3lalpha1;
    real BSIM3lbeta0, BSIM3lvfb;

    /* CV model */
    real BSIM3lcgsl, BSIM3lcgdl, BSIM3lckappa, BSIM3lcf;
    real BSIM3lclc, BSIM3lcle, BSIM3lvfbcv, BSIM3lnoff, BSIM3lvoffcv;
    real BSIM3lmoin, BSIM3lacde;

    /* Width Dependence */
    real BSIM3wcdsc, BSIM3wcdscb, BSIM3wcdscd, BSIM3wcit, BSIM3wnfactor;
    real BSIM3wxj, BSIM3wvsat, BSIM3wat, BSIM3wa0, BSIM3wags, BSIM3wa1;
    real BSIM3wketa, BSIM3wnsub, BSIM3wnpeak, BSIM3wngate, BSIM3wgamma1;
    real BSIM3wgamma2, BSIM3wvbx, BSIM3wvbm, BSIM3wxt, BSIM3wk1, BSIM3wkt1;
    real BSIM3wkt1l, BSIM3wkt2, BSIM3wk2, BSIM3wk3, BSIM3wk3b, BSIM3ww0;
    real BSIM3wnlx, BSIM3wdvt0, BSIM3wdvt1, BSIM3wdvt2, BSIM3wdvt0w;
    real BSIM3wdvt1w, BSIM3wa2;
    real BSIM3wdvt2w, BSIM3wdrout, BSIM3wdsub, BSIM3wvth0, BSIM3wua, BSIM3wua1;
    real BSIM3wub, BSIM3wub1, BSIM3wuc, BSIM3wuc1, BSIM3wu0, BSIM3wute;
    real BSIM3wvoff, BSIM3wdelta, BSIM3wrdsw, BSIM3wprwg, BSIM3wprwb, BSIM3wprt;
    real BSIM3weta0, BSIM3wetab, BSIM3wpclm, BSIM3wpdibl1, BSIM3wpdibl2;
    real BSIM3wpdiblb, BSIM3wpscbe1, BSIM3wpscbe2, BSIM3wpvag, BSIM3wwr;
    real BSIM3wdwg, BSIM3wdwb, BSIM3wb0, BSIM3wb1, BSIM3walpha0, BSIM3walpha1;
    real BSIM3wbeta0, BSIM3wvfb;

    /* CV model */
    real BSIM3wcgsl, BSIM3wcgdl, BSIM3wckappa, BSIM3wcf, BSIM3wclc;
    real BSIM3wcle, BSIM3wvfbcv, BSIM3wnoff, BSIM3wvoffcv;
    real BSIM3wacde, BSIM3wmoin;

    /* Cross-term Dependence */
    real BSIM3pcdsc, BSIM3pcdscb, BSIM3pcdscd, BSIM3pcit, BSIM3pnfactor;
    real BSIM3pxj, BSIM3pvsat, BSIM3pat, BSIM3pa0, BSIM3pags;
    real BSIM3pa1, BSIM3pa2, BSIM3pdvt1w;
    real BSIM3pketa, BSIM3pnsub, BSIM3pnpeak, BSIM3pngate, BSIM3pgamma1;
    real BSIM3pgamma2, BSIM3pvbx, BSIM3pvbm, BSIM3pxt, BSIM3pk1, BSIM3pkt1;
    real BSIM3pkt1l, BSIM3pkt2, BSIM3pk2, BSIM3pk3, BSIM3pk3b, BSIM3pw0;
    real BSIM3pnlx, BSIM3pdvt0, BSIM3pdvt1, BSIM3pdvt2, BSIM3pdvt0w;
    real BSIM3pdvt2w, BSIM3pdrout, BSIM3pdsub, BSIM3pvth0, BSIM3pua, BSIM3pua1;
    real BSIM3pub, BSIM3pub1, BSIM3puc, BSIM3puc1, BSIM3pu0, BSIM3pute;
    real BSIM3pvoff, BSIM3pdelta, BSIM3prdsw, BSIM3pprwg, BSIM3pprwb, BSIM3pprt;
    real BSIM3peta0, BSIM3petab, BSIM3ppclm, BSIM3ppdibl1, BSIM3ppdibl2;
    real BSIM3ppdiblb, BSIM3ppscbe1, BSIM3ppscbe2, BSIM3ppvag, BSIM3pwr;
    real BSIM3pdwg, BSIM3pdwb, BSIM3pb0, BSIM3pb1, BSIM3palpha0, BSIM3palpha1;
    real BSIM3pbeta0, BSIM3pvfb;

    /* CV model */
    real BSIM3pcgsl, BSIM3pcgdl, BSIM3pckappa, BSIM3pcf, BSIM3pclc;
    real BSIM3pcle, BSIM3pvfbcv, BSIM3pnoff, BSIM3pvoffcv, BSIM3pacde;
    real BSIM3tnom, BSIM3xpart, BSIM3pmoin;
    real BSIM3sheetResistance, BSIM3jctSatCurDensity;
    real BSIM3jctSidewallSatCurDensity, BSIM3bulkJctPotential;
    real BSIM3bulkJctBotGradingCoeff, BSIM3bulkJctSideGradingCoeff;
    real BSIM3bulkJctGateSideGradingCoeff, BSIM3sidewallJctPotential;
    real BSIM3GatesidewallJctPotential, BSIM3unitAreaJctCap;
    real BSIM3unitLengthSidewallJctCap, BSIM3unitLengthGateSidewallJctCap;
    real BSIM3jctEmissionCoeff, BSIM3jctTempExponent, BSIM3Lint, BSIM3Ll;
    real BSIM3Llc, BSIM3Lln, BSIM3Lw, BSIM3Lwc, BSIM3Lwn, BSIM3Lwl, BSIM3Lwlc;
    real BSIM3Wint, BSIM3Wl, BSIM3Wlc, BSIM3Wln, BSIM3Ww;
    real BSIM3Wwc, BSIM3Wwn, BSIM3Wwl, BSIM3Wwlc;

    /* Pre-calculated constants */
    /* MCJ: move to size-dependent param. */
    real BSIM3vtm, BSIM3cox;
    real BSIM3factor1, BSIM3PhiB, BSIM3PhiBSW, BSIM3PhiBSWG;
    real BSIM3jctTempSatCurDensity, BSIM3jctSidewallTempSatCurDensity;
    real BSIM3unitAreaTempJctCap, BSIM3unitLengthSidewallTempJctCap;
    real BSIM3unitLengthGateSidewallTempJctCap;
    real BSIM3em, BSIM3ef;
    real BSIM3af, BSIM3kf;

    integer BSIM3npeakGiven, BSIM3k1Given, BSIM3k2Given, BSIM3nsubGiven;
    integer BSIM3xtGiven, BSIM3vbxGiven, BSIM3gamma1Given, BSIM3gamma2Given;
    integer BSIM3vth0Given, BSIM3dlcGiven;
    
    // Some variables conflict with parameter names are renamed to local_
    real SourceSatCurrent, DrainSatCurrent;
    real qgd, qgs, qgb, VgstNVt, ExpVgst, qbs, qbd;
       
    real czbd, czbdsw, czbdswg, czbs, czbssw, czbsswg;
    real evbd, evbs, arg, sarg;
    real Vfbeff, V3, V4, MJ, MJSW, MJSWG;
    real vbd, vbs, vds, vgb, vgd, vgs, qgate, qbulk, qdrn, qsrc;
    // real qinoi;
    real Vds, Vgs, Vbs, Vgs_eff, Vfb;
    real Phis, sqrtPhis, Vth, Vgst, Nvtm;
    real Vtm;
    real n, local_voffcv, local_noff;
    real ExpArg, V0, CoxWLcen, LINK, DeltaPhi, VgDP; //v3.25
    real Cox, Tox, Tcen, Ccen, Coxeff, Denomi, ueff, Esat;
    real Vdsat, EsatL, Vasat, Va, Vbseff, VbseffCV;
    real Arg1, One_Third_CoxWL, Two_Third_CoxWL, Alphaz, CoxWL; 
    real T0, T1, T2, dT2_dVg, T3, T4, T5, T6, T7, T8, T9, T10;
    real T11, T12, T13, T14;
    real tmp, Abulk, Abulk0,X1,X2,Vgs_x2,vgsmax_t3,Vgs_lim,vgslim_t3;
    real VACLM, VADIBL, Xdep, lt1, ltw, Delt_vth;
    real Theta0, TempRatio, tmp1, tmp2, tmp3, tmp4;
    real DIBL_Sft, dDIBL_Sft_dVd, Lambda;
    real Vgsteff;
    real Vdseff, VdseffCV, diffVds, beta, gche, fgche1, fgche2;
    real Idl, Idsa, Ibs, Ibd, Ids, Gm, Gds, Gmb;
    real Isub, VASCBE, CoxWovL;
    real Rds, WVCox, WVCoxRds, Vgst2Vtm, VdsatCV, Leff, Weff;
    real AbulkCV, qgdo, qgso, local_cgdo, local_cgso;
    real Qac0, Qsub0;
    real BSIM3cbs, BSIM3cbd; 
    real Eg, Eg0, ni, Ldrn, Wdrn;
    real delTemp, T, TRatio, Inv_L, Inv_W, Inv_LW, Vtm0,Inv_sa0,Inv_sb0;
    real dAbulk_dVg;
    real vgs_eff, vgd_eff;
    //New model
    real here_w,larg,warg,rseff,rdeff,val,ecjgat,ecjsw,xmult;
    real rdpr,rspr,Lnew,Wnew,devbsdvbs,devbddvbd;
    integer BSIM3binflag, BSIM3breakmod;

    //New model: bsim4 igcmod and igbmod as hspice does
    integer BSIM3igcMod,BSIM3igbMod,BSIM3tempMod;
    real BSIM3agidl,BSIM3lagidl,BSIM3wagidl,BSIM3pagidl,BSIM3bgidl;
    integer BSIM3agidlGiven,BSIM3lagidlGiven,BSIM3wagidlGiven,BSIM3pagidlGiven,BSIM3bgidlGiven;
    real BSIM3lbgidl,BSIM3wbgidl,BSIM3pbgidl,BSIM3cgidl,BSIM3lcgidl;
    integer BSIM3lbgidlGiven,BSIM3wbgidlGiven,BSIM3pbgidlGiven,BSIM3cgidlGiven,BSIM3lcgidlGiven;
    real BSIM3wcgidl,BSIM3pcgidl,BSIM3egidl,BSIM3legidl,BSIM3wegidl;
    integer BSIM3wcgidlGiven,BSIM3pcgidlGiven,BSIM3egidlGiven,BSIM3legidlGiven,BSIM3wegidlGiven;
    real BSIM3pegidl,BSIM3nigc,BSIM3lnigc,BSIM3wnigc,BSIM3pnigc;
    integer BSIM3pegidlGiven,BSIM3nigcGiven,BSIM3lnigcGiven,BSIM3wnigcGiven,BSIM3pnigcGiven;
    real BSIM3aigc,BSIM3laigc,BSIM3waigc,BSIM3paigc,BSIM3bigc;
    integer BSIM3aigcGiven,BSIM3laigcGiven,BSIM3waigcGiven,BSIM3paigcGiven,BSIM3bigcGiven;
    real BSIM3lbigc,BSIM3wbigc,BSIM3pbigc,BSIM3cigc,BSIM3lcigc;
    integer BSIM3lbigcGiven,BSIM3wbigcGiven,BSIM3pbigcGiven,BSIM3cigcGiven,BSIM3lcigcGiven;
    real BSIM3wcigc,BSIM3pcigc,BSIM3aigbacc,BSIM3laigbacc,BSIM3waigbacc;
    integer BSIM3wcigcGiven,BSIM3pcigcGiven,BSIM3aigbaccGiven,BSIM3laigbaccGiven,BSIM3waigbaccGiven;
    real BSIM3paigbacc,BSIM3bigbacc,BSIM3lbigbacc,BSIM3wbigbacc,BSIM3pbigbacc;
    integer BSIM3paigbaccGiven,BSIM3bigbaccGiven,BSIM3lbigbaccGiven,BSIM3wbigbaccGiven,BSIM3pbigbaccGiven;
    real BSIM3cigbacc,BSIM3lcigbacc,BSIM3wcigbacc,BSIM3pcigbacc,BSIM3aigbinv;
    integer BSIM3cigbaccGiven,BSIM3lcigbaccGiven,BSIM3wcigbaccGiven,BSIM3pcigbaccGiven,BSIM3aigbinvGiven;
    real BSIM3laigbinv,BSIM3waigbinv,BSIM3paigbinv,BSIM3bigbinv,BSIM3lbigbinv;
    integer BSIM3laigbinvGiven,BSIM3waigbinvGiven,BSIM3paigbinvGiven,BSIM3bigbinvGiven,BSIM3lbigbinvGiven;
    real BSIM3wbigbinv,BSIM3pbigbinv,BSIM3cigbinv,BSIM3lcigbinv,BSIM3wcigbinv;
    integer BSIM3wbigbinvGiven,BSIM3pbigbinvGiven,BSIM3cigbinvGiven,BSIM3lcigbinvGiven,BSIM3wcigbinvGiven;
    real BSIM3pcigbinv,BSIM3eigbinv,BSIM3leigbinv,BSIM3weigbinv,BSIM3peigbinv;
    integer BSIM3pcigbinvGiven,BSIM3eigbinvGiven,BSIM3leigbinvGiven,BSIM3weigbinvGiven,BSIM3peigbinvGiven;
    real BSIM3nigbinv,BSIM3lnigbinv,BSIM3wnigbinv,BSIM3pnigbinv,BSIM3toxe;
    integer BSIM3nigbinvGiven,BSIM3lnigbinvGiven,BSIM3wnigbinvGiven,BSIM3pnigbinvGiven,BSIM3toxeGiven;
    real BSIM3vtm0,BSIM3toxref,BSIM3ntox,BSIM3lntox,BSIM3wntox;
    integer BSIM3vtm0Given,BSIM3toxrefGiven,BSIM3ntoxGiven,BSIM3lntoxGiven,BSIM3wntoxGiven;
    real BSIM3pntox,BSIM3pigcd,BSIM3lpigcd,BSIM3wpigcd,BSIM3ppigcd;
    integer BSIM3pntoxGiven,BSIM3pigcdGiven,BSIM3lpigcdGiven,BSIM3wpigcdGiven,BSIM3ppigcdGiven;
    real BSIM3nsd,BSIM3lnsd,BSIM3wnsd,BSIM3pnsd,BSIM3vfbsdoff,BSIM3vfbsd;
    integer BSIM3nsdGiven,BSIM3lnsdGiven,BSIM3wnsdGiven,BSIM3pnsdGiven,BSIM3vfbsdoffGiven,BSIM3vfbGiven;
    real BSIM3lvfbsdoff,BSIM3wvfbsdoff,BSIM3pvfbsdoff,BSIM3tvfbsdoff,BSIM3ltvfbsdoff;
    integer BSIM3lvfbsdoffGiven,BSIM3wvfbsdoffGiven,BSIM3pvfbsdoffGiven,BSIM3tvfbsdoffGiven,BSIM3ltvfbsdoffGiven;
    real BSIM3wtvfbsdoff,BSIM3ptvfbsdoff,BSIM3poxedge,BSIM3lpoxedge,BSIM3wpoxedge;
    integer BSIM3wtvfbsdoffGiven,BSIM3ptvfbsdoffGiven,BSIM3poxedgeGiven,BSIM3lpoxedgeGiven,BSIM3wpoxedgeGiven;
    real BSIM3waigs,BSIM3laigs,BSIM3paigs,BSIM3bigs;
    integer BSIM3aigsGiven,BSIM3waigsGiven,BSIM3laigsGiven,BSIM3paigsGiven,BSIM3bigsGiven;
    real BSIM3wbigs,BSIM3lbigs,BSIM3pbigs,BSIM3cigs,BSIM3wcigs;
    integer BSIM3wbigsGiven,BSIM3lbigsGiven,BSIM3pbigsGiven,BSIM3cigsGiven,BSIM3wcigsGiven;
    real BSIM3lcigs,BSIM3pcigs,BSIM3waigd,BSIM3laigd;
    integer BSIM3lcigsGiven,BSIM3pcigsGiven,BSIM3aigdGiven,BSIM3waigdGiven,BSIM3laigdGiven;
    real BSIM3paigd,BSIM3bigd,BSIM3wbigd,BSIM3lbigd,BSIM3pbigd;
    integer BSIM3paigdGiven,BSIM3bigdGiven,BSIM3wbigdGiven,BSIM3lbigdGiven,BSIM3pbigdGiven;
    real BSIM3cigd,BSIM3wcigd,BSIM3lcigd,BSIM3pcigd;
    integer BSIM3cigdGiven,BSIM3wcigdGiven,BSIM3lcigdGiven,BSIM3pcigdGiven;     
    real BSIM3ppoxedge,BSIM3dlcig,BSIM3aigsd,BSIM3laigsd,BSIM3waigsd,BSIM3aigs,BSIM3aigd;
    integer BSIM3ppoxedgeGiven,BSIM3dlcigGiven,BSIM3aigsdGiven,BSIM3laigsdGiven,BSIM3waigsdGiven;
    real BSIM3paigsd,BSIM3bigsd,BSIM3lbigsd,BSIM3wbigsd,BSIM3pbigsd;
    integer BSIM3paigsdGiven,BSIM3bigsdGiven,BSIM3lbigsdGiven,BSIM3wbigsdGiven,BSIM3pbigsdGiven;
    real BSIM3cigsd,BSIM3lcigsd,BSIM3wcigsd,BSIM3pcigsd,BSIM3nigbacc;
    integer BSIM3cigsdGiven,BSIM3lcigsdGiven,BSIM3wcigsdGiven,BSIM3pcigsdGiven,BSIM3nigbaccGiven;
    real BSIM3lnigbacc,BSIM3wnigbacc,BSIM3pnigbacc;
    integer BSIM3lnigbaccGiven,BSIM3wnigbaccGiven,BSIM3pnigbaccGiven;
    real BSIM3agisl,BSIM3wagisl,BSIM3lagisl,BSIM3pagisl,BSIM3bgisl;
    integer BSIM3agislGiven,BSIM3wagislGiven,BSIM3lagislGiven,BSIM3pagislGiven,BSIM3bgislGiven;
    real BSIM3wbgisl,BSIM3lbgisl,BSIM3pbgisl,BSIM3cgisl,BSIM3wcgisl;
    integer BSIM3wbgislGiven,BSIM3lbgislGiven,BSIM3pbgislGiven,BSIM3cgislGiven,BSIM3wcgislGiven;
    real BSIM3lcgisl,BSIM3pcgisl,BSIM3egisl,BSIM3wegisl,BSIM3legisl;
    integer BSIM3lcgislGiven,BSIM3pcgislGiven,BSIM3egislGiven,BSIM3wegislGiven,BSIM3legislGiven;
    real BSIM3pegisl,BSIM3rgisl,BSIM3wrgisl,BSIM3lrgisl,BSIM3prgisl;
    integer BSIM3pegislGiven,BSIM3rgislGiven,BSIM3wrgislGiven,BSIM3lrgislGiven,BSIM3prgislGiven;
    real BSIM3kgisl,BSIM3wkgisl,BSIM3lkgisl,BSIM3pkgisl,BSIM3fgisl;
    integer BSIM3kgislGiven,BSIM3wkgislGiven,BSIM3lkgislGiven,BSIM3pkgislGiven,BSIM3fgislGiven;
    real BSIM3wfgisl,BSIM3lfgisl,BSIM3pfgisl,BSIM3rgidl,BSIM3wrgidl;
    integer BSIM3wfgislGiven,BSIM3lfgislGiven,BSIM3pfgislGiven,BSIM3rgidlGiven,BSIM3wrgidlGiven;
    real BSIM3lrgidl,BSIM3prgidl,BSIM3kgidl,BSIM3wkgidl,BSIM3lkgidl;
    integer BSIM3lrgidlGiven,BSIM3prgidlGiven,BSIM3kgidlGiven,BSIM3wkgidlGiven,BSIM3lkgidlGiven;
    real BSIM3pkgidl,BSIM3fgidl,BSIM3wfgidl,BSIM3lfgidl,BSIM3pfgidl;
    integer BSIM3pkgidlGiven,BSIM3fgidlGiven,BSIM3wfgidlGiven,BSIM3lfgidlGiven,BSIM3pfgidlGiven;
    
    real BSIM3ToxRatio, BSIM3Aechvb, BSIM3Bechvb;
    real BSIM3AechvbEdge,BSIM3BechvbEdge,BSIM3ToxRatioEdge;
    real Igidl, Igisl, Voxacc, Voxdepinv, VxNVt, ExpVxNVt, Vaux;
    real Igc, Igcs, Igcd, Igs, Igbacc, Igbinv, Igb, Igd, Pigcd;    

    //New model ACM
    integer BSIM3calcacm, BSIM3acm;
    //New model stimod
    integer BSIM3stiMod,LOD_flag,BSIM3ku0temp;
    real BSIM3sa, BSIM3sb;
    real BSIM3mulu0,BSIM3mulua,BSIM3mulub,BSIM3sa0,BSIM3sb0;
    real BSIM3wlod,BSIM3ku0,BSIM3kvsat,BSIM3kvth0,BSIM3tku0,here_BSIM3kvth0;
    integer BSIM3wlodGiven,BSIM3ku0Given,BSIM3kvsatGiven,BSIM3kvth0Given,BSIM3tku0Given;
    real BSIM3llodku0,BSIM3wlodku0,BSIM3llodvth,BSIM3wlodvth,BSIM3lku0;
    integer BSIM3llodku0Given,BSIM3wlodku0Given,BSIM3llodvthGiven,BSIM3wlodvthGiven,BSIM3lku0Given;
    real BSIM3wku0,BSIM3pku0,BSIM3lkvth0,BSIM3wkvth0,BSIM3pkvth0;
    integer BSIM3wku0Given,BSIM3pku0Given,BSIM3lkvth0Given,BSIM3wkvth0Given,BSIM3pkvth0Given;
    real BSIM3stk2,BSIM3lodk2,BSIM3steta0,BSIM3lodeta0;
    integer BSIM3stk2Given,BSIM3lodk2Given,BSIM3steta0Given,BSIM3lodeta0Given;
    real BSIM3sa1,BSIM3sa2,BSIM3sa3,BSIM3sa4,BSIM3sa5;
    integer BSIM3saGiven,BSIM3sbGiven,BSIM3sa1Given,BSIM3sa2Given,BSIM3sa3Given,BSIM3sa4Given,BSIM3sa5Given;
    real BSIM3sa6,BSIM3sa7,BSIM3sa8,BSIM3sa9,BSIM3sa10;
    integer BSIM3sa6Given,BSIM3sa7Given,BSIM3sa8Given,BSIM3sa9Given,BSIM3sa10Given;
    real BSIM3sb1,BSIM3sb2,BSIM3sb3,BSIM3sb4,BSIM3sb5;
    integer BSIM3sb1Given,BSIM3sb2Given,BSIM3sb3Given,BSIM3sb4Given,BSIM3sb5Given;
    real BSIM3sb6,BSIM3sb7,BSIM3sb8,BSIM3sb9,BSIM3sb10;
    integer BSIM3sb6Given,BSIM3sb7Given,BSIM3sb8Given,BSIM3sb9Given,BSIM3sb10Given;
    real BSIM3sw1,BSIM3sw2,BSIM3sw3,BSIM3sw4,BSIM3sw5;
    integer BSIM3sw1Given,BSIM3sw2Given,BSIM3sw3Given,BSIM3sw4Given,BSIM3sw5Given;
    real BSIM3sw6,BSIM3sw7,BSIM3sw8,BSIM3sw9,BSIM3sw10;
    integer BSIM3sw6Given,BSIM3sw7Given,BSIM3sw8Given,BSIM3sw9Given,BSIM3sw10Given;
    real W_tmp,BSIM3inv_od_def,BSIM3rho_def,BSIM3tconst,Inv_saref;
    real Inv_sbref,BSIM3inv_od_ref,BSIM3rho_ref,Inv_sa,Inv_sb,Inv_ODeff,rho,OD_offset; 
    real dvth0_lod,dk2_lod,deta0_lod,dk1_lod;

`ifdef NOISE
    real dbeta_dVg, dbeta_dVd, dbeta_dVb;
    real dueff_dVg, dueff_dVd, dueff_dVb;
    real dWeff_dVg, dWeff_dVb;
    real dVdseff_dVg, dVdseff_dVd, dVdseff_dVb;
    real dgche_dVg, dgche_dVd, dgche_dVb;
    real dfgche1_dVg, dfgche1_dVd, dfgche1_dVb;
    real dfgche2_dVg, dfgche2_dVd, dfgche2_dVb;
    real dIdsa_dVg, dIdsa_dVd, dIdsa_dVb;
    real dVa_dVg, dVa_dVd, dVa_dVb;
    real dVASCBE_dVg, dVASCBE_dVd, dVASCBE_dVb;
    real dVgsteff_dVg, dVgsteff_dVd, dVgsteff_dVb;
    real dVbseff_dVb;
    real dT0_dVg, dT0_dVd, dT0_dVb;
    real dEsatL_dVg, dEsatL_dVd, dEsatL_dVb;
    real dRds_dVg, dRds_dVb;
    real dIdl_dVg, dIdl_dVd, dIdl_dVb, dAbulk_dVb;
    real thermalNoiseContrib, flickerNoiseContrib;
    real AbovVgst2Vtm, N0, Nl;
    real Qinv, DelClm;
    integer doNoise;
`endif
    
    analog begin

        // This section emulates BSIM3setup() in b3set.c
        BSIM3weff = 0.0;
        qbulk = 0.0;
        qdrn = 0.0;
        qgate = 0.0;
        BSIM3cgdo = cgdo;
        BSIM3cgso = cgso;
        BSIM3drainArea = ad;
        BSIM3sourceArea = as;
        BSIM3drainSquares = nrd;
        BSIM3sourceSquares = nrs;
        BSIM3drainPerimeter = pd;
        BSIM3sourcePerimeter = ps;
        BSIM3nqsMod = nqsmod;
        BSIM3cdsc = cdsc;
        BSIM3cdscb = cdscb;
        BSIM3cdscd = cdscd;
        BSIM3cit = cit;
        BSIM3nfactor = nfactor;
        BSIM3xj = xj;
        BSIM3vsat = vsat;
        BSIM3at = at;
        BSIM3a0 = a0;
        BSIM3ags = ags;
        BSIM3a1 = a1;
        BSIM3a2 = a2;
        BSIM3keta = keta;
        BSIM3nsub = nsub;
        BSIM3ngate = ngate;
        BSIM3gamma1 = gamma1;
        BSIM3gamma2 = gamma2;
        BSIM3vbx = vbx;
        BSIM3vbm = vbm;
        BSIM3xt = xt;
        BSIM3vfb = vfb;
        BSIM3kt1 = kt1;
        BSIM3kt1l = kt1l;
        BSIM3kt2 = kt2;
        BSIM3k3 = k3;
        BSIM3k3b = k3b;
        BSIM3w0 = w0;
        BSIM3nlx = nlx;
        BSIM3dvt0 = dvt0;
        BSIM3dvt1 = dvt1;
        BSIM3dvt2 = dvt2;
        BSIM3dvt0w = dvt0w;
        BSIM3dvt1w = dvt1w;
        BSIM3dvt2w = dvt2w;
        BSIM3drout = drout;
        BSIM3dsub = dsub;
        BSIM3vth0 = vth0;
        BSIM3ua = ua;
        BSIM3ua1 = ua1;
        BSIM3ub = ub;
        BSIM3ub1 = ub1;
        BSIM3uc = uc;
        BSIM3uc1 = uc1;
        BSIM3u0 = u0;
        BSIM3ute = ute;
        BSIM3voff = voff;
        BSIM3delta = delta;
        BSIM3rdsw = rdsw;
        BSIM3prwg = prwg;
        BSIM3prwb = prwb;
        BSIM3prt = prt;
        BSIM3eta0 = eta0;
        BSIM3etab = etab;
        BSIM3pscbe1 = pscbe1;
        BSIM3pscbe2 = pscbe2;
        BSIM3pvag = pvag;
        BSIM3wr = wr;
        BSIM3dwg = dwg;
        BSIM3dwb = dwb;
        BSIM3b0 = b0;
        BSIM3b1 = b1;
        BSIM3alpha0 = alpha0;
        BSIM3alpha1 = alpha1;
        BSIM3beta0 = beta0;
        BSIM3elm = elm;
        BSIM3cgsl = cgsl;
        BSIM3cgdl = cgdl;
        BSIM3ckappa = ckappa;
        BSIM3cf = cf;
        BSIM3clc = clc;
        BSIM3cle = cle;
        BSIM3vfbcv = vfbcv;
        BSIM3noff = noff;
        BSIM3voffcv = voffcv;
        BSIM3acde = acde;
        BSIM3moin = moin;
        BSIM3mobMod = mobmod;
        BSIM3capMod = capmod;
        BSIM3noiMod = noimod;
        BSIM3binUnit = binunit;
        BSIM3tox = tox;
        BSIM3toxm = toxm;
        BSIM3npeak = nch;
        BSIM3k1 = k1;
        BSIM3k2 = k2;
        BSIM3pdibl1 = pdiblc1;
        BSIM3pdibl2 = pdiblc2;
        BSIM3pdiblb = pdiblcb;
        BSIM3pclm = pclm;
        
        if (ijth  == `NOT_GIVEN)
            BSIM3ijth = 0.1;
        else
            BSIM3ijth = ijth;
        
        BSIM3dwc = dwc;
        BSIM3dlc = dlc;
        BSIM3tcj = tcj;
        BSIM3tcjsw = tcjsw;
        BSIM3tcjswg = tcjswg;
        BSIM3tpb = tpb;
        BSIM3tpbsw = tpbsw;
        BSIM3tpbswg = tpbswg;
        BSIM3lcdsc = lcdsc;
        BSIM3lcdscb = lcdscb;
        BSIM3lcdscd = lcdscd;
        BSIM3lcit = lcit;
        BSIM3lnfactor = lnfactor;
        BSIM3lxj = lxj;
        BSIM3lvsat = lvsat;
        BSIM3lat = lat;
        BSIM3la0 = la0;
        BSIM3lags = lags;
        BSIM3la1 = la1;
        BSIM3la2 = la2;
        BSIM3lketa = lketa;
        BSIM3lnsub = lnsub;
        BSIM3lnpeak = lnpeak;
        BSIM3lngate = lngate;
        BSIM3lgamma1 = lgamma1;
        BSIM3lgamma2 = lgamma2;
        BSIM3lvbx = lvbx;
        BSIM3lvbm = lvbm;
        BSIM3lxt = lxt;
        BSIM3lk1 = lk1;
        BSIM3lkt1 = lkt1;
        BSIM3lkt1l = lkt1l;
        BSIM3lkt2 = lkt2;
        BSIM3lk2 = lk2;
        BSIM3lk3 = lk3;
        BSIM3lk3b = lk3b;
        BSIM3lw0 = lw0;
        BSIM3lnlx = lnlx;
        BSIM3ldvt0 = ldvt0;
        BSIM3ldvt1 = ldvt1;
        BSIM3ldvt2 = ldvt2;
        BSIM3ldvt0w = ldvt0w;
        BSIM3ldvt1w = ldvt1w;
        BSIM3ldvt2w = ldvt2w;
        BSIM3ldrout = ldrout;
        BSIM3ldsub = ldsub;
        BSIM3lvth0 = lvth0;
        BSIM3lua = lua;
        BSIM3lua1 = lua1;
        BSIM3lub = lub;
        BSIM3lub1 = lub1;
        BSIM3luc = luc;
        BSIM3luc1 = luc1;
        BSIM3lu0 = lu0;
        BSIM3lute = lute;
        BSIM3lvoff = lvoff;
        BSIM3ldelta = ldelta;
        BSIM3lrdsw = lrdsw;
        BSIM3lprwg = lprwg;
        BSIM3lprwb = lprwb;
        BSIM3lprt = lprt;
        BSIM3leta0 = leta0;
        BSIM3letab = letab;
        BSIM3lpclm = lpclm;
        BSIM3lpdibl1 = lpdiblc1;
        BSIM3lpdibl2 = lpdiblc2;
        BSIM3lpdiblb = lpdiblcb;
        BSIM3lpscbe1 = lpscbe1;
        BSIM3lpscbe2 = lpscbe2;
        BSIM3lpvag = lpvag;
        BSIM3lwr = lwr;
        BSIM3ldwg = ldwg;
        BSIM3ldwb = ldwb;
        BSIM3lb0 = lb0;
        BSIM3lb1 = lb1;
        BSIM3lalpha0 = lalpha0;
        BSIM3lalpha1 = lalpha1;
        BSIM3lbeta0 = lbeta0;
        BSIM3lvfb = lvfb;
        BSIM3lelm = lelm;
        BSIM3lcgsl = lcgsl;
        BSIM3lcgdl = lcgdl;
        BSIM3lckappa = lckappa;
        BSIM3lcf = lcf;
        BSIM3lclc = lclc;
        BSIM3lcle = lcle;
        BSIM3lvfbcv = lvfbcv;
        BSIM3lnoff = lnoff;
        BSIM3lvoffcv = lvoffcv;
        BSIM3lacde = lacde;
        BSIM3lmoin = lmoin;
        BSIM3wcdsc = wcdsc;
        BSIM3wcdscb = wcdscb;
        BSIM3wcdscd = wcdscd;
        BSIM3wcit = wcit;
        BSIM3wnfactor = wnfactor;
        BSIM3wxj = wxj;
        BSIM3wvsat = wvsat;
        BSIM3wat = wat;
        BSIM3wa0 = wa0;
        BSIM3wags = wags;
        BSIM3wa1 = wa1;
        BSIM3wa2 = wa2;
        BSIM3wketa = wketa;
        BSIM3wnsub = wnsub;
        BSIM3wnpeak = wnpeak;
        BSIM3wngate = wngate;
        BSIM3wgamma1 = wgamma1;
        BSIM3wgamma2 = wgamma2;
        BSIM3wvbx = wvbx;
        BSIM3wvbm = wvbm;
        BSIM3wxt = wxt;
        BSIM3wk1 = wk1;
        BSIM3wkt1 = wkt1;
        BSIM3wkt1l = wkt1l;
        BSIM3wkt2 = wkt2;
        BSIM3wk2 = wk2;
        BSIM3wk3 = wk3;
        BSIM3wk3b = wk3b;
        BSIM3ww0 = ww0;
        BSIM3wnlx = wnlx;
        BSIM3wdvt0 = wdvt0;
        BSIM3wdvt1 = wdvt1;
        BSIM3wdvt2 = wdvt2;
        BSIM3wdvt0w = wdvt0w;
        BSIM3wdvt1w = wdvt1w;
        BSIM3wdvt2w = wdvt2w;
        BSIM3wdrout = wdrout;
        BSIM3wdsub = wdsub;
        BSIM3wvth0 = wvth0;
        BSIM3wua = wua;
        BSIM3wua1 = wua1;
        BSIM3wub = wub;
        BSIM3wub1 = wub1;
        BSIM3wuc = wuc;
        BSIM3wuc1 = wuc1;
        BSIM3wu0 = wu0;
        BSIM3wute = wute;
        BSIM3wvoff = wvoff;
        BSIM3wdelta = wdelta;
        BSIM3wrdsw = wrdsw;
        BSIM3wprwg = wprwg;
        BSIM3wprwb = wprwb;
        BSIM3wprt = wprt;
        BSIM3weta0 = weta0;
        BSIM3wetab = wetab;
        BSIM3wpclm = wpclm;
        BSIM3wpdibl1 = wpdiblc1;
        BSIM3wpdibl2 = wpdiblc2;
        BSIM3wpdiblb = wpdiblcb;
        BSIM3wpscbe1 = wpscbe1;
        BSIM3wpscbe2 = wpscbe2;
        BSIM3wpvag = wpvag;
        BSIM3wwr = wwr;
        BSIM3wdwg = wdwg;
        BSIM3wdwb = wdwb;
        BSIM3wb0 = wb0;
        BSIM3wb1 = wb1;
        BSIM3walpha0 = walpha0;
        BSIM3walpha1 = walpha1;
        BSIM3wbeta0 = wbeta0;
        BSIM3wvfb = wvfb;
        BSIM3welm = welm;
        BSIM3wcgsl = wcgsl;
        BSIM3wcgdl = wcgdl;
        BSIM3wckappa = wckappa;
        BSIM3wcf = wcf;
        BSIM3wclc = wclc;
        BSIM3wcle = wcle;
        BSIM3wvfbcv = wvfbcv;
        BSIM3wnoff = wnoff;
        BSIM3wvoffcv = wvoffcv;
        BSIM3wacde = wacde;
        BSIM3wmoin = wmoin;
        BSIM3pcdsc = pcdsc;
        BSIM3pcdscb = pcdscb;
        BSIM3pcdscd = pcdscd;
        BSIM3pcit = pcit;
        BSIM3pnfactor = pnfactor;
        BSIM3pxj = pxj;
        BSIM3pvsat = pvsat;
        BSIM3pat = pat;
        BSIM3pa0 = pa0;
        BSIM3pags = pags;
        BSIM3pa1 = pa1;
        BSIM3pa2 = pa2;
        BSIM3pketa = pketa;
        BSIM3pnsub = pnsub;
        BSIM3pnpeak = pnpeak;
        BSIM3pngate = pngate;
        BSIM3pgamma1 = pgamma1;
        BSIM3pgamma2 = pgamma2;
        BSIM3pvbx = pvbx;
        BSIM3pvbm = pvbm;
        BSIM3pxt = pxt;
        BSIM3pk1 = pk1;
        BSIM3pkt1 = pkt1;
        BSIM3pkt1l = pkt1l;
        BSIM3pkt2 = pkt2;
        BSIM3pk2 = pk2;
        BSIM3pk3 = pk3;
        BSIM3pk3b = pk3b;
        BSIM3pw0 = pw0;
        BSIM3pnlx = pnlx;
        BSIM3pdvt0 = pdvt0;
        BSIM3pdvt1 = pdvt1;
        BSIM3pdvt2 = pdvt2;
        BSIM3pdvt0w = pdvt0w;
        BSIM3pdvt1w = pdvt1w;
        BSIM3pdvt2w = pdvt2w;
        BSIM3pdrout = pdrout;
        BSIM3pdsub = pdsub;
        BSIM3pvth0 = pvth0;
        BSIM3pua = pua;
        BSIM3pua1 = pua1;
        BSIM3pub = pub;
        BSIM3pub1 = pub1;
        BSIM3puc = puc;
        BSIM3puc1 = puc1;
        BSIM3pu0 = pu0;
        BSIM3pute = pute;
        BSIM3pvoff = pvoff;
        BSIM3pdelta = pdelta;
        BSIM3prdsw = prdsw;
        BSIM3pprwg = pprwg;
        BSIM3pprwb = pprwb;
        BSIM3pprt = pprt;
        BSIM3peta0 = peta0;
        BSIM3petab = petab;
        BSIM3ppclm = ppclm;
        BSIM3ppdibl1 = ppdiblc1;
        BSIM3ppdibl2 = ppdiblc2;
        BSIM3ppdiblb = ppdiblcb;
        BSIM3ppscbe1 = ppscbe1;
        BSIM3ppscbe2 = ppscbe2;
        BSIM3ppvag = ppvag;
        BSIM3pwr = pwr;
        BSIM3pdwg = pdwg;
        BSIM3pdwb = pdwb;
        BSIM3pb0 = pb0;
        BSIM3pb1 = pb1;
        BSIM3palpha0 = palpha0;
        BSIM3palpha1 = palpha1;
        BSIM3pbeta0 = pbeta0;
        BSIM3pvfb = pvfb;
        BSIM3pelm = pelm;
        BSIM3pcgsl = pcgsl;
        BSIM3pcgdl = pcgdl;
        BSIM3pckappa = pckappa;
        BSIM3pcf = pcf;
        BSIM3pclc = pclc;
        BSIM3pcle = pcle;
        BSIM3pvfbcv = pvfbcv;
        BSIM3pnoff = pnoff;
        BSIM3pvoffcv = pvoffcv;
        BSIM3pacde = pacde;
        BSIM3pmoin = pmoin;
        BSIM3tnom = tnom + `P_CELSIUS0;
        BSIM3cgbo = cgbo;
        BSIM3xpart = xpart;
        BSIM3sheetResistance = rsh;
        BSIM3jctSatCurDensity = js;
        BSIM3jctSidewallSatCurDensity = jsw;
        BSIM3bulkJctPotential = pb;
        BSIM3bulkJctBotGradingCoeff = mj;
        BSIM3bulkJctSideGradingCoeff = mjsw;
        BSIM3bulkJctGateSideGradingCoeff = mjswg;
        BSIM3sidewallJctPotential = pbsw;
        BSIM3GatesidewallJctPotential = pbswg;
        BSIM3unitAreaJctCap = cj;
        BSIM3unitLengthSidewallJctCap = cjsw;
        BSIM3unitLengthGateSidewallJctCap = cjswg;
        BSIM3jctEmissionCoeff = nj;
        BSIM3jctTempExponent = xti;
        BSIM3Lint = lint;
        BSIM3Ll = ll;
        BSIM3Llc = llc;
        BSIM3Lln = lln;
        BSIM3Lw = lw;
        BSIM3Lwc = lwc;
        BSIM3Lwn = lwn;
        BSIM3Lwl = lwl;
        BSIM3Lwlc = lwlc;
        BSIM3Wint = wint;
        BSIM3Wl = wl;
        BSIM3Wlc = wlc;
        BSIM3Wln = wln;
        BSIM3Ww = ww;
        BSIM3Wwc = wwc;
        BSIM3Wwn = wwn;
        BSIM3Wwl = wwl;
        BSIM3Wwlc = wwlc;
        BSIM3unitAreaTempJctCap = tcj;
        BSIM3unitLengthSidewallTempJctCap = tcjsw;
        BSIM3unitLengthGateSidewallTempJctCap = tcjswg;
        BSIM3af = af;
        BSIM3kf = kf;
        BSIM3ef = ef;
        BSIM3type=type;
        
    //New model: bsim4 igcmod and igbmod as hspice compatiable
            BSIM3agidl = agidl;
            BSIM3lagidl = lagidl;
            BSIM3wagidl = wagidl;
            BSIM3pagidl = pagidl;
            BSIM3bgidl = bgidl;
            BSIM3lbgidl = lbgidl;
            BSIM3wbgidl = wbgidl;
            BSIM3pbgidl = pbgidl;
            BSIM3cgidl = cgidl;
            BSIM3lcgidl = lcgidl;
            BSIM3wcgidl = wcgidl;
            BSIM3pcgidl = pcgidl;
            BSIM3egidl = egidl;
            BSIM3legidl = legidl;
            BSIM3wegidl = wegidl;
            BSIM3pegidl = pegidl;
            BSIM3nigc = nigc;
            BSIM3lnigc = lnigc;
            BSIM3wnigc = wnigc;
            BSIM3pnigc = pnigc;
            BSIM3aigc = aigc;
            BSIM3laigc = laigc;
            BSIM3waigc = waigc;
            BSIM3paigc = paigc;
            BSIM3bigc = bigc;
            BSIM3lbigc = lbigc;
            BSIM3wbigc = wbigc;
            BSIM3pbigc = pbigc;
            BSIM3cigc = cigc;
            BSIM3lcigc = lcigc;
            BSIM3wcigc = wcigc;
            BSIM3pcigc = pcigc;
            BSIM3aigbacc = aigbacc;
            BSIM3laigbacc = laigbacc;
            BSIM3waigbacc = waigbacc;
            BSIM3paigbacc = paigbacc;
            BSIM3bigbacc = bigbacc;
            BSIM3lbigbacc = lbigbacc;
            BSIM3wbigbacc = wbigbacc;
            BSIM3pbigbacc = pbigbacc;
            BSIM3cigbacc = cigbacc;
            BSIM3lcigbacc = lcigbacc;
            BSIM3wcigbacc = wcigbacc;
            BSIM3pcigbacc = pcigbacc;
            BSIM3aigbinv = aigbinv;
            BSIM3laigbinv = laigbinv;
            BSIM3waigbinv = waigbinv;
            BSIM3paigbinv = paigbinv;
            BSIM3bigbinv = bigbinv;
            BSIM3lbigbinv = lbigbinv;
            BSIM3wbigbinv = wbigbinv;
            BSIM3pbigbinv = pbigbinv;
            BSIM3cigbinv = cigbinv;
            BSIM3lcigbinv = lcigbinv;
            BSIM3wcigbinv = wcigbinv;
            BSIM3pcigbinv = pcigbinv;
            BSIM3eigbinv = eigbinv;
            BSIM3leigbinv = leigbinv;
            BSIM3weigbinv = weigbinv;
            BSIM3peigbinv = peigbinv;
            BSIM3nigbinv = nigbinv;
            BSIM3lnigbinv = lnigbinv;
            BSIM3wnigbinv = wnigbinv;
            BSIM3pnigbinv = pnigbinv;
            BSIM3toxe = toxe;
            BSIM3vtm0 = vtm0;
            BSIM3toxref = toxref;
            BSIM3ntox = ntox;
            BSIM3lntox = lntox;
            BSIM3wntox = wntox;
            BSIM3pntox = pntox;
            BSIM3pigcd = pigcd;
            BSIM3lpigcd = lpigcd;
            BSIM3wpigcd = wpigcd;
            BSIM3ppigcd = ppigcd;
            BSIM3nsd = nsd;
            BSIM3lnsd = lnsd;
            BSIM3wnsd = wnsd;
            BSIM3pnsd = pnsd;
            BSIM3vfbsdoff = vfbsdoff;
            BSIM3lvfbsdoff = lvfbsdoff;
            BSIM3wvfbsdoff = wvfbsdoff;
            BSIM3pvfbsdoff = pvfbsdoff;
            BSIM3tvfbsdoff = tvfbsdoff;
            BSIM3ltvfbsdoff = ltvfbsdoff;
            BSIM3wtvfbsdoff = wtvfbsdoff;
            BSIM3ptvfbsdoff = ptvfbsdoff;
            BSIM3poxedge = poxedge;
            BSIM3lpoxedge = lpoxedge;
            BSIM3wpoxedge = wpoxedge;
            BSIM3ppoxedge = ppoxedge;
            BSIM3dlcig = dlcig;
            BSIM3aigs = aigs;
            BSIM3waigs = waigs;
            BSIM3laigs = laigs;
            BSIM3paigs = paigs;
            BSIM3bigs = bigs;
            BSIM3wbigs = wbigs;
            BSIM3lbigs = lbigs;
            BSIM3pbigs = pbigs;
            BSIM3cigs = cigs;
            BSIM3wcigs = wcigs;
            BSIM3lcigs = lcigs;
            BSIM3pcigs = pcigs;
            BSIM3aigd = aigd;
            BSIM3waigd = waigd;
            BSIM3laigd = laigd;
            BSIM3paigd = paigd;
            BSIM3bigd = bigd;
            BSIM3wbigd = wbigd;
            BSIM3lbigd = lbigd;
            BSIM3pbigd = pbigd;
            BSIM3cigd = cigd;
            BSIM3wcigd = wcigd;
            BSIM3lcigd = lcigd;
            BSIM3pcigd = pcigd;
            BSIM3aigsd = aigsd;
            BSIM3laigsd = laigsd;
            BSIM3waigsd = waigsd;
            BSIM3paigsd = paigsd;
            BSIM3bigsd = bigsd;
            BSIM3lbigsd = lbigsd;
            BSIM3wbigsd = wbigsd;
            BSIM3pbigsd = pbigsd;
            BSIM3cigsd = cigsd;
            BSIM3lcigsd = lcigsd;
            BSIM3wcigsd = wcigsd;
            BSIM3pcigsd = pcigsd;
            BSIM3nigbacc = nigbacc;
            BSIM3lnigbacc = lnigbacc;
            BSIM3wnigbacc = wnigbacc;
            BSIM3pnigbacc = pnigbacc;
            BSIM3agisl = agisl;
            BSIM3wagisl = wagisl;
            BSIM3lagisl = lagisl;
            BSIM3pagisl = pagisl;
            BSIM3bgisl = bgisl;
            BSIM3wbgisl = wbgisl;
            BSIM3lbgisl = lbgisl;
            BSIM3pbgisl = pbgisl;
            BSIM3cgisl = cgisl;
            BSIM3wcgisl = wcgisl;
            BSIM3lcgisl = lcgisl;
            BSIM3pcgisl = pcgisl;
            BSIM3egisl = egisl;
            BSIM3wegisl = wegisl;
            BSIM3legisl = legisl;
            BSIM3pegisl = pegisl;
            BSIM3rgisl = rgisl;
            BSIM3wrgisl = wrgisl;
            BSIM3lrgisl = lrgisl;
            BSIM3prgisl = prgisl;
            BSIM3kgisl = kgisl;
            BSIM3wkgisl = wkgisl;
            BSIM3lkgisl = lkgisl;
            BSIM3pkgisl = pkgisl;
            BSIM3fgisl = fgisl;
            BSIM3wfgisl = wfgisl;
            BSIM3lfgisl = lfgisl;
            BSIM3pfgisl = pfgisl;
            BSIM3rgidl = rgidl;
            BSIM3wrgidl = wrgidl;
            BSIM3lrgidl = lrgidl;
            BSIM3prgidl = prgidl;
            BSIM3kgidl = kgidl;
            BSIM3wkgidl = wkgidl;
            BSIM3lkgidl = lkgidl;
            BSIM3pkgidl = pkgidl;
            BSIM3fgidl = fgidl;
            BSIM3wfgidl = wfgidl;
            BSIM3lfgidl = lfgidl;
            BSIM3pfgidl = pfgidl;
            BSIM3calcacm = calcacm;
            BSIM3bvs = bvs;
            BSIM3bvd = bvd;
            BSIM3ijthsrev = ijthsrev;
            BSIM3ijthdrev = ijthdrev;
            BSIM3xjbvs = xjbvs;
            BSIM3xjbvd = xjbvd;
            BSIM3vgslim = vgslim;
            BSIM3acm = acm;
            BSIM3stiMod = stimod;

            BSIM3sa = sa;
            BSIM3sa0 = saref;
            BSIM3sb0 = sbref;
            BSIM3sb = sb;
            BSIM3mulu0 = mulu0;
            BSIM3mulua = mulua;
            BSIM3mulub = mulub;
            BSIM3binflag = binflag;
            BSIM3breakmod = breakmod;
            BSIM3wlod = wlod;
            BSIM3ku0 = ku0;
            BSIM3kvsat = kvsat;
            BSIM3kvth0 = kvth0;
            BSIM3tku0 = tku0;
            BSIM3llodku0 = llodku0;
            BSIM3wlodku0 = wlodku0;
            BSIM3llodvth = llodvth;
            BSIM3wlodvth = wlodvth;
            BSIM3lku0 = lku0;
            BSIM3wku0 = wku0;
            BSIM3pku0 = pku0;
            BSIM3lkvth0 = lkvth0;
            BSIM3wkvth0 = wkvth0;
            BSIM3pkvth0 = pkvth0;
            BSIM3stk2 = stk2;
            BSIM3lodk2 = lodk2;
            BSIM3steta0 = steta0;
            BSIM3lodeta0 = lodeta0;
            BSIM3sa1 = sa1;
            BSIM3sa2 = sa2;
            BSIM3sa3 = sa3;
            BSIM3sa4 = sa4;
            BSIM3sa5 = sa5;
            BSIM3sa6 = sa6;
            BSIM3sa7 = sa7;
            BSIM3sa8 = sa8;
            BSIM3sa9 = sa9;
            BSIM3sa10 = sa10;
            BSIM3sb1 = sb1;
            BSIM3sb2 = sb2;
            BSIM3sb3 = sb3;
            BSIM3sb4 = sb4;
            BSIM3sb5 = sb5;
            BSIM3sb6 = sb6;
            BSIM3sb7 = sb7;
            BSIM3sb8 = sb8;
            BSIM3sb9 = sb9;
            BSIM3sb10 = sb10;
            BSIM3sw1 = sw1;
            BSIM3sw2 = sw2;
            BSIM3sw3 = sw3;
            BSIM3sw4 = sw4;
            BSIM3sw5 = sw5;
            BSIM3sw6 = sw6;
            BSIM3sw7 = sw7;
            BSIM3sw8 = sw8;
            BSIM3sw9 = sw9;
            BSIM3sw10 = sw10;


        if(BSIM3sa1 == `NOT_GIVEN && BSIM3sa == `NOT_GIVEN) begin
          BSIM3sa = 0.0;
          BSIM3sa1 = 0.0;
        end
        else if(BSIM3sa1 == `NOT_GIVEN && BSIM3sa != `NOT_GIVEN)
          BSIM3sa1 = BSIM3sa;
        else if(BSIM3sa1 != `NOT_GIVEN)
          BSIM3sa = BSIM3sa1;

        if(BSIM3sb1 == `NOT_GIVEN && BSIM3sb == `NOT_GIVEN) begin
          BSIM3sb = 0.0;
          BSIM3sb1 = 0.0;
        end
        else if(BSIM3sb1 == `NOT_GIVEN && BSIM3sb != `NOT_GIVEN)
          BSIM3sb1 = BSIM3sb;
        else if(BSIM3sb1 != `NOT_GIVEN)
          BSIM3sb = BSIM3sb1;

        if(BSIM3mulu0 <= 0.0)
          BSIM3mulu0 = 1.0;
        if(BSIM3mulua <= 0.0)
          BSIM3mulua = 1.0;
        if(BSIM3mulub <= 0.0)
          BSIM3mulub = 1.0;
          
        if(BSIM3vgslim < 0.0)
            BSIM3vgslim = 0.0;
        else if (BSIM3vgslim > 0.0 && BSIM3vgslim < 5.0)
            BSIM3vgslim = 5.0;
        //New model ACM 
        if (BSIM3acm == `INT_NOT_GIVEN) begin
          if (level == 53)
            BSIM3acm = 10;
          else
            BSIM3acm = 0;
        end
        if (BSIM3calcacm == `INT_NOT_GIVEN) 
            BSIM3calcacm = 0;

        if ( BSIM3acm < 3.1 || (BSIM3calcacm>0 && (BSIM3acm < 12.1 && BSIM3acm > 11.9)))
            BSIM3calcacm = 1;
        else
            BSIM3calcacm = 0;

        //New model for breakdown diode model
	if (BSIM3breakmod != 0.0 && BSIM3breakmod != 1.0) begin
	  BSIM3breakmod = 0.0;
	  $strobe("Warning:  breakmod is reset to 0.0 \n");
	end
	if (BSIM3bvs < 0.0 ) begin
	  BSIM3bvs = 0.0;
	  $strobe("Warning:  bvs is negative, reset to 0.0 \n");
	end
	if (BSIM3bvd < 0.0 ) begin
	  BSIM3bvd = 0.0;
	  $strobe("Warning:  bvd is negative, reset to 0.0 \n");
	end
	if (BSIM3ijthsrev < 0.0 ) begin
	  BSIM3ijthsrev = 0.0;
	  $strobe("Warning:  ijthsrev is negative, reset to 0.0 \n");
	end
	if (BSIM3ijthdrev < 0.0 ) begin
	  BSIM3ijthdrev = 0.0;
	  $strobe("Warning:  ijthdrev is negative, reset to 0.0 \n");
	end
	if (BSIM3xjbvs < 0.0 ) begin
	  BSIM3xjbvs = 0.0;
	  $strobe("Warning:  xjbvs is negative, reset to 0.0 \n");
	end
	if (BSIM3xjbvd < 0.0 ) begin
	  BSIM3xjbvd = 0.0;
	  $strobe("Warning:  xjbvd is negative, reset to 0.0 \n");
	end

        if(BSIM3tox == `NOT_GIVEN) 
            BSIM3tox = 150.0e-10;
        else begin
           if (BSIM3tox < 5e-10)
              BSIM3tox = 5e-10;
        end
        if(BSIM3ckappa==0.0)
            BSIM3ckappa = 0.6;

        // Emulate Given flags:
        if (em == `NOT_GIVEN)
            BSIM3em = 4.1e7;
        else
            BSIM3em = em;
        if (vth0 == `NOT_GIVEN) begin
            BSIM3vth0Given = 0;
            BSIM3vth0 = (BSIM3type == `NMOS) ? 0.7 : -0.7; // Default
        end
        else  
            BSIM3vth0Given = 1;

        if (BSIM3xt == `NOT_GIVEN) begin
            BSIM3xtGiven = 0;
            BSIM3xt = 1.55e-7;
        end
        else
            BSIM3xtGiven = 1;
        if (nch == `NOT_GIVEN) begin
            BSIM3npeakGiven = 0;
            BSIM3npeak= 1.7e17;
        end
        else
            BSIM3npeakGiven = 1;
        if (BSIM3npeak > 1.0e20)
            BSIM3npeak = BSIM3npeak * 1.0e-6;
        if (BSIM3lnpeak > 1.0e20)
            BSIM3lnpeak = BSIM3lnpeak * 1.0e-6;
        if (BSIM3wnpeak > 1.0e20)
            BSIM3wnpeak = BSIM3wnpeak * 1.0e-6;
        if (BSIM3pnpeak > 1.0e20)
            BSIM3pnpeak = BSIM3pnpeak * 1.0e-6;
        if (BSIM3ngate > 1.0e23)
            BSIM3ngate = BSIM3ngate * 1.0e-6;
        if (BSIM3lngate > 1.0e23)
            BSIM3lngate = BSIM3lngate * 1.0e-6;
        if (BSIM3wngate > 1.0e23)
            BSIM3wngate = BSIM3wngate * 1.0e-6;
        if (BSIM3pngate > 1.0e23)
            BSIM3pngate = BSIM3pngate * 1.0e-6;

        if (BSIM3gamma2 == `NOT_GIVEN) begin
            BSIM3gamma2Given = 0;
            BSIM3gamma2 = 0.0;
        end
        else
            BSIM3gamma2Given = 0;

        if (BSIM3vbx == `NOT_GIVEN) begin
            BSIM3vbxGiven = 0;
            BSIM3vbx = 0.0;
        end
        else
            BSIM3vbxGiven = 0;
        
        if (BSIM3nsub == `NOT_GIVEN) begin
            BSIM3nsubGiven = 0;
            BSIM3nsub = 6.0e16;
        end
        else
             BSIM3nsubGiven = 1;
        
        if (uc == `NOT_GIVEN) begin
            BSIM3uc = (BSIM3mobMod == 3) ? -0.0465 : -0.0465e-9; // Default
        end

        if (uc1 == `NOT_GIVEN) begin
            BSIM3uc1 = (BSIM3mobMod == 3) ? -0.056 : -0.056e-9; // Default
        end
        
        if (u0 == `NOT_GIVEN) begin
            BSIM3u0 = (BSIM3type == `NMOS ) ? 0.067 : 0.025; // Default
        end
        
        if (gamma1 == `NOT_GIVEN) begin
            BSIM3gamma1Given = 0;
            BSIM3gamma1 = 0.0; // Default
        end
        else
            BSIM3gamma1Given = 1;
        
        if (k1 == `NOT_GIVEN) begin
            BSIM3k1Given = 0;
            BSIM3k1 = 0.0; // Default 0.5->0.0 New model
        end
        else
            BSIM3k1Given = 1;

        if (k2 == `NOT_GIVEN) begin
            BSIM3k2Given = 0;
            BSIM3k2 = 0.0; // Default -0.0186 -> 0.0
        end
        else
            BSIM3k2Given = 1;

        BSIM3cox= 3.453133e-11 / BSIM3tox;
        Cox = BSIM3cox;

        if (BSIM3cf == `NOT_GIVEN)
            BSIM3cf = 2.0 * `EPSOX / `M_PI * ln(1.0 + 0.4e-6 / BSIM3tox);
        if (BSIM3dlc == `NOT_GIVEN) begin       
            BSIM3dlcGiven = 0;
            BSIM3dlc= lint; // Default
        end
        else
            BSIM3dlcGiven = 1;
        
        if (BSIM3cgdo == `NOT_GIVEN) begin       
            if (BSIM3dlcGiven && BSIM3dlc > 0.0)
                BSIM3cgdo = BSIM3dlc * BSIM3cox - BSIM3cgdl;      
            else
                BSIM3cgdo = 0.6 * BSIM3xj * BSIM3cox;
        end
                  
        if (BSIM3cgso == `NOT_GIVEN) begin 
            if (BSIM3dlcGiven  && BSIM3dlc > 0.0)
                BSIM3cgso = BSIM3dlc * BSIM3cox - BSIM3cgsl;     
            else
                BSIM3cgso = 0.6 * BSIM3xj * BSIM3cox; 
        end 
        
        if (BSIM3cgbo == `NOT_GIVEN)
            BSIM3cgbo = 2.0 * BSIM3dwc * BSIM3cox;     

        if (BSIM3xpart == `NOT_GIVEN) begin
          if (level == 53)
            BSIM3xpart=0.0;
          else begin
            if (version > 3.031)
              BSIM3xpart=1.0;
            else
              BSIM3xpart=0.0;
          end
        end


    //New model: BSIM4 igcmod and igbmod as hspice compatiable
            BSIM3agidlGiven = (BSIM3agidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lagidlGiven = (BSIM3lagidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wagidlGiven = (BSIM3wagidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pagidlGiven = (BSIM3pagidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3bgidlGiven = (BSIM3bgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbgidlGiven = (BSIM3lbgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbgidlGiven = (BSIM3wbgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbgidlGiven = (BSIM3pbgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3cgidlGiven = (BSIM3cgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcgidlGiven = (BSIM3lcgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcgidlGiven = (BSIM3wcgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcgidlGiven = (BSIM3pcgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3egidlGiven = (BSIM3egidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3legidlGiven = (BSIM3legidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wegidlGiven = (BSIM3wegidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pegidlGiven = (BSIM3pegidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3nigcGiven = (BSIM3nigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3lnigcGiven = (BSIM3lnigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3wnigcGiven = (BSIM3wnigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3pnigcGiven = (BSIM3pnigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3aigcGiven = (BSIM3aigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3laigcGiven = (BSIM3laigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3waigcGiven = (BSIM3waigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3paigcGiven = (BSIM3paigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3bigcGiven = (BSIM3bigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbigcGiven = (BSIM3lbigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbigcGiven = (BSIM3wbigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbigcGiven = (BSIM3pbigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3cigcGiven = (BSIM3cigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcigcGiven = (BSIM3lcigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcigcGiven = (BSIM3wcigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcigcGiven = (BSIM3pcigc == `NOT_GIVEN) ? 0 : 1;
            BSIM3aigbaccGiven = (BSIM3aigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3laigbaccGiven = (BSIM3laigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3waigbaccGiven = (BSIM3waigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3paigbaccGiven = (BSIM3paigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3bigbaccGiven = (BSIM3bigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbigbaccGiven = (BSIM3lbigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbigbaccGiven = (BSIM3wbigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbigbaccGiven = (BSIM3pbigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3cigbaccGiven = (BSIM3cigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcigbaccGiven = (BSIM3lcigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcigbaccGiven = (BSIM3wcigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcigbaccGiven = (BSIM3pcigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3aigbinvGiven = (BSIM3aigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3laigbinvGiven = (BSIM3laigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3waigbinvGiven = (BSIM3waigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3paigbinvGiven = (BSIM3paigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3bigbinvGiven = (BSIM3bigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbigbinvGiven = (BSIM3lbigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbigbinvGiven = (BSIM3wbigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbigbinvGiven = (BSIM3pbigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3cigbinvGiven = (BSIM3cigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcigbinvGiven = (BSIM3lcigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcigbinvGiven = (BSIM3wcigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcigbinvGiven = (BSIM3pcigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3eigbinvGiven = (BSIM3eigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3leigbinvGiven = (BSIM3leigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3weigbinvGiven = (BSIM3weigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3peigbinvGiven = (BSIM3peigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3nigbinvGiven = (BSIM3nigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3lnigbinvGiven = (BSIM3lnigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3wnigbinvGiven = (BSIM3wnigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3pnigbinvGiven = (BSIM3pnigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM3toxeGiven = (BSIM3toxe == `NOT_GIVEN) ? 0 : 1;
            BSIM3toxmGiven = (BSIM3toxm == `NOT_GIVEN) ? 0 : 1;
            BSIM3vtm0Given = (BSIM3vtm0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3toxrefGiven = (BSIM3toxref == `NOT_GIVEN) ? 0 : 1;
            BSIM3ntoxGiven = (BSIM3ntox == `NOT_GIVEN) ? 0 : 1;
            BSIM3lntoxGiven = (BSIM3lntox == `NOT_GIVEN) ? 0 : 1;
            BSIM3wntoxGiven = (BSIM3wntox == `NOT_GIVEN) ? 0 : 1;
            BSIM3pntoxGiven = (BSIM3pntox == `NOT_GIVEN) ? 0 : 1;
            BSIM3pigcdGiven = (BSIM3pigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM3lpigcdGiven = (BSIM3lpigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM3wpigcdGiven = (BSIM3wpigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM3ppigcdGiven = (BSIM3ppigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM3nsdGiven = (BSIM3nsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3lnsdGiven = (BSIM3lnsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3wnsdGiven = (BSIM3wnsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3pnsdGiven = (BSIM3pnsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3vfbGiven = (BSIM3vfb == `NOT_GIVEN) ? 0 : 1;
            BSIM3vfbsdoffGiven = (BSIM3vfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3lvfbsdoffGiven = (BSIM3lvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3wvfbsdoffGiven = (BSIM3wvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3pvfbsdoffGiven = (BSIM3pvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3tvfbsdoffGiven = (BSIM3tvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3ltvfbsdoffGiven = (BSIM3ltvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3wtvfbsdoffGiven = (BSIM3wtvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3ptvfbsdoffGiven = (BSIM3ptvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM3poxedgeGiven = (BSIM3poxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM3lpoxedgeGiven = (BSIM3lpoxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM3wpoxedgeGiven = (BSIM3wpoxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM3ppoxedgeGiven = (BSIM3ppoxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM3dlcigGiven = (BSIM3dlcig == `NOT_GIVEN) ? 0 : 1;
            BSIM3aigsGiven = (BSIM3aigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3waigsGiven = (BSIM3waigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3laigsGiven = (BSIM3laigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3paigsGiven = (BSIM3paigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3bigsGiven = (BSIM3bigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbigsGiven = (BSIM3wbigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbigsGiven = (BSIM3lbigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbigsGiven = (BSIM3pbigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3cigsGiven = (BSIM3cigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcigsGiven = (BSIM3wcigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcigsGiven = (BSIM3lcigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcigsGiven = (BSIM3pcigs == `NOT_GIVEN) ? 0 : 1;
            BSIM3aigdGiven = (BSIM3aigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3waigdGiven = (BSIM3waigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3laigdGiven = (BSIM3laigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3paigdGiven = (BSIM3paigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3bigdGiven = (BSIM3bigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbigdGiven = (BSIM3wbigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbigdGiven = (BSIM3lbigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbigdGiven = (BSIM3pbigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3cigdGiven = (BSIM3cigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcigdGiven = (BSIM3wcigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcigdGiven = (BSIM3lcigd == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcigdGiven = (BSIM3pcigd == `NOT_GIVEN) ? 0 : 1;
            
            BSIM3aigsdGiven = (BSIM3aigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3laigsdGiven = (BSIM3laigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3waigsdGiven = (BSIM3waigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3paigsdGiven = (BSIM3paigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3bigsdGiven = (BSIM3bigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbigsdGiven = (BSIM3lbigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbigsdGiven = (BSIM3wbigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbigsdGiven = (BSIM3pbigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3cigsdGiven = (BSIM3cigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcigsdGiven = (BSIM3lcigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcigsdGiven = (BSIM3wcigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcigsdGiven = (BSIM3pcigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM3nigbaccGiven = (BSIM3nigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3lnigbaccGiven = (BSIM3lnigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3wnigbaccGiven = (BSIM3wnigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3pnigbaccGiven = (BSIM3pnigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM3agislGiven = (BSIM3agisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wagislGiven = (BSIM3wagisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lagislGiven = (BSIM3lagisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pagislGiven = (BSIM3pagisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3bgislGiven = (BSIM3bgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wbgislGiven = (BSIM3wbgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lbgislGiven = (BSIM3lbgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pbgislGiven = (BSIM3pbgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3cgislGiven = (BSIM3cgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wcgislGiven = (BSIM3wcgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lcgislGiven = (BSIM3lcgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pcgislGiven = (BSIM3pcgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3egislGiven = (BSIM3egisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wegislGiven = (BSIM3wegisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3legislGiven = (BSIM3legisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pegislGiven = (BSIM3pegisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3rgislGiven = (BSIM3rgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wrgislGiven = (BSIM3wrgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lrgislGiven = (BSIM3lrgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3prgislGiven = (BSIM3prgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3kgislGiven = (BSIM3kgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wkgislGiven = (BSIM3wkgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lkgislGiven = (BSIM3lkgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pkgislGiven = (BSIM3pkgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3fgislGiven = (BSIM3fgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wfgislGiven = (BSIM3wfgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lfgislGiven = (BSIM3lfgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pfgislGiven = (BSIM3pfgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM3rgidlGiven = (BSIM3rgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wrgidlGiven = (BSIM3wrgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lrgidlGiven = (BSIM3lrgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3prgidlGiven = (BSIM3prgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3kgidlGiven = (BSIM3kgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wkgidlGiven = (BSIM3wkgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lkgidlGiven = (BSIM3lkgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pkgidlGiven = (BSIM3pkgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3fgidlGiven = (BSIM3fgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3wfgidlGiven = (BSIM3wfgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3lfgidlGiven = (BSIM3lfgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM3pfgidlGiven = (BSIM3pfgidl == `NOT_GIVEN) ? 0 : 1;

            //New model stimod
            BSIM3wlodGiven = (BSIM3wlod == `NOT_GIVEN) ? 0 : 1;
            BSIM3ku0Given = (BSIM3ku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3kvsatGiven = (BSIM3kvsat == `NOT_GIVEN) ? 0 : 1;
            BSIM3kvth0Given = (BSIM3kvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3tku0Given = (BSIM3tku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3llodku0Given = (BSIM3llodku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3wlodku0Given = (BSIM3wlodku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3llodvthGiven = (BSIM3llodvth == `NOT_GIVEN) ? 0 : 1;
            BSIM3wlodvthGiven = (BSIM3wlodvth == `NOT_GIVEN) ? 0 : 1;
            BSIM3lku0Given = (BSIM3lku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3wku0Given = (BSIM3wku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3pku0Given = (BSIM3pku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3lkvth0Given = (BSIM3lkvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3wkvth0Given = (BSIM3wkvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3pkvth0Given = (BSIM3pkvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3stk2Given = (BSIM3stk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM3lodk2Given = (BSIM3lodk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM3steta0Given = (BSIM3steta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3lodeta0Given = (BSIM3lodeta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM3saGiven = (BSIM3sa == `NOT_GIVEN) ? 0 : 1;
            BSIM3sbGiven = (BSIM3sb == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa1Given = (BSIM3sa1 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa2Given = (BSIM3sa2 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa3Given = (BSIM3sa3 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa4Given = (BSIM3sa4 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa5Given = (BSIM3sa5 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa6Given = (BSIM3sa6 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa7Given = (BSIM3sa7 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa8Given = (BSIM3sa8 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa9Given = (BSIM3sa9 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sa10Given = (BSIM3sa10 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb1Given = (BSIM3sb1 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb2Given = (BSIM3sb2 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb3Given = (BSIM3sb3 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb4Given = (BSIM3sb4 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb5Given = (BSIM3sb5 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb6Given = (BSIM3sb6 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb7Given = (BSIM3sb7 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb8Given = (BSIM3sb8 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb9Given = (BSIM3sb9 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sb10Given = (BSIM3sb10 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw1Given = (BSIM3sw1 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw2Given = (BSIM3sw2 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw3Given = (BSIM3sw3 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw4Given = (BSIM3sw4 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw5Given = (BSIM3sw5 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw6Given = (BSIM3sw6 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw7Given = (BSIM3sw7 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw8Given = (BSIM3sw8 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw9Given = (BSIM3sw9 == `NOT_GIVEN) ? 0 : 1;
            BSIM3sw10Given = (BSIM3sw10 == `NOT_GIVEN) ? 0 : 1;
            
            if(!BSIM3toxeGiven)
            	BSIM3toxe = BSIM3tox;
            if(!BSIM3toxmGiven)
            	BSIM3toxm = BSIM3tox;
            if(!BSIM3vtm0Given)
            	BSIM3vtm0 = 0.0;
            if(!BSIM3toxrefGiven)
            	BSIM3toxref = 30.0e-10;
            if(!BSIM3nsdGiven)
            	BSIM3nsd = 1.0e20;
            if(!BSIM3lnsdGiven)
            	BSIM3lnsd = 0.0;
            if(!BSIM3wnsdGiven)
            	BSIM3wnsd = 0.0;
            if(!BSIM3pnsdGiven)
            	BSIM3pnsd = 0.0;
            if(!BSIM3vfbsdoffGiven)
            	BSIM3vfbsdoff = 0.0;
            if(!BSIM3lvfbsdoffGiven)
            	BSIM3lvfbsdoff = 0.0;
            if(!BSIM3wvfbsdoffGiven)
            	BSIM3wvfbsdoff = 0.0;
            if(!BSIM3pvfbsdoffGiven)
            	BSIM3pvfbsdoff = 0.0;
            if(!BSIM3tvfbsdoffGiven)
            	BSIM3tvfbsdoff = 0.0;
            if(!BSIM3ltvfbsdoffGiven)
            	BSIM3ltvfbsdoff = 0.0;
            if(!BSIM3wtvfbsdoffGiven)
            	BSIM3wtvfbsdoff = 0.0;
            if(!BSIM3ptvfbsdoffGiven)
            	BSIM3ptvfbsdoff = 0.0;
            if(!BSIM3dlcigGiven)
            	BSIM3dlcig = BSIM3Lint;

            if(!BSIM3agislGiven)
            	BSIM3agisl = BSIM3agidl;
            if(!BSIM3wagislGiven)
            	BSIM3wagisl = BSIM3wagidl;
            if(!BSIM3lagislGiven)
            	BSIM3lagisl = BSIM3lagidl;
            if(!BSIM3pagislGiven)
            	BSIM3pagisl = BSIM3pagidl;
            if(!BSIM3bgislGiven)
            	BSIM3bgisl = BSIM3bgidl;
            if(!BSIM3wbgislGiven)
            	BSIM3wbgisl = BSIM3wbgidl;
            if(!BSIM3lbgislGiven)
            	BSIM3lbgisl = BSIM3lbgidl;
            if(!BSIM3pbgislGiven)
            	BSIM3pbgisl = BSIM3pbgidl;
            if(!BSIM3cgislGiven)
            	BSIM3cgisl = BSIM3cgidl;
            if(!BSIM3wcgislGiven)
            	BSIM3wcgisl = BSIM3wcgidl;
            if(!BSIM3lcgislGiven)
            	BSIM3lcgisl = BSIM3lcgidl;
            if(!BSIM3pcgislGiven)
            	BSIM3pcgisl = BSIM3pcgidl;
            if(!BSIM3egislGiven)
            	BSIM3egisl = BSIM3egidl;
            if(!BSIM3wegislGiven)
            	BSIM3wegisl = BSIM3wegidl;
            if(!BSIM3legislGiven)
            	BSIM3legisl = BSIM3legidl;
            if(!BSIM3pegislGiven)
            	BSIM3pegisl = BSIM3pegidl;
            if(!BSIM3rgislGiven)
            	BSIM3rgisl = BSIM3rgidl;
            if(!BSIM3wrgislGiven)
            	BSIM3wrgisl = BSIM3wrgidl;
            if(!BSIM3lrgislGiven)
            	BSIM3lrgisl = BSIM3lrgidl;
            if(!BSIM3prgislGiven)
            	BSIM3prgisl = BSIM3prgidl;
            if(!BSIM3kgislGiven)
            	BSIM3kgisl = BSIM3kgidl;
            if(!BSIM3wkgislGiven)
            	BSIM3wkgisl = BSIM3wkgidl;
            if(!BSIM3lkgislGiven)
            	BSIM3lkgisl = BSIM3lkgidl;
            if(!BSIM3pkgislGiven)
            	BSIM3pkgisl = BSIM3pkgidl;
            if(!BSIM3fgislGiven)
            	BSIM3fgisl = BSIM3fgidl;
            if(!BSIM3wfgislGiven)
            	BSIM3wfgisl = BSIM3wfgidl;
            if(!BSIM3lfgislGiven)
            	BSIM3lfgisl = BSIM3lfgidl;
            if(!BSIM3pfgislGiven)
            	BSIM3pfgisl = BSIM3pfgidl;

            if (!BSIM3agidlGiven)
                BSIM3agidl = 0.0;
            if (!BSIM3bgidlGiven)
                BSIM3bgidl = 2.3e9; /* V/m */
            if (!BSIM3cgidlGiven)
                BSIM3cgidl = 0.5;   /* V^3 */
            if (!BSIM3egidlGiven)
                BSIM3egidl = 0.8;   /* V */
            if (!BSIM3aigcGiven)
                BSIM3aigc = (BSIM3type == `NMOS) ? 1.36e-2 : 9.80e-3;
            if (!BSIM3bigcGiven)
                BSIM3bigc = (BSIM3type == `NMOS) ? 1.71e-3 : 7.59e-4;
            if (!BSIM3cigcGiven)
                BSIM3cigc = (BSIM3type == `NMOS) ? 0.075 : 0.03;
            if (BSIM3aigsdGiven) begin
              BSIM3aigs = BSIM3aigsd;
              BSIM3aigd = BSIM3aigsd;
            end
            else begin
                BSIM3aigsd = (BSIM3type == `NMOS) ? 1.36e-2 : 9.80e-3;
                if (!BSIM3aigsGiven)
                  BSIM3aigs = (BSIM3type == `NMOS) ? 1.36e-2 : 9.80e-3;
                if (!BSIM3aigdGiven)
                  BSIM3aigd = (BSIM3type == `NMOS) ? 1.36e-2 : 9.80e-3;
            end
            if (BSIM3bigsdGiven) begin
              BSIM3bigs = BSIM3bigsd;
              BSIM3bigd = BSIM3bigsd;
            end
            else begin
                BSIM3bigsd = (BSIM3type == `NMOS) ? 1.71e-3 : 7.59e-4; 
                if (!BSIM3bigsGiven)
                  BSIM3bigs = (BSIM3type == `NMOS) ? 1.71e-3 : 7.59e-4;
                if (!BSIM3bigdGiven)
                  BSIM3bigd = (BSIM3type == `NMOS) ? 1.71e-3 : 7.59e-4;
            end
            if (BSIM3cigsdGiven) begin
                BSIM3cigs =BSIM3cigsd;
                BSIM3cigd = BSIM3cigsd;
            end
            else begin
               BSIM3cigsd = (BSIM3type == `NMOS) ? 0.075 : 0.03;
               if (!BSIM3cigsGiven)
                    BSIM3cigs = (BSIM3type == `NMOS) ? 0.075 : 0.03;
               if (!BSIM3cigdGiven)
                    BSIM3cigd = (BSIM3type == `NMOS) ? 0.075 : 0.03;
            end
            
            if (!BSIM3aigbaccGiven)
                BSIM3aigbacc = 1.36e-2;
            if (!BSIM3bigbaccGiven)
                BSIM3bigbacc = 1.71e-3;
            if (!BSIM3cigbaccGiven)
                BSIM3cigbacc = 0.075;
            if (!BSIM3aigbinvGiven)
                BSIM3aigbinv = 1.11e-2;
            if (!BSIM3bigbinvGiven)
                BSIM3bigbinv = 9.49e-4;
            if (!BSIM3cigbinvGiven)
                BSIM3cigbinv = 0.006;
            if (!BSIM3nigcGiven)
                BSIM3nigc = 1.0;
            if (!BSIM3nigbinvGiven)
                BSIM3nigbinv = 3.0;
            if (!BSIM3nigbaccGiven)
                BSIM3nigbacc = 1.0;
            if (!BSIM3ntoxGiven)
                BSIM3ntox = 1.0;
            if (!BSIM3eigbinvGiven)
                BSIM3eigbinv = 1.1;
            if (!BSIM3pigcdGiven)
                BSIM3pigcd = 1.0;
            if (!BSIM3poxedgeGiven)
                BSIM3poxedge = 1.0;
            if (!BSIM3lagidlGiven)
                BSIM3lagidl = 0.0;
            if (!BSIM3lbgidlGiven)
                BSIM3lbgidl = 0.0;
            if (!BSIM3lcgidlGiven)
                BSIM3lcgidl = 0.0;
            if (!BSIM3legidlGiven)
                BSIM3legidl = 0.0;
            if (!BSIM3laigcGiven)
                BSIM3laigc = 0.0;
            if (!BSIM3lbigcGiven)
                BSIM3lbigc = 0.0;
            if (!BSIM3lcigcGiven)
                BSIM3lcigc = 0.0;
            if (!BSIM3laigsdGiven)
                BSIM3laigsd = 0.0;
            if (!BSIM3lbigsdGiven)
                BSIM3lbigsd = 0.0;
            if (!BSIM3lcigsdGiven)
                BSIM3lcigsd = 0.0;
            if (!BSIM3laigbaccGiven)
                BSIM3laigbacc = 0.0;
            if (!BSIM3lbigbaccGiven)
                BSIM3lbigbacc = 0.0;
            if (!BSIM3lcigbaccGiven)
                BSIM3lcigbacc = 0.0;
            if (!BSIM3laigbinvGiven)
                BSIM3laigbinv = 0.0;
            if (!BSIM3lbigbinvGiven)
                BSIM3lbigbinv = 0.0;
            if (!BSIM3lcigbinvGiven)
                BSIM3lcigbinv = 0.0;
            if (!BSIM3lnigcGiven)
                BSIM3lnigc = 0.0;
            if (!BSIM3lnigbinvGiven)
                BSIM3lnigbinv = 0.0;
            if (!BSIM3lnigbaccGiven)
                BSIM3lnigbacc = 0.0;
            if (!BSIM3lntoxGiven)
                BSIM3lntox = 0.0;
            if (!BSIM3leigbinvGiven)
                BSIM3leigbinv = 0.0;
            if (!BSIM3lpigcdGiven)
                BSIM3lpigcd = 0.0;
            if (!BSIM3lpoxedgeGiven)
                BSIM3lpoxedge = 0.0;
            if (!BSIM3wagidlGiven)
                BSIM3wagidl = 0.0;
            if (!BSIM3wbgidlGiven)
                BSIM3wbgidl = 0.0;
            if (!BSIM3wcgidlGiven)
                BSIM3wcgidl = 0.0;
            if (!BSIM3wegidlGiven)
                BSIM3wegidl = 0.0;
            if (!BSIM3waigcGiven)
                BSIM3waigc = 0.0;
            if (!BSIM3wbigcGiven)
                BSIM3wbigc = 0.0;
            if (!BSIM3wcigcGiven)
                BSIM3wcigc = 0.0;
            if (!BSIM3waigsdGiven)
                BSIM3waigsd = 0.0;
            if (!BSIM3wbigsdGiven)
                BSIM3wbigsd = 0.0;
            if (!BSIM3wcigsdGiven)
                BSIM3wcigsd = 0.0;
            if (!BSIM3waigbaccGiven)
                BSIM3waigbacc = 0.0;
            if (!BSIM3wbigbaccGiven)
                BSIM3wbigbacc = 0.0;
            if (!BSIM3wcigbaccGiven)
                BSIM3wcigbacc = 0.0;
            if (!BSIM3waigbinvGiven)
                BSIM3waigbinv = 0.0;
            if (!BSIM3wbigbinvGiven)
                BSIM3wbigbinv = 0.0;
            if (!BSIM3wcigbinvGiven)
                BSIM3wcigbinv = 0.0;
            if (!BSIM3wnigcGiven)
                BSIM3wnigc = 0.0;
            if (!BSIM3wnigbinvGiven)
                BSIM3wnigbinv = 0.0;
            if (!BSIM3wnigbaccGiven)
                BSIM3wnigbacc = 0.0;
            if (!BSIM3wntoxGiven)
                BSIM3wntox = 0.0;
            if (!BSIM3weigbinvGiven)
                BSIM3weigbinv = 0.0;
            if (!BSIM3wpigcdGiven)
                BSIM3wpigcd = 0.0;
            if (!BSIM3wpoxedgeGiven)
                BSIM3wpoxedge = 0.0;
            if (!BSIM3pagidlGiven)
                BSIM3pagidl = 0.0;
            if (!BSIM3pbgidlGiven)
                BSIM3pbgidl = 0.0;
            if (!BSIM3pcgidlGiven)
                BSIM3pcgidl = 0.0;
            if (!BSIM3pegidlGiven)
                BSIM3pegidl = 0.0;
            if (!BSIM3paigcGiven)
                BSIM3paigc = 0.0;
            if (!BSIM3pbigcGiven)
                BSIM3pbigc = 0.0;
            if (!BSIM3pcigcGiven)
                BSIM3pcigc = 0.0;
            if (!BSIM3paigsdGiven)
                BSIM3paigsd = 0.0;
            if (!BSIM3pbigsdGiven)
                BSIM3pbigsd = 0.0;
            if (!BSIM3pcigsdGiven)
                BSIM3pcigsd = 0.0;
            if (!BSIM3paigbaccGiven)
                BSIM3paigbacc = 0.0;
            if (!BSIM3pbigbaccGiven)
                BSIM3pbigbacc = 0.0;
            if (!BSIM3pcigbaccGiven)
                BSIM3pcigbacc = 0.0;
            if (!BSIM3paigbinvGiven)
                BSIM3paigbinv = 0.0;
            if (!BSIM3pbigbinvGiven)
                BSIM3pbigbinv = 0.0;
            if (!BSIM3pcigbinvGiven)
                BSIM3pcigbinv = 0.0;
            if (!BSIM3pnigcGiven)
                BSIM3pnigc = 0.0;
            if (!BSIM3pnigbinvGiven)
                BSIM3pnigbinv = 0.0;
            if (!BSIM3pnigbaccGiven)
                BSIM3pnigbacc = 0.0;
            if (!BSIM3pntoxGiven)
                BSIM3pntox = 0.0;
            if (!BSIM3peigbinvGiven)
                BSIM3peigbinv = 0.0;
            if (!BSIM3ppigcdGiven)
                BSIM3ppigcd = 0.0;
            if (!BSIM3ppoxedgeGiven)
                BSIM3ppoxedge = 0.0;
            //New model stimod
            if(!BSIM3wlodGiven)
            	BSIM3wlod = 0.0;
            if(!BSIM3ku0Given)
            	BSIM3ku0 = 0.0;
            if(!BSIM3kvsatGiven)
            	BSIM3kvsat = 0.0;
            if(!BSIM3kvth0Given)
            	BSIM3kvth0 = 0.0;
            if(!BSIM3tku0Given)
            	BSIM3tku0 = 0.0;
            if(!BSIM3llodku0Given)
            	BSIM3llodku0 = 0.0;
            if(!BSIM3wlodku0Given)
            	BSIM3wlodku0 = 0.0;
            if(!BSIM3llodvthGiven)
            	BSIM3llodvth = 0.0;
            if(!BSIM3wlodvthGiven)
            	BSIM3wlodvth = 0.0;
            if(!BSIM3lku0Given)
            	BSIM3lku0 = 0.0;
            if(!BSIM3wku0Given)
            	BSIM3wku0 = 0.0;
            if(!BSIM3pku0Given)
            	BSIM3pku0 = 0.0;
            if(!BSIM3lkvth0Given)
            	BSIM3lkvth0 = 0.0;
            if(!BSIM3wkvth0Given)
            	BSIM3wkvth0 = 0.0;
            if(!BSIM3pkvth0Given)
            	BSIM3pkvth0 = 0.0;
            if(!BSIM3stk2Given)
            	BSIM3stk2 = 0.0;
            if(!BSIM3lodk2Given)
            	BSIM3lodk2 = 0.0;
            if(!BSIM3steta0Given)
            	BSIM3steta0 = 0.0;
            if(!BSIM3lodeta0Given)
            	BSIM3lodeta0 = 1.0;
            if(!BSIM3sa1Given)
            	BSIM3sa1 = 0.0;
            if(!BSIM3sa2Given)
            	BSIM3sa2 = 0.0;
            if(!BSIM3sa3Given)
            	BSIM3sa3 = 0.0;
            if(!BSIM3sa4Given)
            	BSIM3sa4 = 0.0;
            if(!BSIM3sa5Given)
            	BSIM3sa5 = 0.0;
            if(!BSIM3sa6Given)
            	BSIM3sa6 = 0.0;
            if(!BSIM3sa7Given)
            	BSIM3sa7 = 0.0;
            if(!BSIM3sa8Given)
            	BSIM3sa8 = 0.0;
            if(!BSIM3sa9Given)
            	BSIM3sa9 = 0.0;
            if(!BSIM3sa10Given)
            	BSIM3sa10 = 0.0;
            if(!BSIM3sb1Given)
            	BSIM3sb1 = 0.0;
            if(!BSIM3sb2Given)
            	BSIM3sb2 = 0.0;
            if(!BSIM3sb3Given)
            	BSIM3sb3 = 0.0;
            if(!BSIM3sb4Given)
            	BSIM3sb4 = 0.0;
            if(!BSIM3sb5Given)
            	BSIM3sb5 = 0.0;
            if(!BSIM3sb6Given)
            	BSIM3sb6 = 0.0;
            if(!BSIM3sb7Given)
            	BSIM3sb7 = 0.0;
            if(!BSIM3sb8Given)
            	BSIM3sb8 = 0.0;
            if(!BSIM3sb9Given)
            	BSIM3sb9 = 0.0;
            if(!BSIM3sb10Given)
            	BSIM3sb10 = 0.0;
            //if(!BSIM3sw1Given)
            //	BSIM3sw1 = 0.0;
            if(!BSIM3sw2Given)
            	BSIM3sw2 = 0.0;
            if(!BSIM3sw3Given)
            	BSIM3sw3 = 0.0;
            if(!BSIM3sw4Given)
            	BSIM3sw4 = 0.0;
            if(!BSIM3sw5Given)
            	BSIM3sw5 = 0.0;
            if(!BSIM3sw6Given)
            	BSIM3sw6 = 0.0;
            if(!BSIM3sw7Given)
            	BSIM3sw7 = 0.0;
            if(!BSIM3sw8Given)
            	BSIM3sw8 = 0.0;
            if(!BSIM3sw9Given)
            	BSIM3sw9 = 0.0;
            if(!BSIM3sw10Given)
            	BSIM3sw10 = 0.0;

        Igd = 0.0;
        Igs = 0.0;
        Voxacc = 0.0;
        Voxdepinv = 0.0;
        xmult=1.0;   //always set xmult=1?

        // BSIM3checkmodel
         if (BSIM3bulkJctPotential < 0.1) begin
	     BSIM3bulkJctPotential = 0.1;
	     $strobe("\nWarning: Given pb is less than 0.1. Pb is set to 0.1.\n");
	 end
         if (BSIM3sidewallJctPotential < 0.1) begin
	     BSIM3sidewallJctPotential = 0.1;
	     $strobe("\nWarning: Given pbsw is less than 0.1. Pbsw is set to 0.1.\n");
	 end
         if (BSIM3GatesidewallJctPotential < 0.1) begin
	     BSIM3GatesidewallJctPotential = 0.1;
	     $strobe("\nWarning: Given pbswg is less than 0.1. Pbswg is set to 0.1.\n");
	 end            
        // Temperature calculations 
        T = $temperature;
        TRatio = T / BSIM3tnom;
        BSIM3factor1 = `BSIM3_sqrt(`EPSSI / `EPSOX * BSIM3tox);
        Vtm0 = `KboQ * BSIM3tnom;
        Eg0 = 1.16 - 7.02e-4 * BSIM3tnom * BSIM3tnom / (BSIM3tnom + 1108.0);
        ni = 1.45e10 * (BSIM3tnom / 300.15) * `BSIM3_sqrt(BSIM3tnom / 300.15) 
              * exp(21.5565981 - Eg0 / (2.0 * Vtm0));
        
        BSIM3vtm = `KboQ * T;
        Eg = 1.16 - 7.02e-4 * T * T / (T + 1108.0);
        if (T != BSIM3tnom) begin
            T0 = Eg0 / Vtm0 - Eg / BSIM3vtm + BSIM3jctTempExponent 
                  * ln(T / BSIM3tnom);
            T1 = exp(T0 / BSIM3jctEmissionCoeff);
            BSIM3jctTempSatCurDensity = BSIM3jctSatCurDensity * T1;
            BSIM3jctSidewallTempSatCurDensity = BSIM3jctSidewallSatCurDensity 
                                                 * T1;
        end 
        else begin
            BSIM3jctTempSatCurDensity = BSIM3jctSatCurDensity;
            BSIM3jctSidewallTempSatCurDensity = BSIM3jctSidewallSatCurDensity;
        end 

        if (BSIM3jctTempSatCurDensity < 0.0)
            BSIM3jctTempSatCurDensity = 0.0;
        
        if (BSIM3jctSidewallTempSatCurDensity < 0.0)
            BSIM3jctSidewallTempSatCurDensity = 0.0;
 
        //New model ACM calculation ACM=0,1,2,3,10,11,12,13
	if (ad  == `NOT_GIVEN ) 
	    BSIM3drainArea = 0.0;
	
	if (as  == `NOT_GIVEN ) 
	    BSIM3sourceArea = 0.0;
	
        if (pd  == `NOT_GIVEN ) 
            BSIM3drainPerimeter = 0.0;
        
        if (ps  == `NOT_GIVEN ) 
            BSIM3sourcePerimeter = 0.0;
        
        //set nrd,nrs default=0.0
        if (nrd  == `NOT_GIVEN)   
            BSIM3drainSquares = 0.0;
        
        if (nrs  == `NOT_GIVEN) 
            BSIM3sourceSquares = 0.0;
        
          arg = wmlt * xmult;
          Leff = l*lmlt+xl-(ld+del)*2.0;
          Weff = w*wmlt+xw*2.0;
          here_w=Weff-wd*2.0;
          if (here_w == 0.0)
            here_w = 1.0e-12;

          rseff = rs;
          rdeff = rd;            
          if (wrs != 0.0 || lrs != 0.0 || prs != 0.0 || wrd != 0.0 
      	    || lrd != 0.0 || prd != 0.0) begin
      	   larg = lref * lmlt + xlref - (ld + del) * 2.0;
      	   warg = wref * wmlt + xwref - wd * 2.0;
      	   if (lref > 0.0) 
      	       T0 = 1.0 / (larg * 1e6);
      	   else 
      	       T0 = 0.0;
      	   
      	   if (wref > 0.0) 
      	       T1 = 1.0 / (warg * 1e6);
      	   else 
      	       T1 = 0.0;
      	   
      	   T2 = 1.0 / (Leff * 1e6) - T0;
      	   T3 = 1.0 / (here_w * 1e6) - T1;
      	   T4 = T2 * T3;
      	   rseff = rs + wrs * T3 + lrs * T2 + prs * T4;
      	   rdeff = rd + wrd * T3 + lrd * T2 + prd * T4;
          end
          case(BSIM3acm)
          0,10: begin
            BSIM3drainArea = BSIM3drainArea * arg * wmlt;
            BSIM3sourceArea = BSIM3sourceArea * arg * wmlt;
            BSIM3drainPerimeter = BSIM3drainPerimeter * arg;
            BSIM3sourcePerimeter = BSIM3sourcePerimeter * arg;
            rdpr = rdeff + rdc;
            rspr = rseff + rsc;
          end
          1,11: begin
            BSIM3drainArea = Weff * wmlt;
            BSIM3sourceArea = Weff * wmlt;
            BSIM3drainPerimeter = Weff;
            BSIM3sourcePerimeter = Weff;
            val = (ld + ldif) / Weff;
            rdpr = val * rdeff + BSIM3drainSquares * rsh;
            rspr = val * rseff + BSIM3sourceSquares * rsh;
            rdpr =rdpr+ rdc;
            rspr =rspr+ rsc;
          end
          2,12: begin 
          T0 = hdif * wmlt;
          if ( ad == `NOT_GIVEN) begin 
              BSIM3drainArea = (T0 + T0) * Weff;
              BSIM3drainArea = BSIM3drainArea*xmult;
          end
          else 
              BSIM3drainArea = BSIM3drainArea * arg * wmlt;
          
          if (as == `NOT_GIVEN) begin
              BSIM3sourceArea = (T0 + T0) * Weff;
              BSIM3sourceArea = BSIM3sourceArea*xmult;
          end
          else 
              BSIM3sourceArea = BSIM3sourceArea * arg * wmlt;
          
          if (pd == `NOT_GIVEN) begin
              BSIM3drainPerimeter = T0 + T0 + T0 + T0 + (Weff + Weff);
              BSIM3drainPerimeter = BSIM3drainPerimeter*xmult;
          end
          else
              BSIM3drainPerimeter =BSIM3drainPerimeter* arg;
          
          if (ps == `NOT_GIVEN) begin
              BSIM3sourcePerimeter = T0 + T0 + T0 + T0 + (Weff + Weff);
              BSIM3sourcePerimeter = BSIM3sourcePerimeter*xmult;
          end
          else
              BSIM3sourcePerimeter =BSIM3sourcePerimeter* arg;
          
          ecjsw=cjsw;
          if (cjgate != cjsw) begin
              czbdsw = cjsw * BSIM3drainPerimeter + (cjgate - cjsw) * min(BSIM3drainPerimeter,Weff);
              if (cjsw == 0.0 && cjgate > 0.0) 
                  ecjsw = cjgate;
              if (ecjsw > 0.0)
                  BSIM3drainPerimeter = czbdsw / ecjsw;
              
              czbssw = cjsw * BSIM3sourcePerimeter + (cjgate - cjsw) * min(BSIM3sourcePerimeter,Weff);
              if (ecjsw > 0.0) 
                  BSIM3sourcePerimeter = czbssw / ecjsw;
              
          end
          val = (ld + ldif) / Weff;
          if (nrd == `NOT_GIVEN) begin
              BSIM3drainSquares = T0 / Weff;
          end
          rdpr = val * rdeff + BSIM3drainSquares * rsh + rdc;
          if (nrs == `NOT_GIVEN) 
              BSIM3sourceSquares = T0 / Weff;
          
          rspr = val * rseff + BSIM3sourceSquares * rsh + rsc;
          end 
          3,13: begin 
          T0 = hdif * wmlt;
          ecjgat = cjgate; //TODO check ?
          if (cjgate != 0.0) 
              ecjgat = cjgate * Weff * xmult;
          
          if (BSIM3drainArea == 0) begin
              if (geo == 0 || geo == 2) 
                  BSIM3drainArea = (T0 + T0) * Weff;
              else 
                  BSIM3drainArea = T0 * Weff;
              
              BSIM3drainArea = BSIM3drainArea*xmult;
          end else 
              BSIM3drainArea = BSIM3drainArea * arg * wmlt;
          
          if (BSIM3sourceArea == 0) begin
              if (geo == 0 || geo == 1) 
                  BSIM3sourceArea = (T0 + T0) * Weff;
              else 
                  BSIM3sourceArea = T0 * Weff;
              
              BSIM3sourceArea =BSIM3sourceArea*xmult;
          end else 
              BSIM3sourceArea = BSIM3sourceArea * arg * wmlt;
          
          if (pd == `NOT_GIVEN) begin
              if (geo == 0 || geo == 2) 
                  BSIM3drainPerimeter = T0 + T0 + T0 + T0 + Weff;
              else 
                  BSIM3drainPerimeter = T0 + T0;
              
              BSIM3drainPerimeter =BSIM3drainPerimeter*xmult;
          end else 
              BSIM3drainPerimeter =BSIM3drainPerimeter* arg;
          
          if (ps == `NOT_GIVEN) begin
              if (geo == 0 || geo == 1) 
                  BSIM3sourcePerimeter = T0 + T0 + T0 + T0 + Weff;
              else 
                  BSIM3sourcePerimeter = T0 + T0;
              
              BSIM3sourcePerimeter =BSIM3sourcePerimeter*xmult;
          end else 
              BSIM3sourcePerimeter =BSIM3sourcePerimeter* arg;
          
          val = (ld + ldif) / Weff;
          if (nrd == `NOT_GIVEN) 
              BSIM3drainSquares = T0 / Weff;
          
          rdpr = val * rdeff + BSIM3drainSquares * rsh + rdc;
          if (nrs == `NOT_GIVEN) 
              BSIM3sourceSquares = T0 / Weff;
          
          rspr = val * rseff + BSIM3sourceSquares * rsh + rsc;
          end 
          default:  //same as acm=0,10
          begin
            BSIM3drainArea = BSIM3drainArea * arg * wmlt;
            BSIM3sourceArea = BSIM3sourceArea * arg * wmlt;
            BSIM3drainPerimeter = BSIM3drainPerimeter * arg;
            BSIM3sourcePerimeter = BSIM3sourcePerimeter * arg;
            rdpr = rdeff + rdc;
            rspr = rseff + rsc;
          end
          endcase 
          rdpr = (rdpr>`EPSMIN ? max(`RESMIX, rdpr):0.0);
          rspr = (rspr>`EPSMIN ? max(`RESMIX, rspr):0.0);          
        
        //New model starts for preprocessing instance params
        if(BSIM3stiMod !=0 && BSIM3stiMod !=1 && BSIM3stiMod !=2)
          BSIM3stiMod = 0;
          
        /* Temperature dependence of D/B and S/B diode capacitance begins */
        delTemp = T - BSIM3tnom;
        T0 = BSIM3tcj * delTemp;
        if (T0 >= -1.0)
            BSIM3unitAreaTempJctCap = BSIM3unitAreaJctCap * (1.0 + T0);
        else if (BSIM3unitAreaJctCap > 0.0) begin
            BSIM3unitAreaTempJctCap = 0.0;
            $strobe( "Temperature effect has caused cj to be negative.  \
                      Cj is clamped to zero.\n");
        end 
        
        T0 = BSIM3tcjsw * delTemp;
        if (T0 >= -1.0)
            BSIM3unitLengthSidewallTempJctCap = BSIM3unitLengthSidewallJctCap 
                                                 * (1.0 + T0);
        else if (BSIM3unitLengthSidewallJctCap > 0.0) begin
            BSIM3unitLengthSidewallTempJctCap = 0.0;
            $strobe( "Temperature effect has caused cjsw to be negative. \
                      Cjsw is clamped to zero.\n");
        end 
        T0 = BSIM3tcjswg * delTemp;
        if (T0 >= -1.0)
            BSIM3unitLengthGateSidewallTempJctCap = (1.0 + T0)
                                           * BSIM3unitLengthGateSidewallJctCap;
        else if (BSIM3unitLengthGateSidewallJctCap > 0.0) begin
            BSIM3unitLengthGateSidewallTempJctCap = 0.0;
            $strobe( "Temperature effect has caused cjswg to be negative. \
                      Cjswg is clamped to zero.\n");
        end 
        BSIM3PhiB = BSIM3bulkJctPotential - BSIM3tpb * delTemp;
        if (BSIM3PhiB < 0.01) begin
            BSIM3PhiB = 0.01;
            $strobe( "Temperature effect has caused pb to be less than 0.01. \
                      Pb is clamped to 0.01.\n");
        end 
        BSIM3PhiBSW = BSIM3sidewallJctPotential - BSIM3tpbsw * delTemp;
        
        if (BSIM3PhiBSW <= 0.01) begin
            BSIM3PhiBSW = 0.01;
            $strobe( "Temperature effect has caused pbsw to be less than 0.01. \
                      Pbsw is clamped to 0.01.\n");
        end // if (BSIM3PhiBSW <= 0.01)
        
        BSIM3PhiBSWG = BSIM3GatesidewallJctPotential - BSIM3tpbswg * delTemp;
        
        if (BSIM3PhiBSWG <= 0.01) begin
            BSIM3PhiBSWG = 0.01;
            $strobe( "Temperature effect has caused pbswg to be less than 0.01.\
                        Pbswg is clamped to 0.01.\n");
        end // if (BSIM3PhiBSWG <= 0.01)

        //Lnew = Leff + 2.0*BSIM3Lint;
        //Wnew = here_w + 2.0*BSIM3Wint;
        //fixed
        Lnew = l;
        Wnew = w;
        Ldrn = Lnew-xl; 
        Wdrn = Wnew-xw; 

        if(!BSIM3sw1Given)
            BSIM3sw1 = Wnew;
        //New model: change  L/Wdrn->L/Wnew 
        T0 = pow(Lnew, BSIM3Lln);
        T1 = pow(Wnew, BSIM3Lwn);
        tmp1 = BSIM3Ll / T0 + BSIM3Lw / T1 + BSIM3Lwl / (T0 * T1);
        BSIM3dl = BSIM3Lint + tmp1;
        tmp2 = BSIM3Llc / T0 + BSIM3Lwc / T1 + BSIM3Lwlc / (T0 * T1);
        BSIM3dlc = BSIM3dlc + tmp2;
        T2 = pow(Lnew, BSIM3Wln);
        T3 = pow(Wnew, BSIM3Wwn);
        tmp1 = BSIM3Wl / T2 + BSIM3Ww / T3 + BSIM3Wwl / (T2 * T3);
        BSIM3dw = BSIM3Wint + tmp1;
        tmp2 = BSIM3Wlc / T2 + BSIM3Wwc / T3 + BSIM3Wwlc / (T2 * T3);
              
        BSIM3dwc = BSIM3dwc + tmp2;
        BSIM3leff = Lnew - 2.0 * BSIM3dl;
        BSIM3weff = Wnew - 2.0 * BSIM3dw;
        BSIM3leffCV = Lnew - 2.0 * BSIM3dlc;
        BSIM3weffCV = Wnew - 2.0 * BSIM3dwc;
        if(BSIM3leff <= 0.0)
            $strobe("\nFatal: Effective channel length %g <= 0",BSIM3leff);
        if(BSIM3weff <= 0.0)
            $strobe("\nFatal: Effective channel width %g <= 0",BSIM3weff);

        if(BSIM3leffCV <= 0.0)
            $strobe("\nFatal: Effective channel length-CV %g <= 0",BSIM3leffCV);
        if(BSIM3weffCV <= 0.0)
            $strobe("\nFatal: Effective channel width-CV %g <= 0",BSIM3weffCV);
        if(!(BSIM3acm < 3.1 || (BSIM3calcacm > 0 && (BSIM3acm < 12.1 && BSIM3acm > 11.9)))) 
        //use the previous calculated values from ACM
         begin
        //use the orignal values from instance line
          BSIM3sourceArea = as ;
          BSIM3drainArea = ad ;
          BSIM3sourcePerimeter = ps ;
          BSIM3drainPerimeter = pd ;
         end

        if(BSIM3sourceArea < 0.0)
            BSIM3sourceArea = 0.0;
        if(BSIM3drainArea < 0.0)
            BSIM3drainArea = 0.0;
        if(BSIM3sourcePerimeter <0.0) BSIM3sourcePerimeter=0.0;
        if(BSIM3drainPerimeter<0.0) BSIM3drainPerimeter = 0.0;
        
        //New model Binflag
        if ( binflag > 0.9 && lref > 0 && wref > 0 ) 
          BSIM3binflag = 1 ;
        else 
          BSIM3binflag = 0 ;

        if ( BSIM3binflag > 0.9 ) begin
          if (BSIM3binUnit == 1)
            begin   
              Inv_L = (1.0e-6/BSIM3leff - 1.0e-6/lref);
              Inv_W = (1.0e-6 / BSIM3weff - 1.0e-6 /wref);
              Inv_LW = Inv_L * Inv_W;
            end
          else
            begin   
              Inv_L = (1.0 / BSIM3leff - 1.0 / lref);
              Inv_W = (1.0 / BSIM3weff - 1.0 / wref);
              Inv_LW = Inv_L * Inv_W;
            end
        end else begin
          if (BSIM3binUnit == 1)
            begin
              Inv_L = 1.0e-6/BSIM3leff ;
              Inv_W = 1.0e-6 / BSIM3weff;
              Inv_LW = 1.0e-12 / (BSIM3leff * BSIM3weff);
            end
          else
            begin   
              Inv_L = 1.0 / BSIM3leff;
              Inv_W = 1.0 / BSIM3weff;
              Inv_LW = 1.0 / (BSIM3leff * BSIM3weff);
            end
        end
        
        
        BSIM3cdsc = BSIM3cdsc
                 + BSIM3lcdsc * Inv_L
                 + BSIM3wcdsc * Inv_W
                 + BSIM3pcdsc * Inv_LW;
        BSIM3cdscb = BSIM3cdscb
                  + BSIM3lcdscb * Inv_L
                  + BSIM3wcdscb * Inv_W
                  + BSIM3pcdscb * Inv_LW; 
        BSIM3cdscd = BSIM3cdscd
                  + BSIM3lcdscd * Inv_L
                  + BSIM3wcdscd * Inv_W
                  + BSIM3pcdscd * Inv_LW; 
        BSIM3cit = BSIM3cit
                + BSIM3lcit * Inv_L
                + BSIM3wcit * Inv_W
                + BSIM3pcit * Inv_LW;
        BSIM3nfactor = BSIM3nfactor
                    + BSIM3lnfactor * Inv_L
                    + BSIM3wnfactor * Inv_W
                    + BSIM3pnfactor * Inv_LW;
        BSIM3xj = BSIM3xj
               + BSIM3lxj * Inv_L
               + BSIM3wxj * Inv_W
               + BSIM3pxj * Inv_LW;
        BSIM3vsat = BSIM3vsat
                 + BSIM3lvsat * Inv_L
                 + BSIM3wvsat * Inv_W
                 + BSIM3pvsat * Inv_LW;
        BSIM3at = BSIM3at
               + BSIM3lat * Inv_L
               + BSIM3wat * Inv_W
               + BSIM3pat * Inv_LW;
        BSIM3a0 = BSIM3a0
               + BSIM3la0 * Inv_L
               + BSIM3wa0 * Inv_W
               + BSIM3pa0 * Inv_LW; 
        BSIM3ags = BSIM3ags
                + BSIM3lags * Inv_L
                + BSIM3wags * Inv_W
                + BSIM3pags * Inv_LW;
        BSIM3a1 = BSIM3a1
               + BSIM3la1 * Inv_L
               + BSIM3wa1 * Inv_W
               + BSIM3pa1 * Inv_LW;
        BSIM3a2 = BSIM3a2
               + BSIM3la2 * Inv_L
               + BSIM3wa2 * Inv_W
               + BSIM3pa2 * Inv_LW;
        BSIM3keta = BSIM3keta
                 + BSIM3lketa * Inv_L
                 + BSIM3wketa * Inv_W
                 + BSIM3pketa * Inv_LW;
        BSIM3nsub = BSIM3nsub
                 + BSIM3lnsub * Inv_L
                 + BSIM3wnsub * Inv_W
                 + BSIM3pnsub * Inv_LW;
        BSIM3npeak = BSIM3npeak
                  + BSIM3lnpeak * Inv_L
                  + BSIM3wnpeak * Inv_W
                  + BSIM3pnpeak * Inv_LW;
        BSIM3ngate = BSIM3ngate
                  + BSIM3lngate * Inv_L
                  + BSIM3wngate * Inv_W
                  + BSIM3pngate * Inv_LW;
        BSIM3gamma1 = BSIM3gamma1
                   + BSIM3lgamma1 * Inv_L
                   + BSIM3wgamma1 * Inv_W
                   + BSIM3pgamma1 * Inv_LW;
        BSIM3gamma2 = BSIM3gamma2
                   + BSIM3lgamma2 * Inv_L
                   + BSIM3wgamma2 * Inv_W
                   + BSIM3pgamma2 * Inv_LW;
        BSIM3vbx = BSIM3vbx
                + BSIM3lvbx * Inv_L
                + BSIM3wvbx * Inv_W
                + BSIM3pvbx * Inv_LW;
        BSIM3vbm = BSIM3vbm
                + BSIM3lvbm * Inv_L
                + BSIM3wvbm * Inv_W
                + BSIM3pvbm * Inv_LW;
        BSIM3xt = BSIM3xt
               + BSIM3lxt * Inv_L
               + BSIM3wxt * Inv_W
               + BSIM3pxt * Inv_LW;
        BSIM3vfb = BSIM3vfb
                + BSIM3lvfb * Inv_L
                + BSIM3wvfb * Inv_W
                + BSIM3pvfb * Inv_LW;
        BSIM3k1 = BSIM3k1
               + BSIM3lk1 * Inv_L
               + BSIM3wk1 * Inv_W
               + BSIM3pk1 * Inv_LW;
        BSIM3kt1 = BSIM3kt1
                + BSIM3lkt1 * Inv_L
                + BSIM3wkt1 * Inv_W
                + BSIM3pkt1 * Inv_LW;
        BSIM3kt1l = BSIM3kt1l
                 + BSIM3lkt1l * Inv_L
                 + BSIM3wkt1l * Inv_W
                 + BSIM3pkt1l * Inv_LW;
        BSIM3k2 = BSIM3k2
               + BSIM3lk2 * Inv_L
               + BSIM3wk2 * Inv_W
               + BSIM3pk2 * Inv_LW;
        BSIM3kt2 = BSIM3kt2
                + BSIM3lkt2 * Inv_L
                + BSIM3wkt2 * Inv_W
                + BSIM3pkt2 * Inv_LW;
        BSIM3k3 = BSIM3k3
               + BSIM3lk3 * Inv_L
               + BSIM3wk3 * Inv_W
               + BSIM3pk3 * Inv_LW;
        BSIM3k3b = BSIM3k3b
                + BSIM3lk3b * Inv_L
                + BSIM3wk3b * Inv_W
                + BSIM3pk3b * Inv_LW;
        BSIM3w0 = BSIM3w0
               + BSIM3lw0 * Inv_L
               + BSIM3ww0 * Inv_W
               + BSIM3pw0 * Inv_LW;
        BSIM3nlx = BSIM3nlx
                + BSIM3lnlx * Inv_L
                + BSIM3wnlx * Inv_W
                + BSIM3pnlx * Inv_LW;
        BSIM3dvt0 = BSIM3dvt0
                 + BSIM3ldvt0 * Inv_L
                 + BSIM3wdvt0 * Inv_W
                 + BSIM3pdvt0 * Inv_LW;
        BSIM3dvt1 = BSIM3dvt1
                 + BSIM3ldvt1 * Inv_L
                 + BSIM3wdvt1 * Inv_W
                 + BSIM3pdvt1 * Inv_LW;
        BSIM3dvt2 = BSIM3dvt2
                 + BSIM3ldvt2 * Inv_L
                 + BSIM3wdvt2 * Inv_W
                 + BSIM3pdvt2 * Inv_LW;
        BSIM3dvt0w = BSIM3dvt0w
                  + BSIM3ldvt0w * Inv_L
                  + BSIM3wdvt0w * Inv_W
                  + BSIM3pdvt0w * Inv_LW;
        BSIM3dvt1w = BSIM3dvt1w
                  + BSIM3ldvt1w * Inv_L
                  + BSIM3wdvt1w * Inv_W
                  + BSIM3pdvt1w * Inv_LW;
        BSIM3dvt2w = BSIM3dvt2w
                  + BSIM3ldvt2w * Inv_L
                  + BSIM3wdvt2w * Inv_W
                  + BSIM3pdvt2w * Inv_LW;
        BSIM3drout = BSIM3drout
                  + BSIM3ldrout * Inv_L
                  + BSIM3wdrout * Inv_W
                  + BSIM3pdrout * Inv_LW;
        BSIM3dsub = BSIM3dsub
                 + BSIM3ldsub * Inv_L
                 + BSIM3wdsub * Inv_W
                 + BSIM3pdsub * Inv_LW;
        BSIM3vth0 = BSIM3vth0
                 + BSIM3lvth0 * Inv_L
                 + BSIM3wvth0 * Inv_W
                 + BSIM3pvth0 * Inv_LW;
        BSIM3ua = BSIM3ua
               + BSIM3lua * Inv_L
               + BSIM3wua * Inv_W
               + BSIM3pua * Inv_LW;
        BSIM3ua1 = BSIM3ua1
                + BSIM3lua1 * Inv_L
                + BSIM3wua1 * Inv_W
                + BSIM3pua1 * Inv_LW;
        BSIM3ub = BSIM3ub
               + BSIM3lub * Inv_L
               + BSIM3wub * Inv_W
               + BSIM3pub * Inv_LW;
        BSIM3ub1 = BSIM3ub1
                + BSIM3lub1 * Inv_L
                + BSIM3wub1 * Inv_W
                + BSIM3pub1 * Inv_LW;
        BSIM3uc = BSIM3uc
               + BSIM3luc * Inv_L
               + BSIM3wuc * Inv_W
               + BSIM3puc * Inv_LW;
        BSIM3uc1 = BSIM3uc1
                + BSIM3luc1 * Inv_L
                + BSIM3wuc1 * Inv_W
                + BSIM3puc1 * Inv_LW;
        BSIM3u0 = BSIM3u0
               + BSIM3lu0 * Inv_L
               + BSIM3wu0 * Inv_W
               + BSIM3pu0 * Inv_LW;
        BSIM3ute = BSIM3ute
                + BSIM3lute * Inv_L
                + BSIM3wute * Inv_W
                + BSIM3pute * Inv_LW;
        BSIM3voff = BSIM3voff
                 + BSIM3lvoff * Inv_L
                 + BSIM3wvoff * Inv_W
                 + BSIM3pvoff * Inv_LW;
        BSIM3delta = BSIM3delta
                  + BSIM3ldelta * Inv_L
                  + BSIM3wdelta * Inv_W
                  + BSIM3pdelta * Inv_LW;
        BSIM3rdsw = BSIM3rdsw
                 + BSIM3lrdsw * Inv_L
                 + BSIM3wrdsw * Inv_W
                 + BSIM3prdsw * Inv_LW;
        BSIM3prwg = BSIM3prwg
                 + BSIM3lprwg * Inv_L
                 + BSIM3wprwg * Inv_W
                 + BSIM3pprwg * Inv_LW;
        BSIM3prwb = BSIM3prwb
                 + BSIM3lprwb * Inv_L
                 + BSIM3wprwb * Inv_W
                 + BSIM3pprwb * Inv_LW;
        BSIM3prt = BSIM3prt
                + BSIM3lprt * Inv_L
                + BSIM3wprt * Inv_W
                + BSIM3pprt * Inv_LW;
        BSIM3eta0 = BSIM3eta0
                 + BSIM3leta0 * Inv_L
                 + BSIM3weta0 * Inv_W
                 + BSIM3peta0 * Inv_LW;
        BSIM3etab = BSIM3etab
                 + BSIM3letab * Inv_L
                 + BSIM3wetab * Inv_W
                 + BSIM3petab * Inv_LW;
        BSIM3pclm = BSIM3pclm
                 + BSIM3lpclm * Inv_L
                 + BSIM3wpclm * Inv_W
                 + BSIM3ppclm * Inv_LW;
        BSIM3pdibl1 = BSIM3pdibl1
                   + BSIM3lpdibl1 * Inv_L
                   + BSIM3wpdibl1 * Inv_W
                   + BSIM3ppdibl1 * Inv_LW;
        BSIM3pdibl2 = BSIM3pdibl2
                       + BSIM3lpdibl2 * Inv_L
                   + BSIM3wpdibl2 * Inv_W
                   + BSIM3ppdibl2 * Inv_LW;
        BSIM3pdiblb = BSIM3pdiblb
                   + BSIM3lpdiblb * Inv_L
                   + BSIM3wpdiblb * Inv_W
                   + BSIM3ppdiblb * Inv_LW;
        BSIM3pscbe1 = BSIM3pscbe1
                   + BSIM3lpscbe1 * Inv_L
                   + BSIM3wpscbe1 * Inv_W
                   + BSIM3ppscbe1 * Inv_LW;
        BSIM3pscbe2 = BSIM3pscbe2
                   + BSIM3lpscbe2 * Inv_L
                   + BSIM3wpscbe2 * Inv_W
                   + BSIM3ppscbe2 * Inv_LW;
        BSIM3pvag = BSIM3pvag
                 + BSIM3lpvag * Inv_L
                 + BSIM3wpvag * Inv_W
                 + BSIM3ppvag * Inv_LW;
        BSIM3wr = BSIM3wr
               + BSIM3lwr * Inv_L
               + BSIM3wwr * Inv_W
               + BSIM3pwr * Inv_LW;
        BSIM3dwg = BSIM3dwg
                + BSIM3ldwg * Inv_L
                + BSIM3wdwg * Inv_W
                + BSIM3pdwg * Inv_LW;
        BSIM3dwb = BSIM3dwb
                + BSIM3ldwb * Inv_L
                + BSIM3wdwb * Inv_W
                + BSIM3pdwb * Inv_LW;
        BSIM3b0 = BSIM3b0
               + BSIM3lb0 * Inv_L
               + BSIM3wb0 * Inv_W
               + BSIM3pb0 * Inv_LW;
        BSIM3b1 = BSIM3b1
               + BSIM3lb1 * Inv_L
               + BSIM3wb1 * Inv_W
               + BSIM3pb1 * Inv_LW;
        BSIM3alpha0 = BSIM3alpha0
                   + BSIM3lalpha0 * Inv_L
                   + BSIM3walpha0 * Inv_W
                   + BSIM3palpha0 * Inv_LW;
        BSIM3alpha1 = BSIM3alpha1
                   + BSIM3lalpha1 * Inv_L
                   + BSIM3walpha1 * Inv_W
                   + BSIM3palpha1 * Inv_LW;
        BSIM3beta0 = BSIM3beta0
                  + BSIM3lbeta0 * Inv_L
                  + BSIM3wbeta0 * Inv_W
                  + BSIM3pbeta0 * Inv_LW;
        BSIM3elm = BSIM3elm
                + BSIM3lelm * Inv_L
                + BSIM3welm * Inv_W
                + BSIM3pelm * Inv_LW;
                
        BSIM3cgsl = BSIM3cgsl
                 + BSIM3lcgsl * Inv_L
                 + BSIM3wcgsl * Inv_W
                 + BSIM3pcgsl * Inv_LW;
        BSIM3cgdl = BSIM3cgdl
                 + BSIM3lcgdl * Inv_L
                 + BSIM3wcgdl * Inv_W
                 + BSIM3pcgdl * Inv_LW;
        BSIM3ckappa = BSIM3ckappa
                   + BSIM3lckappa * Inv_L
                   + BSIM3wckappa * Inv_W
                   + BSIM3pckappa * Inv_LW;
        BSIM3cf = BSIM3cf
               + BSIM3lcf * Inv_L
               + BSIM3wcf * Inv_W
               + BSIM3pcf * Inv_LW;
        BSIM3clc = BSIM3clc
                + BSIM3lclc * Inv_L
                + BSIM3wclc * Inv_W
                + BSIM3pclc * Inv_LW;
        BSIM3cle = BSIM3cle
                + BSIM3lcle * Inv_L
                + BSIM3wcle * Inv_W
                + BSIM3pcle * Inv_LW;
        BSIM3vfbcv = BSIM3vfbcv
                  + BSIM3lvfbcv * Inv_L
                  + BSIM3wvfbcv * Inv_W
                  + BSIM3pvfbcv * Inv_LW;
        BSIM3acde = BSIM3acde
                 + BSIM3lacde * Inv_L
                 + BSIM3wacde * Inv_W
                 + BSIM3pacde * Inv_LW;
        BSIM3moin = BSIM3moin
                 + BSIM3lmoin * Inv_L
                 + BSIM3wmoin * Inv_W
                 + BSIM3pmoin * Inv_LW;
        BSIM3noff = BSIM3noff
                 + BSIM3lnoff * Inv_L
                 + BSIM3wnoff * Inv_W
                 + BSIM3pnoff * Inv_LW;
        BSIM3voffcv = BSIM3voffcv
                   + BSIM3lvoffcv * Inv_L
                   + BSIM3wvoffcv * Inv_W
                   + BSIM3pvoffcv * Inv_LW;
    //New model: BSIM4 igcmod and igbmod as hspice compatiable
        BSIM3agisl = BSIM3agisl
          + BSIM3lagisl * Inv_L
          + BSIM3wagisl * Inv_W
          + BSIM3pagisl * Inv_LW;

        BSIM3bgisl = BSIM3bgisl
          + BSIM3lbgisl * Inv_L
          + BSIM3wbgisl * Inv_W
          + BSIM3pbgisl * Inv_LW;

        BSIM3cgisl = BSIM3cgisl
          + BSIM3lcgisl * Inv_L
          + BSIM3wcgisl * Inv_W
          + BSIM3pcgisl * Inv_LW;

        BSIM3egisl = BSIM3egisl
          + BSIM3legisl * Inv_L
          + BSIM3wegisl * Inv_W
          + BSIM3pegisl * Inv_LW;

        BSIM3rgisl = BSIM3rgisl
          + BSIM3lrgisl * Inv_L
          + BSIM3wrgisl * Inv_W
          + BSIM3prgisl * Inv_LW;

        BSIM3kgisl = BSIM3kgisl
          + BSIM3lkgisl * Inv_L
          + BSIM3wkgisl * Inv_W
          + BSIM3pkgisl * Inv_LW;

        BSIM3fgisl = BSIM3fgisl
          + BSIM3lfgisl * Inv_L
          + BSIM3wfgisl * Inv_W
          + BSIM3pfgisl * Inv_LW;

        BSIM3rgidl = BSIM3rgidl
          + BSIM3lrgidl * Inv_L
          + BSIM3wrgidl * Inv_W
          + BSIM3prgidl * Inv_LW;

        BSIM3kgidl = BSIM3kgidl
          + BSIM3lkgidl * Inv_L
          + BSIM3wkgidl * Inv_W
          + BSIM3pkgidl * Inv_LW;

        BSIM3fgidl = BSIM3fgidl
          + BSIM3lfgidl * Inv_L
          + BSIM3wfgidl * Inv_W
          + BSIM3pfgidl * Inv_LW;                   
        BSIM3agidl = BSIM3agidl
          + BSIM3lagidl * Inv_L
          + BSIM3wagidl * Inv_W
          + BSIM3pagidl * Inv_LW;

        BSIM3bgidl = BSIM3bgidl
          + BSIM3lbgidl * Inv_L
          + BSIM3wbgidl * Inv_W
          + BSIM3pbgidl * Inv_LW;

        BSIM3cgidl = BSIM3cgidl
          + BSIM3lcgidl * Inv_L
          + BSIM3wcgidl * Inv_W
          + BSIM3pcgidl * Inv_LW;

        BSIM3egidl = BSIM3egidl
          + BSIM3legidl * Inv_L
          + BSIM3wegidl * Inv_W
          + BSIM3pegidl * Inv_LW;

        BSIM3nigc = BSIM3nigc
          + BSIM3lnigc * Inv_L
          + BSIM3wnigc * Inv_W
          + BSIM3pnigc * Inv_LW;

        BSIM3aigc = BSIM3aigc
          + BSIM3laigc * Inv_L
          + BSIM3waigc * Inv_W
          + BSIM3paigc * Inv_LW;

        BSIM3bigc = BSIM3bigc
          + BSIM3lbigc * Inv_L
          + BSIM3wbigc * Inv_W
          + BSIM3pbigc * Inv_LW;

        BSIM3cigc = BSIM3cigc
          + BSIM3lcigc * Inv_L
          + BSIM3wcigc * Inv_W
          + BSIM3pcigc * Inv_LW;

        BSIM3aigbacc = BSIM3aigbacc
          + BSIM3laigbacc * Inv_L
          + BSIM3waigbacc * Inv_W
          + BSIM3paigbacc * Inv_LW;

        BSIM3bigbacc = BSIM3bigbacc
          + BSIM3lbigbacc * Inv_L
          + BSIM3wbigbacc * Inv_W
          + BSIM3pbigbacc * Inv_LW;

        BSIM3cigbacc = BSIM3cigbacc
          + BSIM3lcigbacc * Inv_L
          + BSIM3wcigbacc * Inv_W
          + BSIM3pcigbacc * Inv_LW;

        BSIM3aigbinv = BSIM3aigbinv
          + BSIM3laigbinv * Inv_L
          + BSIM3waigbinv * Inv_W
          + BSIM3paigbinv * Inv_LW;

        BSIM3bigbinv = BSIM3bigbinv
          + BSIM3lbigbinv * Inv_L
          + BSIM3wbigbinv * Inv_W
          + BSIM3pbigbinv * Inv_LW;

        BSIM3cigbinv = BSIM3cigbinv
          + BSIM3lcigbinv * Inv_L
          + BSIM3wcigbinv * Inv_W
          + BSIM3pcigbinv * Inv_LW;

        BSIM3eigbinv = BSIM3eigbinv
          + BSIM3leigbinv * Inv_L
          + BSIM3weigbinv * Inv_W
          + BSIM3peigbinv * Inv_LW;

        BSIM3nigbinv = BSIM3nigbinv
          + BSIM3lnigbinv * Inv_L
          + BSIM3wnigbinv * Inv_W
          + BSIM3pnigbinv * Inv_LW;

        BSIM3ntox = BSIM3ntox
          + BSIM3lntox * Inv_L
          + BSIM3wntox * Inv_W
          + BSIM3pntox * Inv_LW;

        BSIM3nsd = BSIM3nsd
          + BSIM3lnsd * Inv_L
          + BSIM3wnsd * Inv_W
          + BSIM3pnsd * Inv_LW;

        BSIM3vfbsdoff = BSIM3vfbsdoff
          + BSIM3lvfbsdoff * Inv_L
          + BSIM3wvfbsdoff * Inv_W
          + BSIM3pvfbsdoff * Inv_LW;

        BSIM3tvfbsdoff = BSIM3tvfbsdoff
          + BSIM3ltvfbsdoff * Inv_L
          + BSIM3wtvfbsdoff * Inv_W
          + BSIM3ptvfbsdoff * Inv_LW;

        BSIM3aigs = BSIM3aigs
          + BSIM3laigs * Inv_L
          + BSIM3waigs * Inv_W
          + BSIM3paigs * Inv_LW;

        BSIM3bigs = BSIM3bigs
          + BSIM3lbigs * Inv_L
          + BSIM3wbigs * Inv_W
          + BSIM3pbigs * Inv_LW;

        BSIM3cigs = BSIM3cigs
          + BSIM3lcigs * Inv_L
          + BSIM3wcigs * Inv_W
          + BSIM3pcigs * Inv_LW;

        BSIM3aigd = BSIM3aigd
          + BSIM3laigd * Inv_L
          + BSIM3waigd * Inv_W
          + BSIM3paigd * Inv_LW;

        BSIM3bigd = BSIM3bigd
          + BSIM3lbigd * Inv_L
          + BSIM3wbigd * Inv_W
          + BSIM3pbigd * Inv_LW;

        BSIM3cigd = BSIM3cigd
          + BSIM3lcigd * Inv_L
          + BSIM3wcigd * Inv_W
          + BSIM3pcigd * Inv_LW;

        BSIM3aigsd = BSIM3aigsd
          + BSIM3laigsd * Inv_L
          + BSIM3waigsd * Inv_W
          + BSIM3paigsd * Inv_LW;

        BSIM3bigsd = BSIM3bigsd
          + BSIM3lbigsd * Inv_L
          + BSIM3wbigsd * Inv_W
          + BSIM3pbigsd * Inv_LW;

        BSIM3cigsd = BSIM3cigsd
          + BSIM3lcigsd * Inv_L
          + BSIM3wcigsd * Inv_W
          + BSIM3pcigsd * Inv_LW;

        BSIM3nigbacc = BSIM3nigbacc
          + BSIM3lnigbacc * Inv_L
          + BSIM3wnigbacc * Inv_W
          + BSIM3pnigbacc * Inv_LW;
                   
        BSIM3abulkCVfactor = 1.0 + pow((BSIM3clc/BSIM3leffCV), BSIM3cle);
        T0 = (TRatio - 1.0);
        BSIM3ua = BSIM3ua*BSIM3mulua + BSIM3ua1 * T0;
        BSIM3ub = BSIM3ub*BSIM3mulub + BSIM3ub1 * T0;
        BSIM3uc = BSIM3uc + BSIM3uc1 * T0;
        
        BSIM3u0 = BSIM3u0 * BSIM3mulu0;
        if (BSIM3u0 > 1.0 && version>3.021) 
            BSIM3u0 = BSIM3u0 / 1.0e4;

        BSIM3u0temp = BSIM3u0 * pow(TRatio, BSIM3ute); 
        BSIM3vsattemp = BSIM3vsat - BSIM3at * T0;
        BSIM3rds0 = (BSIM3rdsw + BSIM3prt * T0) / pow(BSIM3weff * 1E6, BSIM3wr);

        //Breakdown diode model
        if(BSIM3breakmod == 1) begin
          Vtm = `KboQ * T;
          Vtm0 = `KboQ*BSIM3tnom ;
          Nvtm  = Vtm * BSIM3jctEmissionCoeff;

          Eg0 = 1.16 - (7.02e-4 * BSIM3tnom * BSIM3tnom) / (BSIM3tnom + 1108.0);
          Eg = 1.16 - (7.02e-4 * T * T) / (T + 1108.0); 

          if (T != BSIM3tnom)
            begin
              T0 = Eg0 / Vtm0 - Eg / Vtm + BSIM3jctTempExponent
                * log(T / BSIM3tnom);
              T1 = exp(T0 / BSIM3jctEmissionCoeff);
              BSIM3jctTempSatCurDensity = BSIM3jctSatCurDensity * T1;
              BSIM3jctSidewallTempSatCurDensity
                = BSIM3jctSidewallSatCurDensity * T1;
            end
          else
            begin
              BSIM3jctTempSatCurDensity = BSIM3jctSatCurDensity;
              BSIM3jctSidewallTempSatCurDensity
                = BSIM3jctSidewallSatCurDensity;
            end
          
          if (BSIM3jctTempSatCurDensity < 0.0)
            BSIM3jctTempSatCurDensity = 0.0;
          if (BSIM3jctSidewallTempSatCurDensity < 0.0)
            BSIM3jctSidewallTempSatCurDensity = 0.0;
             
          /* drain side diode */
          if ((BSIM3bvd / Nvtm) > `EXP_THRESHOLD)
            BSIM3XExpBVD = BSIM3xjbvd * `MIN_EXP;
          else
            begin   
                BSIM3XExpBVD = exp(-BSIM3bvd / Nvtm);
                BSIM3XExpBVD =BSIM3XExpBVD*BSIM3xjbvd;
            end

          /* use UCB equations */
          if ((BSIM3drainArea <= 0.0) && (BSIM3drainPerimeter <= 0.0))
              BSIM3DrainSatCurrent = 1.0e-14;
          else
              BSIM3DrainSatCurrent = BSIM3drainArea
                                   * BSIM3jctTempSatCurDensity
                                   + BSIM3drainPerimeter
                                   * BSIM3jctSidewallTempSatCurDensity;
          /* BSIM3XExpBV -> BSIM3XExpBVD */
          `DioIjthVjmEval(Nvtm, BSIM3ijth, BSIM3DrainSatCurrent, BSIM3XExpBVD, BSIM3vjdmFwd)
          T0 = exp(BSIM3vjdmFwd / Nvtm);
          BSIM3IVjdmFwd = BSIM3DrainSatCurrent * (T0 - BSIM3XExpBVD / T0
            		  + BSIM3XExpBVD - 1.0);
          BSIM3DslpFwd = BSIM3DrainSatCurrent
                              * (T0 + BSIM3XExpBVD / T0) / Nvtm;

          /* bv->bvd, xjbv -> xjbvd, ijthrev -> ijthdrev */
          if (BSIM3xjbvd!=0.0) begin
              /* for breakdown linearization */
              T2=BSIM3ijthdrev/BSIM3DrainSatCurrent;
              if(T2<1.0) begin
                  T2=10.0;
                  $strobe( "Warning; ijthdrev too small and set to 10 times IdbSat. \n");
              end
              BSIM3vjdmRev = -BSIM3bvd - Vtm * BSIM3jctEmissionCoeff
                * log(T2 - 1.0) / BSIM3xjbvd;
            end else  
              BSIM3vjdmRev = -BSIM3bvd;
          
          T1 = BSIM3xjbvd * exp(-(BSIM3bvd + BSIM3vjdmRev) / Nvtm);
          BSIM3IVjdmRev = BSIM3DrainSatCurrent * (1.0 + T1);
          BSIM3DslpRev = -BSIM3DrainSatCurrent * T1 / Nvtm;
          
          /* source side diode */
          if ((BSIM3bvs / Nvtm) > `EXP_THRESHOLD)
              BSIM3XExpBVS = BSIM3xjbvs * `MIN_EXP;
          else begin   
              BSIM3XExpBVS = exp(-BSIM3bvs / Nvtm);
              BSIM3XExpBVS = BSIM3XExpBVS*BSIM3xjbvs;
          end

          /* use UCB equations */
          if ((BSIM3sourceArea <= 0.0) && (BSIM3sourcePerimeter <= 0.0))
              BSIM3SourceSatCurrent = 1.0e-14;
          else
              BSIM3SourceSatCurrent = BSIM3sourceArea
                                    * BSIM3jctTempSatCurDensity
                                    + BSIM3sourcePerimeter
                                    * BSIM3jctSidewallTempSatCurDensity;

          /* BSIM3XExpBV -> BSIM3XExpBVS */
          `DioIjthVjmEval(Nvtm, BSIM3ijth, BSIM3SourceSatCurrent,
            		  BSIM3XExpBVS, BSIM3vjsmFwd)
          T0 = exp(BSIM3vjsmFwd / Nvtm);
          BSIM3IVjsmFwd = BSIM3SourceSatCurrent * (T0 - BSIM3XExpBVS / T0
                               + BSIM3XExpBVS - 1.0);
          BSIM3SslpFwd = BSIM3SourceSatCurrent
                               * (T0 + BSIM3XExpBVS / T0) / Nvtm;

          /* bv->bvd, xjbv -> xjbvd, ijthrev -> ijthdrev */
          if (BSIM3xjbvs!=0.0) begin
              /* for breakdown linearization */
              T2=BSIM3ijthsrev/BSIM3SourceSatCurrent;
              if(T2<1.0) begin
                  T2=10.0;
                  $strobe( "Warning; ijthsrev too small and set to 10 times IsbSat. \n");
              end
              BSIM3vjsmRev = -BSIM3bvs - Vtm * BSIM3jctEmissionCoeff
                * log(T2 - 1.0) / BSIM3xjbvs;
            end else  
              BSIM3vjsmRev = -BSIM3bvs;
          
          T1 = BSIM3xjbvs * exp(-(BSIM3bvs + BSIM3vjsmRev) / Nvtm);
          BSIM3IVjsmRev = BSIM3SourceSatCurrent * (1.0 + T1);
          BSIM3SslpRev = -BSIM3SourceSatCurrent * T1 / Nvtm;
        end //end of breakmod
        
        //Check model params
        Fatal_Flag = 0;
        if(BSIM3capMod >2 && version < 3.11) begin
            BSIM3capMod = 2;
            $strobe("Warning: CAPMOD > 2 not allowed with Version = %f \n", version);
        end
        if (BSIM3nlx < -BSIM3leff) begin
	    $strobe("Fatal: Nlx = %g is less than -Leff.\n",BSIM3nlx);
	    Fatal_Flag = 1;
        end     

	if (BSIM3tox <= 0.0) begin
	    $strobe("Fatal: Tox = %g is not positive.\n", BSIM3tox);
	    Fatal_Flag = 1;
	end

        if (BSIM3toxm <= 0.0) begin
            $strobe("Fatal: Toxm = %g is not positive.\n", BSIM3toxm);
            Fatal_Flag = 1;
        end

        //if (BSIM3lintnoi > BSIM3leff/2) begin
        //    $strobe("Fatal: Lintnoi = %g is too large - Leff for noise is negative.\n", BSIM3lintnoi);
        //    Fatal_Flag = 1;
        //end

	if (BSIM3npeak <= 0.0) begin
	    $strobe("Fatal: Nch = %g is not positive.\n", BSIM3npeak);
	    Fatal_Flag = 1;
	end
	if (BSIM3nsub <= 0.0) begin
	    $strobe("Fatal: Nsub = %g is not positive.\n", BSIM3nsub);
	    Fatal_Flag = 1;
	end
	if (BSIM3ngate < 0.0) begin
	    $strobe("Fatal: Ngate = %g Ngate is not positive.\n", BSIM3ngate);
	    Fatal_Flag = 1;
	end
	if (BSIM3ngate > 1.0e25) begin
	    $strobe("Fatal: Ngate = %g Ngate is too high\n", BSIM3ngate);
	    Fatal_Flag = 1;
	end
	if (BSIM3xj <= 0.0) begin
	    $strobe("Fatal: Xj = %g is not positive.\n", BSIM3xj);
	    Fatal_Flag = 1;
	end

	if (BSIM3dvt1 < 0.0) begin
	    $strobe("Fatal: Dvt1 = %g is negative.\n", BSIM3dvt1);   
	    Fatal_Flag = 1;
	end
	    
	if (BSIM3dvt1w < 0.0) begin
	    $strobe("Fatal: Dvt1w = %g is negative.\n", BSIM3dvt1w);
	    Fatal_Flag = 1;
	end
	    
	if (BSIM3w0 == -BSIM3weff) begin
	    $strobe("Fatal: (W0 + Weff) = 0 causing divided-by-zero.\n");
	    Fatal_Flag = 1;
        end   

	if (BSIM3dsub < 0.0) begin
	    $strobe("Fatal: Dsub = %g is negative.\n", BSIM3dsub);
	    Fatal_Flag = 1;
	end
	if (BSIM3b1 == -BSIM3weff) begin
	    $strobe("Fatal: (B1 + Weff) = 0 causing divided-by-zero.\n");
	    Fatal_Flag = 1;
        end  
        if (BSIM3u0temp <= 0.0) begin
	    $strobe("Fatal: u0 at current temperature = %g is not positive.\n", BSIM3u0temp);
	    Fatal_Flag = 1;
        end
/* Check delta parameter */      
        if (BSIM3delta < 0.0)
	begin   
            $strobe("Fatal: Delta = %g is less than zero.\n", BSIM3delta);
	    Fatal_Flag = 1;
        end      

	if (BSIM3vsattemp <= 0.0)
	begin   
	    $strobe("Fatal: Vsat at current temperature = %g is not positive.\n", BSIM3vsattemp);
	    Fatal_Flag = 1;
	end

/* Check Rout parameters */
	if (BSIM3pclm <= 0.0)
	begin  
	    $strobe("Fatal: Pclm = %g is not positive.\n", BSIM3pclm);
	    Fatal_Flag = 1;
	end

	if (BSIM3drout < 0.0)
	begin   
	    $strobe("Fatal: Drout = %g is negative.\n", BSIM3drout);
	    Fatal_Flag = 1;
	end

        if (BSIM3pscbe2 <= 0.0)
        begin   
            $strobe("Warning: Pscbe2 = %g is not positive.\n", BSIM3pscbe2);
        end

      if (BSIM3unitLengthSidewallJctCap > 0.0 || BSIM3unitLengthGateSidewallJctCap > 0.0)
      begin
	if (BSIM3drainPerimeter < BSIM3weff)
            $strobe("\nWarning: Pd = %g is less than Weff=%g.",BSIM3drainPerimeter,BSIM3weff);
	if (BSIM3sourcePerimeter < BSIM3weff)
            $strobe("\nWarning: Ps = %g is less than Weff=%g.", BSIM3sourcePerimeter,BSIM3weff);
      end

        if (BSIM3noff < 0.1)
        begin   
            $strobe("Warning: Noff = %g is too small.\n", BSIM3noff);
        end
        if (BSIM3noff > 4.0)
        begin   
            $strobe("Warning: Noff = %g is too large.\n", BSIM3noff);
        end

        if (BSIM3voffcv < -0.5)
        begin   $strobe("Warning: Voffcv = %g is too small.\n",
                    BSIM3voffcv);
        end
        if (BSIM3voffcv > 0.5)
        begin   $strobe("Warning: Voffcv = %g is too large.\n",
                    BSIM3voffcv);
        end

        if (BSIM3ijth < 0.0)
        begin   $strobe("Fatal: Ijth = %g cannot be negative.\n",
                    BSIM3ijth);
            Fatal_Flag = 1;
        end

/* Check capacitance parameters */
        if (BSIM3clc < 0.0)
	begin   $strobe("Fatal: Clc = %g is negative.\n", BSIM3clc);
	    Fatal_Flag = 1;
        end      

        if (BSIM3moin < 5.0)
        begin   $strobe("Warning: Moin = %g is too small.\n",
                    BSIM3moin);
        end
        if (BSIM3moin > 25.0)
        begin   $strobe("Warning: Moin = %g is too large.\n",
                    BSIM3moin);
        end

	if(BSIM3capMod ==3) begin
          if(dtoxcv < 0.0)
            $strobe("Warning: dtoxcv = %g is negative! Physically, should set positive or zero.\n", dtoxcv);
          if(tox - dtoxcv <=0.0) begin
            $strobe("Fatal: Tox - dtoxcv = %g is not positive.\n", tox - dtoxcv);
            $strobe("W = %g, L = %g\n", w, l);
            Fatal_Flag = 1;
          end
          if (BSIM3acde < 0.4)
          begin   $strobe("Warning:  Acde = %g is too small.\n",
              	BSIM3acde);
          end
          if (BSIM3acde > 1.6)
          begin   $strobe("Warning:  Acde = %g is too large.\n",
              	BSIM3acde);
          end
	end

      if (paramchk ==1)
      begin
/* Check L and W parameters */ 
	if (BSIM3leff <= 5.0e-8)
	begin   $strobe("Warning: Leff = %g may be too small.\n",
	            BSIM3leff);
	end    
	
	if (BSIM3leffCV <= 5.0e-8)
	begin   $strobe("Warning: Leff for CV = %g may be too small.\n",
		    BSIM3leffCV);
	end  
	
        if (BSIM3weff <= 1.0e-7)
	begin   $strobe("Warning: Weff = %g may be too small.\n",
		    BSIM3weff);
	end             
	
	if (BSIM3weffCV <= 1.0e-7)
	begin   $strobe("Warning: Weff for CV = %g may be too small.\n",
		    BSIM3weffCV);
	end        
	
/* Check threshold voltage parameters */
	if (BSIM3nlx < 0.0)
	begin   $strobe("Warning: Nlx = %g is negative.\n", BSIM3nlx);
        end
	 if (BSIM3tox < 1.0e-9)
	begin   $strobe("Warning: Tox = %g is less than 10A.\n",
	            BSIM3tox);
        end

        if (BSIM3npeak <= 1.0e15)
	begin   $strobe("Warning: Nch = %g may be too small.\n",
	            BSIM3npeak);
	end
	else if (BSIM3npeak >= 1.0e21)
	begin   $strobe("Warning: Nch = %g may be too large.\n",
	            BSIM3npeak);
	end

	 if (BSIM3nsub <= 1.0e14)
	begin   $strobe("Warning: Nsub = %g may be too small.\n",
	            BSIM3nsub);
	end
	else if (BSIM3nsub >= 1.0e21)
	begin   $strobe("Warning: Nsub = %g may be too large.\n",
	            BSIM3nsub);
	end

	if ((BSIM3ngate > 0.0) && (BSIM3ngate <= 1.0e18))
	begin   $strobe("Warning: Ngate = %g is less than 1.E18cm^-3.\n",
	            BSIM3ngate);
	end
       
        if (BSIM3dvt0 < 0.0)
	begin   $strobe("Warning: Dvt0 = %g is negative.\n",
		    BSIM3dvt0);   
	end
	    
	if (abs(1.0e-6 / (BSIM3w0 + BSIM3weff)) > 10.0)
	begin   $strobe("Warning: (W0 + Weff) may be too small.\n");
        end

/* Check subthreshold parameters */
	if (BSIM3nfactor < 0.0)
	begin   $strobe("Warning: Nfactor = %g is negative.\n",
		    BSIM3nfactor);
	end
	if (BSIM3cdsc < 0.0)
	begin   $strobe("Warning: Cdsc = %g is negative.\n",
		    BSIM3cdsc);
	end
	if (BSIM3cdscd < 0.0)
	begin   $strobe("Warning: Cdscd = %g is negative.\n",
		    BSIM3cdscd);
	end
/* Check DIBL parameters */
	if (BSIM3eta0 < 0.0)
	begin   $strobe("Warning: Eta0 = %g is negative.\n",
		    BSIM3eta0); 
	end
	      
/* Check Abulk parameters */	    
	if (abs(1.0e-6 / (BSIM3b1 + BSIM3weff)) > 10.0)
       	begin   $strobe("Warning: (B1 + Weff) may be too small.\n");
        end    
    

/* Check Saturation parameters */
     	if (BSIM3a2 < 0.01)
	begin   $strobe("Warning: A2 = %g is too small. Set to 0.01.\n", BSIM3a2);
	    BSIM3a2 = 0.01;
	end
	else if (BSIM3a2 > 1.0)
	begin   
	    $strobe("Warning: A2 = %g is larger than 1. A2 is set to 1 and A1 is set to 0.\n", BSIM3a2);
	    BSIM3a2 = 1.0;
	    BSIM3a1 = 0.0;
	end

        if(version < 3.3) begin
	if (BSIM3rdsw < 0.0)
	begin   $strobe("Warning: Rdsw = %g is negative. Set to zero.\n",
		    BSIM3rdsw);
	    BSIM3rdsw = 0.0;
	    BSIM3rds0 = 0.0;
	end
        else if (BSIM3rds0 > 0.0 && BSIM3rds0<0.001)
        begin   $strobe("Warning: Rds at current temperature = %g  < 0.001 ohm. Set to zero.\n",
                    BSIM3rds0);
            BSIM3rds0 = 0.0;
        end
        end else begin
	if (BSIM3rdsw < 0.0)
	begin   $strobe("Warning: Rdsw = %g is negative. Set to zero.\n",
		    BSIM3rdsw);
	    BSIM3rdsw = 0.0;
	    BSIM3rds0 = 0.0;
	end
        if (BSIM3rds0 < 0.0 )
        begin   $strobe("Warning: Rds at current temperature = %g is negative. Set to zero.\n",
                    BSIM3rds0);
            BSIM3rds0 = 0.0;
        end        
        end

	 if (BSIM3vsattemp < 1.0e3)
	begin   $strobe("Warning: Vsat at current temperature = %g may be too small.\n", BSIM3vsattemp);
	end

	if (BSIM3pdibl1 < 0.0)
	begin   $strobe("Warning: Pdibl1 = %g is negative.\n",
		    BSIM3pdibl1);
	end
	if (BSIM3pdibl2 < 0.0)
	begin   $strobe("Warning: Pdibl2 = %g is negative.\n",
		    BSIM3pdibl2);
	end
/* Check overlap capacitance parameters */
        if (BSIM3cgdo < 0.0)
	begin   $strobe("Warning: cgdo = %g is negative. Set to zero.\n", BSIM3cgdo);
	    BSIM3cgdo = 0.0;
        end      
        if (BSIM3cgso < 0.0)
	begin   $strobe("Warning: cgso = %g is negative. Set to zero.\n", BSIM3cgso);
	    BSIM3cgso = 0.0;
        end      
        if (BSIM3cgbo < 0.0)
	begin   $strobe("Warning: cgbo = %g is negative. Set to zero.\n", BSIM3cgbo);
	    BSIM3cgbo = 0.0;
        end
        end

        //New model STI model
        if(BSIM3stiMod >= 1) begin
            if(saref == `NOT_GIVEN && sa0 == `NOT_GIVEN)
                BSIM3sa0 = 1.0e-6;
            else if (sa0 != `NOT_GIVEN && saref == `NOT_GIVEN)
                BSIM3sa0 = sa0;
            if(sbref == `NOT_GIVEN && sb0 == `NOT_GIVEN)
                BSIM3sb0 = 1.0e-6;
            else if (sb0 != `NOT_GIVEN && sbref == `NOT_GIVEN)
                BSIM3sb0 = sb0;

            if (BSIM3stiMod == 1) 
            begin
                if ((BSIM3sa > 0.0) && (BSIM3sb > 0.0))
                begin
                    if (BSIM3sa0 <= 0.0)
                    begin   $strobe("Fatal: SAref(SA0) = %g is not positive.\n",BSIM3sa0);
                        Fatal_Flag = 1;
                    end
                    if (BSIM3sb0 <= 0.0)
                    begin   $strobe("Fatal: SBref(SB0) = %g is not positive.\n",BSIM3sb0);
                        Fatal_Flag = 1;
                    end
                    if (BSIM3wlod < 0.0)
                    begin
                        begin  
                            $strobe("Warning: WLOD = %g is less than 0. Set to 0.0.\n",BSIM3wlod);
                        end
                        BSIM3wlod = 0.0;
                    end
                    if (BSIM3kvsat < -1.0)
                    begin
                        begin  
                            $strobe("Warning: KVSAT = %g is too small; Reset to -1.0.\n",BSIM3kvsat);
                        end
                        BSIM3kvsat = -1.0;
                    end
                    if (BSIM3kvsat > 1.0)
                    begin
                        begin
                            $strobe("Warning: KVSAT = %g is too big; Reset to 1.0.\n",BSIM3kvsat);
                        end
                        BSIM3kvsat = 1.0;
                    end
                    if (BSIM3lodk2 <= 0.0)
                    begin
                        begin
                            $strobe("Warning: LODK2 = %g is not positive.\n",BSIM3lodk2);
                        end
                    end
                    if (BSIM3lodeta0 <= 0.0)
                            $strobe("Warning: LODETA0 = %g is not positive.\n",BSIM3lodeta0);
                end
            end
      else if (BSIM3stiMod == 2)
      begin
        if (BSIM3sa1Given && BSIM3saGiven)
        begin   
            $strobe("Warning: SA = %g is overwritten by SA1 = %g.\n", BSIM3sa, BSIM3sa1);
        end
        if (BSIM3sb1Given && BSIM3sbGiven)
        begin
            $strobe("Warning: SB = %g is overwritten by SB1 = %g.\n", BSIM3sb, BSIM3sb1);
        end
        if ((!BSIM3sa1Given && BSIM3sb1Given) || (BSIM3sa1Given && !BSIM3sb1Given))
        begin   $strobe("Fatal: SA1 and SB1 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa2Given && BSIM3sb2Given) || (BSIM3sa2Given && !BSIM3sb2Given))
        begin   $strobe("Fatal: SA2 and SB2 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa3Given && BSIM3sb3Given) || (BSIM3sa3Given && !BSIM3sb3Given))
        begin   $strobe("Fatal: SA3 and SB3 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa4Given && BSIM3sb4Given) || (BSIM3sa4Given && !BSIM3sb4Given))
        begin   $strobe("Fatal: SA4 and SB4 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa5Given && BSIM3sb5Given) || (BSIM3sa5Given && !BSIM3sb5Given))
        begin   $strobe("Fatal: SA5 and SB5 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa6Given && BSIM3sb6Given) || (BSIM3sa6Given && !BSIM3sb6Given))
        begin   $strobe("Fatal: SA6 and SB6 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa7Given && BSIM3sb7Given) || (BSIM3sa7Given && !BSIM3sb7Given))
        begin   $strobe("Fatal: SA7 and SB7 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa8Given && BSIM3sb8Given) || (BSIM3sa8Given && !BSIM3sb8Given))
        begin   $strobe("Fatal: SA8 and SB8 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa9Given && BSIM3sb9Given) || (BSIM3sa9Given && !BSIM3sb9Given))
        begin   $strobe("Fatal: SA9 and SB9 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end
        if ((!BSIM3sa10Given && BSIM3sb10Given) || (BSIM3sa10Given && !BSIM3sb10Given))
        begin   $strobe("Fatal: SA10 and SB10 have to be given in a pair.\n");
            Fatal_Flag = 1;
        end

        if (BSIM3sa0 <= 0.0)
        begin   $strobe("Fatal: SA0 = %g is not positive.\n",BSIM3sa0);
            Fatal_Flag = 1;
        end
        if (BSIM3sb0 <= 0.0)
        begin   $strobe("Fatal: SB0 = %g is not positive.\n",BSIM3sb0);
            Fatal_Flag = 1;
        end
        if (BSIM3wlod < 0.0)
        begin   $strobe("Fatal: WLOD = %g is less than 0.\n",BSIM3wlod);
            Fatal_Flag = 1;
        end
        if (BSIM3kvsat < -1.0 || BSIM3kvsat > 1.0)
        begin   $strobe("Fatal: KVSAT = %g is out of range.\n",BSIM3kvsat);
            Fatal_Flag = 1;
        end
        if (BSIM3llodku0Given && BSIM3llodku0 <= 0.0)
        begin
            $strobe("Warning: LLODKU0 = %g is not positive.\n",BSIM3llodku0);
        end
        if (BSIM3wlodku0Given && BSIM3wlodku0 <= 0.0)
        begin
            begin
            $strobe("Warning: WLODKU0 = %g is not positive.\n",BSIM3wlodku0);
            end
        end
        if (BSIM3llodvthGiven && BSIM3llodvth <= 0.0)
        begin
            $strobe("Warning: LLODVTH = %g is not positive.\n",BSIM3llodvth);
        end
        if (BSIM3wlodvthGiven && BSIM3wlodvth <= 0.0)
        begin
            begin
            $strobe("Warning: WLODVTH = %g is not positive.\n",BSIM3wlodvth);
            end
        end

        if (BSIM3lodk2 <= 0.0)
        begin   $strobe("Fatal: LODK2 = %g is not positive.\n",BSIM3lodk2);
            Fatal_Flag = 1;
        end
        if (BSIM3lodeta0 <= 0.0)
        begin   $strobe("Fatal: LODETA0 = %g is not positive.\n",BSIM3lodeta0);
            Fatal_Flag = 1;
        end
        if (BSIM3saGiven && BSIM3sa <= 0)
        begin
            $strobe("Warning: SA = %g is not positive.\n",BSIM3sa);
        end
        
        if (BSIM3sa1Given && BSIM3sa1 <= 0)
        begin   $strobe("Fatal: SA1 = %g is not positive.\n",BSIM3sa1);
            Fatal_Flag = 1;
        end
        if (BSIM3sa2Given && BSIM3sa2 <= 0)
        begin   $strobe("Fatal: SA2 = %g is not positive.\n",BSIM3sa2);
            Fatal_Flag = 1;
        end
        if (BSIM3sa3Given && BSIM3sa3 <= 0)
        begin   $strobe("Fatal: SA3 = %g is not positive.\n",BSIM3sa3);
            Fatal_Flag = 1;
        end
        if (BSIM3sa4Given && BSIM3sa4 <= 0)
        begin   $strobe("Fatal: SA4 = %g is not positive.\n",BSIM3sa4);
            Fatal_Flag = 1;
        end
        if (BSIM3sa5Given && BSIM3sa5 <= 0)
        begin   $strobe("Fatal: SA5 = %g is not positive.\n",BSIM3sa5);
            Fatal_Flag = 1;
        end
        if (BSIM3sa6Given && BSIM3sa6 <= 0)
        begin   $strobe("Fatal: SA6 = %g is not positive.\n",BSIM3sa6);
            Fatal_Flag = 1;
        end
        if (BSIM3sa7Given && BSIM3sa7 <= 0)
        begin   $strobe("Fatal: SA7 = %g is not positive.\n",BSIM3sa7);
            Fatal_Flag = 1;
        end
        if (BSIM3sa8Given && BSIM3sa8 <= 0)
        begin   $strobe("Fatal: SA8 = %g is not positive.\n",BSIM3sa8);
            Fatal_Flag = 1;
        end
        if (BSIM3sa9Given && BSIM3sa9 <= 0)
        begin   $strobe("Fatal: SA9 = %g is not positive.\n",BSIM3sa9);
            Fatal_Flag = 1;
        end
        if (BSIM3sa10Given && BSIM3sa10 <= 0)
        begin   $strobe("Fatal: SA10 = %g is not positive.\n",BSIM3sa10);
            Fatal_Flag = 1;
        end

        if (BSIM3sbGiven && BSIM3sb <= 0)
        begin
            begin
            $strobe("Warning: SB = %g is not positive.\n",BSIM3sb);
            end
        end

        if (BSIM3sb1Given && BSIM3sb1 <= 0)
        begin   $strobe("Fatal: SB1 = %g is not positive.\n",BSIM3sb1);
            Fatal_Flag = 1; 
        end
        if (BSIM3sb2Given && BSIM3sb2 <= 0)
        begin   $strobe("Fatal: SB2 = %g is not positive.\n",BSIM3sb2);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb3Given && BSIM3sb3 <= 0)
        begin   $strobe("Fatal: SB3 = %g is not positive.\n",BSIM3sb3);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb4Given && BSIM3sb4 <= 0)
        begin   $strobe("Fatal: SB4 = %g is not positive.\n",BSIM3sb4);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb5Given && BSIM3sb5 <= 0)
        begin   $strobe("Fatal: SB5 = %g is not positive.\n",BSIM3sb5);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb6Given && BSIM3sb6 <= 0)
        begin   $strobe("Fatal: SB6 = %g is not positive.\n",BSIM3sb6);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb7Given && BSIM3sb7 <= 0)
        begin   $strobe("Fatal: SB7 = %g is not positive.\n",BSIM3sb7);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb8Given && BSIM3sb8 <= 0)
        begin   $strobe("Fatal: SB8 = %g is not positive.\n",BSIM3sb8);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb9Given && BSIM3sb9 <= 0)
        begin   $strobe("Fatal: SB9 = %g is not positive.\n",BSIM3sb9);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sb10Given && BSIM3sb10 <= 0)
        begin   $strobe("Fatal: SB10 = %g is not positive.\n",BSIM3sb10);
            Fatal_Flag = 1; 
        end         

        if (BSIM3sw1Given && BSIM3sw1 <= 0)
        begin   $strobe("Fatal: SW1 = %g is not positive.\n",BSIM3sw1);
            Fatal_Flag = 1; 
        end         
        if (BSIM3sw2Given && BSIM3sw2 <= 0)
        begin   $strobe("Fatal: SW2 = %g is not positive.\n",BSIM3sw2);
            Fatal_Flag = 1;
        end
        if (BSIM3sw3Given && BSIM3sw3 <= 0)
        begin   $strobe("Fatal: SW3 = %g is not positive.\n",BSIM3sw3);
            Fatal_Flag = 1;
        end
        if (BSIM3sw4Given && BSIM3sw4 <= 0)
        begin   $strobe("Fatal: SW4 = %g is not positive.\n",BSIM3sw4);
            Fatal_Flag = 1;
        end
        if (BSIM3sw5Given && BSIM3sw5 <= 0)
        begin   $strobe("Fatal: SW5 = %g is not positive.\n",BSIM3sw5);
            Fatal_Flag = 1;
        end
        if (BSIM3sw6Given && BSIM3sw6 <= 0)
        begin   $strobe("Fatal: SW6 = %g is not positive.\n",BSIM3sw6);
            Fatal_Flag = 1;
        end
        if (BSIM3sw7Given && BSIM3sw7 <= 0)
        begin   $strobe("Fatal: SW7 = %g is not positive.\n",BSIM3sw7);
            Fatal_Flag = 1;
        end
        if (BSIM3sw8Given && BSIM3sw8 <= 0)
        begin   $strobe("Fatal: SW8 = %g is not positive.\n",BSIM3sw8);
            Fatal_Flag = 1;
        end
        if (BSIM3sw9Given && BSIM3sw9 <= 0)
        begin   $strobe("Fatal: SW9 = %g is not positive.\n",BSIM3sw9);
            Fatal_Flag = 1;
        end
        if (BSIM3sw10Given && BSIM3sw10 <= 0)
        begin   $strobe("Fatal: SW10 = %g is not positive.\n",BSIM3sw10);
            Fatal_Flag = 1;
        end


        tmp= BSIM3sw1 + BSIM3sw2 + BSIM3sw3 + BSIM3sw4
                  + BSIM3sw5 + BSIM3sw6 + BSIM3sw7 + BSIM3sw8
                  + BSIM3sw9 + BSIM3sw10;
        tmp1=w;
        if ((abs(tmp - tmp1)/tmp1) > 0.01)
        begin
            $strobe("Warning: Sum of SW = %g is not equal to W = %g.\n",tmp, w);
        end

      end        
        end
        //New model gate current model
        if(version > 3.219) begin
            if (BSIM3igbMod) begin
              if (BSIM3nigbinv <= 0.0)
              begin   
                  $strobe("Fatal: nigbinv = %g is non-positive.\n", BSIM3nigbinv);
                  Fatal_Flag = 1;
              end
              if (BSIM3nigbacc <= 0.0)
              begin   
                  $strobe("Fatal: nigbacc = %g is non-positive.\n", BSIM3nigbacc);
                  Fatal_Flag = 1;
              end
            end
            if (BSIM3igcMod) begin
              if (BSIM3nigc <= 0.0)
              begin   
                  $strobe("Fatal: nigc = %g is non-positive.\n", BSIM3nigc);
                  Fatal_Flag = 1;
              end
              if (BSIM3poxedge <= 0.0)
              begin   
                  $strobe("Fatal: poxedge = %g is non-positive.\n", BSIM3poxedge);
                  Fatal_Flag = 1;
              end
              if (BSIM3pigcd <= 0.0)
              begin   
                  $strobe("Fatal: pigcd = %g is non-positive.\n", BSIM3pigcd);
                  Fatal_Flag = 1;
              end
            end	
	    
	   if (BSIM3toxe <= 0.0)
	   begin   
	      $strobe("Fatal: Toxe = %g(Tox=%g) is not positive.\n", BSIM3toxe,BSIM3tox);
	      Fatal_Flag = 1;
	   end 
	   if (BSIM3toxe < 1.0e-10)
	   begin   
	       $strobe("Warning: Toxe = %g is less than 1A. Recommended Toxe >= 5A\n", BSIM3toxe);
           end
	   if (BSIM3toxref <= 0.0)
	   begin   
	       $strobe("Fatal: Toxe = %g is not positive.\n", BSIM3toxref);
	       Fatal_Flag = 1;
           end	   	
        end

        BSIM3cgdo = (BSIM3cgdo + BSIM3cf) * BSIM3weffCV;
        BSIM3cgso = (BSIM3cgso + BSIM3cf) * BSIM3weffCV;
        BSIM3cgbo = BSIM3cgbo * BSIM3leffCV;
        if (!BSIM3npeakGiven && BSIM3gamma1Given) begin
            T0 = BSIM3gamma1 * BSIM3cox;
            BSIM3npeak = 3.021E22 * T0 * T0;
            $strobe("\nWARNING: npeak not given, gamma1 given: npeak=%g", 
                     BSIM3npeak);
        end 

        BSIM3phi = 2.0 * Vtm0 * ln(BSIM3npeak / ni);
        BSIM3sqrtPhi = `BSIM3_sqrt(BSIM3phi);
        BSIM3phis3 = BSIM3sqrtPhi * BSIM3phi;
        BSIM3Xdep0 = `BSIM3_sqrt(2.0 * `EPSSI / (`P_Q * BSIM3npeak * 1.0e6)) 
                      * BSIM3sqrtPhi;
        BSIM3litl = `BSIM3_sqrt(3.0 * BSIM3xj * BSIM3tox);
        BSIM3vbi = Vtm0 * ln(1.0e20 * BSIM3npeak / (ni * ni));
        BSIM3cdep0 = `BSIM3_sqrt(`P_Q * `EPSSI * BSIM3npeak * 1.0e6 / 2.0 / BSIM3phi);
        BSIM3ldeb = `BSIM3_sqrt(`EPSSI * Vtm0 / (`P_Q * BSIM3npeak * 1.0e6)) / 3.0;
        BSIM3acde = BSIM3acde * (  pow((BSIM3npeak / 2.0e16), -0.25));
        if (BSIM3k1Given || BSIM3k2Given) begin
            if (!BSIM3k1Given) begin
                $strobe( "\nWarning: k1 should be specified with k2.");
                BSIM3k1 = 0.53;
            end 
            if (!BSIM3k2Given) begin
                $strobe( "\nWarning: k2 should be specified with k1.");
                BSIM3k2 = -0.0186;
            end 
            if (BSIM3nsubGiven)
                $strobe("\nWarning: \
                           nsub is ignored because k1 or k2 is given.");
            if (BSIM3xtGiven)
                $strobe( "\nWarning: \
                           xt is ignored because k1 or k2 is given.");
            if (BSIM3vbxGiven)
                $strobe( "\nWarning: \
                           vbx is ignored because k1 or k2 is given.");
            if (BSIM3gamma1Given)
                $strobe( "\nWarning: \
                           gamma1 is ignored because k1 or k2 is given.");
            if (BSIM3gamma2Given)
                $strobe( "\nWarning: \
                           gamma2 is ignored because k1 or k2 is given.");
        end 
        else begin
            if (!BSIM3vbxGiven)
                BSIM3vbx = BSIM3phi - 7.7348e-4 * BSIM3npeak * BSIM3xt 
                            * BSIM3xt;
            if (BSIM3vbx > 0.0)
                BSIM3vbx = -BSIM3vbx;
            if (BSIM3vbm > 0.0)
                BSIM3vbm = -BSIM3vbm;
            if (!BSIM3gamma1Given)
                BSIM3gamma1 = 5.753e-12 * `BSIM3_sqrt(BSIM3npeak) / BSIM3cox;
            if (!BSIM3gamma2Given)
                BSIM3gamma2 = 5.753e-12 * `BSIM3_sqrt(BSIM3nsub) / BSIM3cox;
         
            T0 = BSIM3gamma1 - BSIM3gamma2;
            T1 = `BSIM3_sqrt(BSIM3phi - BSIM3vbx) - BSIM3sqrtPhi;
            T2 = `BSIM3_sqrt(BSIM3phi * (BSIM3phi - BSIM3vbm)) - BSIM3phi;
            BSIM3k2 = T0 * T1 / (2.0 * T2 + BSIM3vbm);
            BSIM3k1 = BSIM3gamma2 - 2.0 * BSIM3k2 * `BSIM3_sqrt(BSIM3phi - BSIM3vbm);
        end 

        BSIM3k1 = BSIM3k1 + delk1;
        BSIM3nfactor = BSIM3nfactor + delnfct;
        
        if (BSIM3k2 < 0.0) begin
            T0 = 0.5 * BSIM3k1 / BSIM3k2;
            BSIM3vbsc = 0.9 * (BSIM3phi - T0 * T0);
        if (BSIM3vbsc > -3.0)
            BSIM3vbsc = -3.0;
        else if (BSIM3vbsc < -30.0)
            BSIM3vbsc = -30.0;
        end 
        else
            BSIM3vbsc = -30.0;
        
        if (BSIM3vbsc > BSIM3vbm)
            BSIM3vbsc = BSIM3vbm;

        if (vfb == `NOT_GIVEN) begin
            if (BSIM3vth0Given)
                BSIM3vfb = BSIM3type * BSIM3vth0 - BSIM3phi - BSIM3k1 * BSIM3sqrtPhi;
            else
                BSIM3vfb = -1.0;
        end 
        BSIM3vfb = BSIM3vfb + delvto;


        if (!BSIM3vth0Given) begin
            BSIM3vth0 = BSIM3type * (BSIM3vfb + BSIM3phi + BSIM3k1 * BSIM3sqrtPhi);
            $strobe(" \nvth0 calculated: vth0=%g", BSIM3vth0);
        end else 
            BSIM3vth0 = BSIM3vth0 + delvto;


            
        BSIM3k1ox = BSIM3k1 * BSIM3tox / BSIM3toxm;
        BSIM3k2ox = BSIM3k2 * BSIM3tox / BSIM3toxm;
        if (vfbflag != 0.0)
            BSIM3vfbcv = BSIM3vfb;
        
        T1 = `BSIM3_sqrt(`EPSSI / `EPSOX * BSIM3tox * BSIM3Xdep0);
        T0 = exp(-0.5 * BSIM3dsub * BSIM3leff / T1);
        BSIM3theta0vb0 = (T0 + 2.0 * T0 * T0);
        T2 = -0.5 * BSIM3drout * BSIM3leff / T1;
	if(T2 > -`EXP_THRESHOLD2) 
	  T0 = exp(T2);
	else
	  T0 = `MIN_EXP2;

        //T0 = exp(-0.5 * BSIM3drout * BSIM3leff / T1);
        T2 = (T0 + 2.0 * T0 * T0);
        BSIM3thetaRout = BSIM3pdibl1 * T2 + BSIM3pdibl2;

        tmp = `BSIM3_sqrt(BSIM3Xdep0);
        tmp1 = BSIM3vbi - BSIM3phi;
        tmp2 = BSIM3factor1 * tmp;
        T0 = -0.5 * BSIM3dvt1w * BSIM3weff * BSIM3leff / tmp2;
        if (T0 > -`EXP_THRESHOLD) begin
          if(T0 >100)
            T1 = exp(100.0);
          else
            T1 = exp(T0);
          T2 = T1 * (1.0 + 2.0 * T1);
        end 
        else begin
            T1 = `MIN_EXP;
            T2 = T1 * (1.0 + 2.0 * T1);
        end 
        T0 = BSIM3dvt0w * T2;
        T2 = T0 * tmp1;
        T0 = -0.5 * BSIM3dvt1 * BSIM3leff / tmp2;
        if (T0 > -`EXP_THRESHOLD) begin
            T1 = exp(T0);
            T3 = T1 * (1.0 + 2.0 * T1);
        end 
        else begin
            T1 = `MIN_EXP;
            T3 = T1 * (1.0 + 2.0 * T1);
        end 
        
        T3 = BSIM3dvt0 * T3 * tmp1;
        if(BSIM3capMod == 3)
          T4 = (BSIM3tox -  dtoxcv)* BSIM3phi / (BSIM3weff + BSIM3w0);
        else
          T4 = BSIM3tox * BSIM3phi / (BSIM3weff + BSIM3w0);
        T0 = `BSIM3_sqrt(1.0 + BSIM3nlx / BSIM3leff);
        T5 = BSIM3k1ox * (T0 - 1.0) * BSIM3sqrtPhi + (BSIM3kt1 + BSIM3kt1l 
              / BSIM3leff)  * (TRatio - 1.0);
        tmp3 = BSIM3type * BSIM3vth0 - T2 - T3 + BSIM3k3 * T4 + T5;
        BSIM3vfbzb = tmp3 - BSIM3phi - BSIM3k1 * BSIM3sqrtPhi;
        /* End of vfbzb */

        //New model stimod
        if (BSIM3stiMod==1) begin
          T0 = pow(Lnew, BSIM3llodku0);
          W_tmp = Wnew + BSIM3wlod;
          T1 = pow(W_tmp, BSIM3wlodku0);
          tmp1 = BSIM3lku0 / T0 + BSIM3wku0 / T1
                 + BSIM3pku0 / (T0 * T1);
          T9 = 1.0 + tmp1;

          T0 = pow(Lnew, BSIM3llodvth);
          T1 = pow(W_tmp, BSIM3wlodvth);
          tmp1 = BSIM3lkvth0 / T0 + BSIM3wkvth0 / T1
               + BSIM3pkvth0 / (T0 * T1);
          here_BSIM3kvth0 = 1.0 + tmp1;
          here_BSIM3kvth0 = `BSIM3_sqrt(here_BSIM3kvth0*here_BSIM3kvth0 + `DELTA);

          T0 = (TRatio - 1.0);
          BSIM3ku0temp = T9 * (1.0 + BSIM3tku0 *T0) + `DELTA;

          Inv_saref = 1.0/(BSIM3sa0 + 0.5*Ldrn);
          Inv_sbref = 1.0/(BSIM3sb0 + 0.5*Ldrn);

          BSIM3inv_od_ref = Inv_saref + Inv_sbref;
          BSIM3rho_ref = BSIM3ku0 / BSIM3ku0temp * BSIM3inv_od_ref;
          if(verbose==1) begin
              $strobe("STI:Inv_saref,Inv_sbref,Ldrn,BSIM3inv_od_ref=%e,%e,%e,%e\n",Inv_saref,Inv_sbref,Ldrn,BSIM3inv_od_ref);
          end

          T0 = BSIM3leffCV * BSIM3leffCV;
          BSIM3tconst = BSIM3u0temp * BSIM3elm /(BSIM3cox
                              * BSIM3weffCV * BSIM3leffCV * T0);
        end
        else if(BSIM3stiMod == 2 ) begin
          /* New model: scalable TSMC STI model */
          T0 = pow(Lnew, BSIM3llodku0);
          W_tmp = Wnew + BSIM3wlod;
          T1 = pow(W_tmp, BSIM3wlodku0);
          tmp1 = BSIM3lku0 / T0 + BSIM3wku0 / T1
                 + BSIM3pku0 / (T0 * T1);
          T9 = 1.0 + tmp1;

          T0 = pow(Lnew, BSIM3llodvth);
          T1 = pow(W_tmp, BSIM3wlodvth);
          tmp1 = BSIM3lkvth0 / T0 + BSIM3wkvth0 / T1
               + BSIM3pkvth0 / (T0 * T1);
          here_BSIM3kvth0 = 1.0 + tmp1;
          here_BSIM3kvth0 = `BSIM3_sqrt(here_BSIM3kvth0 * here_BSIM3kvth0 + `DELTA);

          T0 = (TRatio - 1.0);
          BSIM3ku0temp = T9 * (1 + BSIM3tku0 *T0);
          BSIM3ku0temp =BSIM3ku0temp+ `DELTA;

          Inv_sa0 = 1/(BSIM3sa0 + 0.5*Ldrn);
          Inv_sb0 = 1/(BSIM3sb0 + 0.5*Ldrn);
          BSIM3inv_od_def = Inv_sa0 + Inv_sb0;
          BSIM3rho_def = BSIM3ku0/BSIM3ku0temp * BSIM3inv_od_def;

          T0 = BSIM3leffCV * BSIM3leffCV;
          BSIM3tconst = BSIM3u0temp * BSIM3elm /(BSIM3cox
                              * BSIM3weffCV * BSIM3leffCV * T0);
       end
       /* end of TSMC STI */        

        /* BSIM430 STI/LOD model ends*/
        //New model for TSMC STI model
              Inv_sa = 0;
              Inv_sb = 0;
              LOD_flag = 0;
              if (BSIM3stiMod == 2 )
              begin   if (BSIM3sa1 > 0.0 && BSIM3sb1 > 0.0)
                  begin   tmp = BSIM3sw1/w;
                      T0 = tmp/(BSIM3sa1 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb1 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa2 > 0.0 && BSIM3sb2 > 0.0)
                  begin   tmp = BSIM3sw2/w;
                      T0 = tmp/(BSIM3sa2 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb2 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa3 > 0.0 && BSIM3sb3 > 0.0)
                  begin   tmp = BSIM3sw3/w;
                      T0 = tmp/(BSIM3sa3 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb3 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa4 > 0.0 && BSIM3sb4 > 0.0)
                  begin   tmp = BSIM3sw4/w;
                      T0 = tmp/(BSIM3sa4 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb4 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa5 > 0.0 && BSIM3sb5 > 0.0)
                  begin   tmp = BSIM3sw5/w;
                      T0 = tmp/(BSIM3sa5 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb5 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                 if (BSIM3sa6 > 0.0 && BSIM3sb6 > 0.0)
                  begin   tmp = BSIM3sw6/w;
                      T0 = tmp/(BSIM3sa6 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb6 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa7 > 0.0 && BSIM3sb7 > 0.0)
                  begin   tmp = BSIM3sw7/w;
                      T0 = tmp/(BSIM3sa7 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb7 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa8 > 0.0 && BSIM3sb8 > 0.0)
                  begin   tmp = BSIM3sw8/w;
                      T0 = tmp/(BSIM3sa8 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb8 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa9 > 0.0 && BSIM3sb9 > 0.0)
                  begin   tmp = BSIM3sw9/w;
                      T0 = tmp/(BSIM3sa9 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb9 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
                  if (BSIM3sa10 > 0.0 && BSIM3sb10 > 0.0)
                  begin   tmp = BSIM3sw10/w;
                      T0 = tmp/(BSIM3sa10 + 0.5*Ldrn);
                      T1 = tmp/(BSIM3sb10 + 0.5*Ldrn);
                      Inv_sa =Inv_sa+ T0;
                      Inv_sb =Inv_sb+ T1;
                      LOD_flag = 1;
                  end
              end

              if (LOD_flag == 1)
              begin
                  Inv_ODeff = Inv_sa + Inv_sb;
                  rho = BSIM3ku0/BSIM3ku0temp * Inv_ODeff;
                  T0 = (1 + rho)/(1 + BSIM3rho_def);
                  BSIM3u0temp = BSIM3u0temp * T0;

                  T1 = (1 + BSIM3kvsat*rho)/(1 + BSIM3kvsat*BSIM3rho_def);
                  BSIM3vsattemp = BSIM3vsattemp * T1;

                  OD_offset = Inv_ODeff-BSIM3inv_od_def;
                  dvth0_lod = BSIM3kvth0/here_BSIM3kvth0 * OD_offset;
                  dk2_lod = BSIM3stk2/pow(here_BSIM3kvth0, BSIM3lodk2) *
                                     OD_offset;
                  deta0_lod = BSIM3steta0/pow(here_BSIM3kvth0, BSIM3lodeta0) *
                                     OD_offset;

                  BSIM3k2 = BSIM3k2 + dk2_lod;
                  if (!BSIM3k1Given && !BSIM3k2Given)
                  begin   dk1_lod = - 2.0 * dk2_lod * `BSIM3_sqrt(BSIM3phi - BSIM3vbm);
                      BSIM3k1 = BSIM3k1 + dk1_lod;
                  end
                  else
                  begin   
                      dk1_lod = 0.0;
                      BSIM3k1 = BSIM3k1;
                  end

                  if (version > 3.021)     /* for versions >=3.03 and higher */
                  begin
                      if (BSIM3k2 < 0.0) 
                      begin
                          T0 = 0.5 * BSIM3k1 / BSIM3k2;
                          BSIM3vbsc = 0.9 * (BSIM3phi - T0 * T0);
                          if (BSIM3vbsc > -3.0)
                              BSIM3vbsc = -3.0;
                          else if (BSIM3vbsc < -30.0)
                              BSIM3vbsc = -30.0;
                      end
                      else
                          BSIM3vbsc = -30.0;
                      if (BSIM3vbsc > BSIM3vbm)
                          BSIM3vbsc = BSIM3vbm;

                  end
                  else /* model versions < 3.03 */
                  begin
                      if (BSIM3k2 > 0.0) 
                      begin
                          T0 = 0.5 * BSIM3k1 / BSIM3k2;
                          BSIM3vbsc = 0.9 * (BSIM3phi - T0 * T0);
                          if (BSIM3vbsc > -3.0)
                              BSIM3vbsc = -3.0;
                          else if (BSIM3vbsc < -30.0)
                              BSIM3vbsc = -30.0;
                      end
                      else
                          if (version < 3.001)
                              BSIM3vbsc = -10.0;
                          else
                              BSIM3vbsc = -30.0;
                  end

                  BSIM3vth0 = BSIM3vth0 + dvth0_lod;
                  if (!BSIM3vth0Given)
                      BSIM3vth0 =BSIM3vth0+ BSIM3type * dk1_lod;
                  if (!BSIM3vfbGiven)
                  begin   if (BSIM3vth0Given)
                          BSIM3vfb = BSIM3vfb + BSIM3type * dvth0_lod - dk1_lod;
                  end

                  T3 = BSIM3leffCV * BSIM3leffCV;
                  BSIM3tconst = BSIM3u0temp * BSIM3elm /(BSIM3cox
                                      * BSIM3weffCV * BSIM3leffCV * T3);

                  BSIM3k1ox = BSIM3k1 * BSIM3tox
                                    / BSIM3toxm;
                  BSIM3k2ox = BSIM3k2 * BSIM3tox
                                    / BSIM3toxm;

                  T0 = `BSIM3_sqrt(1.0 + BSIM3nlx / BSIM3leff);
                  BSIM3vfbzb = BSIM3vfbzb +
                       (BSIM3k1ox - BSIM3k1ox) * (T0 - 1.0) * BSIM3sqrtPhi +
                       BSIM3type * (BSIM3vth0 - BSIM3vth0) -
                       dk1_lod * BSIM3sqrtPhi;

                  BSIM3eta0 = BSIM3eta0 + deta0_lod;
              end 
              /* end of TSMC STI */

            /* BSIM430 STI/LOD */
            if (BSIM3stiMod==1)
            begin
              if ((BSIM3sa > 0.0) && (BSIM3sb > 0.0))
              begin
                  /* for BSIM3v3, nf is always 1 */
                  Inv_sa = 1.0 / (BSIM3sa + 0.5*Ldrn);
                  Inv_sb = 1.0 / (BSIM3sb + 0.5*Ldrn);
                  Inv_ODeff = Inv_sa + Inv_sb;
                  rho = BSIM3ku0 / BSIM3ku0temp * Inv_ODeff;
                  T0 = (1.0 + rho)/(1.0 + BSIM3rho_ref);
                  BSIM3u0temp = BSIM3u0temp * T0;

                  T1 = (1.0 + BSIM3kvsat * rho)/(1.0 + BSIM3kvsat* BSIM3rho_ref);
                  BSIM3vsattemp = BSIM3vsattemp * T1;

                  OD_offset = Inv_ODeff - BSIM3inv_od_ref;
                  dvth0_lod = BSIM3kvth0 / here_BSIM3kvth0 * OD_offset ;
                  dk2_lod = BSIM3stk2 / pow(here_BSIM3kvth0, BSIM3lodk2) *
                                   OD_offset;
                  deta0_lod = BSIM3steta0 / pow(here_BSIM3kvth0, BSIM3lodeta0) *
                                     OD_offset;

                  BSIM3vth0 = BSIM3vth0 + dvth0_lod;

                  T3 = BSIM3leffCV * BSIM3leffCV;
                  BSIM3tconst = BSIM3u0temp * BSIM3elm /(BSIM3cox
                                      * BSIM3weffCV * BSIM3leffCV * T3);

                  if (!BSIM3vfbGiven && !BSIM3vth0Given)
                       BSIM3vfb = -1.0;
                  else
                       BSIM3vfb = BSIM3vfb + BSIM3type * dvth0_lod;
                  BSIM3vfbzb = BSIM3vfbzb + BSIM3type * dvth0_lod;

                  BSIM3k2 = BSIM3k2 + dk2_lod;
                  if (BSIM3k2 < 0.0)
                  begin   T0 = 0.5 * BSIM3k1 / BSIM3k2;
                      BSIM3vbsc = 0.9 * (BSIM3phi - T0 * T0);
                      if (BSIM3vbsc > -3.0)
                          BSIM3vbsc = -3.0;
                      else if (BSIM3vbsc < -30.0)
                          BSIM3vbsc = -30.0;
                  end
                  else
                      BSIM3vbsc = -30.0;
                  if (BSIM3vbsc > BSIM3vbm)
                      BSIM3vbsc = BSIM3vbm;
                  BSIM3k2ox = BSIM3k2 * BSIM3tox / BSIM3toxm;

                  BSIM3eta0 = BSIM3eta0 + deta0_lod;
              end 
            end
            /* end of BSIM430 STI/LOD model */

        if(BSIM3stiMod>0 && verbose == 1) begin
           $strobe("STI:dvth0_lod,dk2_lod,deta0_lod=%e,%e,%e\n", dvth0_lod,dk2_lod,deta0_lod);
           $strobe("STI:BSIM3u0temp,BSIM3vsattemp=%e,%e\n", BSIM3u0temp,BSIM3vsattemp);
           $strobe("STI:BSIM3kvth0,here_BSIM3kvth0,OD_offset=%e,%e\n",BSIM3kvth0,here_BSIM3kvth0,OD_offset);
        end

        // process source/drain series resistance. 
        BSIM3drainResistance = rdpr;
        BSIM3sourceResistance = rspr; 
        if (BSIM3drainResistance <= 0.0)
          BSIM3drainResistance = 0;
        if (BSIM3sourceResistance <= 0.0)
          BSIM3sourceResistance = 0;
        if(verbose == 1) begin
           $strobe("rdpr,rspr, rdc, rsc,rsh=%e,%e,%e,%e,%e\n", rdpr,rspr, rdc, rsc,rsh);
           $strobe("nrd,nrs=%e,%e\n", BSIM3drainSquares,BSIM3sourceSquares);
        end
        
        //if(BSIM3acm > 9) begin
        Nvtm = BSIM3vtm * BSIM3jctEmissionCoeff;

        if ((BSIM3sourceArea <= 0.0) && BSIM3sourcePerimeter <= 0.0)
            SourceSatCurrent = 1.0e-14;
        else
            SourceSatCurrent = BSIM3sourceArea * BSIM3jctTempSatCurDensity 
                                + BSIM3sourcePerimeter 
                                * BSIM3jctSidewallTempSatCurDensity;
        if ((SourceSatCurrent > 0.0) && (BSIM3ijth > 0.0)) 
            BSIM3vjsm = Nvtm * ln(BSIM3ijth / SourceSatCurrent + 1.0);
        else
            BSIM3vjsm = 0.0;

        BSIM3IsEvjsm = SourceSatCurrent * limexp(BSIM3vjsm / Nvtm);

        if ((BSIM3drainArea <= 0.0) && BSIM3drainPerimeter <= 0.0)
            DrainSatCurrent = 1.0e-14;
        else
            DrainSatCurrent = BSIM3drainArea * BSIM3jctTempSatCurDensity 
                               + BSIM3drainPerimeter 
                               * BSIM3jctSidewallTempSatCurDensity;
        if ((DrainSatCurrent > 0.0) && (BSIM3ijth > 0.0))
            BSIM3vjdm = Nvtm * ln(BSIM3ijth / DrainSatCurrent + 1.0);
        else
            BSIM3vjdm = 0.0;

        BSIM3IsEvjdm = DrainSatCurrent * limexp(BSIM3vjdm / Nvtm);


    //New model: bsim4 igcmod and igbmod as hspice compatiable 
        if(version >= 3.219999) begin
          BSIM3igcMod = igcmod;
          BSIM3igbMod = igbmod;
          BSIM3tempMod = tempmod;
	  if ((BSIM3igcMod != 0) && (BSIM3igcMod != 1) && (BSIM3igcMod != 2))	
	  begin
	    BSIM3igcMod = 0;
	    $strobe("Warning: igcMod has been set to its default value: 0.\n");
	  end 
	  if ((BSIM3igbMod != 0) && (BSIM3igbMod != 1))	
	  begin
	    BSIM3igbMod = 0;
	    $strobe("Warning: igbMod has been set to its default value: 0.\n");
	  end         

          if (BSIM3nigbinv <= 0.0)
             begin
            $strobe("Fatal: nigbinv = %g is non-positive.\n", BSIM3nigbinv);
            Fatal_Flag = 1;
             end 
          if (BSIM3nigbacc <= 0.0)
             begin
            $strobe("Fatal: nigbacc = %g is non-positive.\n", BSIM3nigbacc);
            Fatal_Flag = 1;
             end 
          if (BSIM3nigc <= 0.0)
             begin
            $strobe("Fatal: nigc = %g is non-positive.\n", BSIM3nigc);
            Fatal_Flag = 1;
             end 
          if (BSIM3poxedge <= 0.0)
             begin
            $strobe("Fatal: poxedge = %g is non-positive.\n", BSIM3poxedge);
            Fatal_Flag = 1;
             end 
          if (BSIM3pigcd <= 0.0)
             begin
            $strobe("Fatal: pigcd = %g is non-positive.\n", BSIM3pigcd);
            Fatal_Flag = 1;
             end 

         BSIM3vfbsdoff = BSIM3vfbsdoff 
	                   * (1.0 + BSIM3tvfbsdoff * delTemp);	
         if (BSIM3ngate > 0.0)
             BSIM3vfbsd = Vtm0 * ln(BSIM3ngate / BSIM3nsd);
         else
             BSIM3vfbsd = 0.0;
          BSIM3ToxRatio = exp(BSIM3ntox * ln(BSIM3toxref / BSIM3toxe)) / BSIM3toxe / BSIM3toxe;
          BSIM3ToxRatioEdge = exp(BSIM3ntox * ln(BSIM3toxref / (BSIM3toxe * BSIM3poxedge))) 
                                    / BSIM3toxe / BSIM3toxe 
                                    / BSIM3poxedge / BSIM3poxedge;		     
          BSIM3Aechvb = (BSIM3type == `NMOS) ? 4.97232e-7 : 3.42537e-7;
          BSIM3Bechvb = (BSIM3type == `NMOS) ? 7.45669e11 : 1.16645e12;
	  BSIM3AechvbEdge = BSIM3Aechvb * BSIM3weff * BSIM3dlcig * BSIM3ToxRatioEdge; 
          BSIM3BechvbEdge = -BSIM3Bechvb * BSIM3toxe * BSIM3poxedge;		       		   
          BSIM3Aechvb = BSIM3Aechvb * BSIM3weff * BSIM3leff * BSIM3ToxRatio;
          BSIM3Bechvb = -BSIM3Bechvb * BSIM3toxe;
          if(verbose == 1) begin
             $strobe("BSIM3Aechvb=%e,%e,%e,%e\n", BSIM3Aechvb,BSIM3ToxRatio,BSIM3toxref,BSIM3toxe);
             $strobe("BSIM3AechvbEdge=%e,%e,%e,%e\n", BSIM3AechvbEdge,BSIM3dlcig,BSIM3Lint,BSIM3ToxRatioEdge);
          end
	end


        // Model evaluation starts 
        vds = BSIM3type * V(di,si);
        vbs = BSIM3type * V(b, si);
        vgs = BSIM3type * V(g, si);

        if(verbose == 1) 
          $strobe("Input vds,vbs,vgs=%e,%e,%e\n", vds,vbs,vgs);
        /* determine DC current and derivatives */
        vbd = vbs - vds;
        vgd = vgs - vds;
        vgb = vgs - vbs;
        
        if (vds >= 0.0) begin
            /* normal mode */
            BSIM3mode = 1;
            Vds = vds;
            Vgs = vgs;
            Vbs = vbs;
        end 
        else begin
            /* inverse mode */
            BSIM3mode = -1;
            Vds = -vds;
            Vgs = vgd;
            Vbs = vbd;
        end 

        if(BSIM3acm < 9) begin
           //mos diode model with acm <9, print a warning
          $strobe("Warn: ACM(%d)<9 may not full compatible with hspice...\n", BSIM3acm);
        end
        /* Source/drain junction diode DC model begins */
        Nvtm = BSIM3vtm * BSIM3jctEmissionCoeff;
        if ((BSIM3sourceArea <= 0.0) && (BSIM3sourcePerimeter <= 0.0)) 
            SourceSatCurrent = 1.0e-14;
        else 
            SourceSatCurrent = BSIM3sourceArea 
                                * BSIM3jctTempSatCurDensity
                                + BSIM3sourcePerimeter
                                * BSIM3jctSidewallTempSatCurDensity;
        
        if (SourceSatCurrent <= 0.0) begin
            BSIM3cbs = _ckt_gmin * vbs;
        end 
        else begin   
            if (BSIM3ijth == 0.0) begin
                evbs = exp_lim(vbs / Nvtm);
                BSIM3cbs = SourceSatCurrent * (evbs - 1.0) + _ckt_gmin * vbs;
            end 
            else begin
              if(BSIM3breakmod == 0) begin //breakmod off
                if (vbs < BSIM3vjsm) begin
                    evbs = exp_lim(vbs / Nvtm);
                    BSIM3cbs = SourceSatCurrent * (evbs - 1.0) + _ckt_gmin * vbs;
                end 
                else if (version >= 3.21)
                begin
                    T0 = BSIM3IsEvjsm / Nvtm;
                    BSIM3cbs = BSIM3IsEvjsm - SourceSatCurrent
                                + T0 * (vbs - BSIM3vjsm)
                                + _ckt_gmin * vbs;
               end else begin
                    T0 = (BSIM3ijth+SourceSatCurrent)/Nvtm;
                    //BSIM3cbs = BSIM3ijth + T0*(vbs-BSIM3vjsm);
                    BSIM3cbs = BSIM3ijth + T0*(vbs-BSIM3vjsm)+_ckt_gmin * vbs;
               end
              end //breakmod off
              else begin //breakmod on       
		  if((vbs < BSIM3vjsmRev)) 
		    begin
		      evbs = vbs / Nvtm;
		      if(evbs < -`EXP_THRESHOLD)
                        begin
			  evbs = `MIN_EXP;
			  devbsdvbs = 0.0;
                        end else begin
			  evbs = exp(evbs);
			  devbsdvbs = evbs / Nvtm;
                        end
		      
		      T1 = evbs - 1.0;
		      T2 = BSIM3IVjsmRev + BSIM3SslpRev
			* (vbs - BSIM3vjsmRev);
		      BSIM3cbs = T1 * T2;

		    end
		  else if (vbs <= BSIM3vjsmFwd) begin
		      T0 = vbs / Nvtm;
		      if (T0 < -`EXP_THRESHOLD)
			begin
			  evbs = `MIN_EXP;
			  devbsdvbs = 0.0;
			end
		      else
			begin
			  evbs = exp(T0);
			  devbsdvbs = evbs / Nvtm;
		      end
		      
		      T1 = (BSIM3bvs + vbs) / Nvtm;
		      if (T1 > `EXP_THRESHOLD)
			begin
			  T2 = `MIN_EXP;
			  T3 = 0.0;
			end
		      else
			begin
			  T2 = exp(-T1);
			  T3 = -T2 /Nvtm;
			end
		      BSIM3cbs = SourceSatCurrent * (evbs + BSIM3XExpBVS - 1.0 - BSIM3xjbvs * T2);
		    end  
		  else
                      BSIM3cbs = BSIM3IVjsmFwd + BSIM3SslpFwd * (vbs - BSIM3vjsmFwd);
              end //breakmod on
            end 
        end 

        if ((BSIM3drainArea <= 0.0) && (BSIM3drainPerimeter <= 0.0))
             DrainSatCurrent = 1.0e-14;
        else
            DrainSatCurrent = BSIM3drainArea
                               * BSIM3jctTempSatCurDensity
                               + BSIM3drainPerimeter
                               * BSIM3jctSidewallTempSatCurDensity;
                               
        if (DrainSatCurrent <= 0.0) begin 
            BSIM3cbd = _ckt_gmin * vbd; 
        end 
        else begin
            if (BSIM3ijth == 0.0) begin
                evbd = exp_lim(vbd / Nvtm);
                BSIM3cbd = DrainSatCurrent * (evbd - 1.0) + _ckt_gmin * vbd;
            end 
            else begin
              if(BSIM3breakmod == 0) begin //breakmod off
                if (vbd < BSIM3vjdm) begin
                    evbd = exp_lim(vbd / Nvtm);
                    BSIM3cbd = DrainSatCurrent * (evbd - 1.0)
                                + _ckt_gmin * vbd;
               end 
               else if (version >= 3.21) begin
                   T0 = BSIM3IsEvjdm / Nvtm;
                   BSIM3cbd = BSIM3IsEvjdm - DrainSatCurrent
                               + T0 * (vbd - BSIM3vjdm)
                               + _ckt_gmin * vbd;
               end 
               else begin
                    T0 = (BSIM3ijth+DrainSatCurrent)/Nvtm;
                    BSIM3cbd = BSIM3ijth + T0*(vbd-BSIM3vjdm)+_ckt_gmin * vbd;
               end
             end //breakmod off
             else begin //breakmod on
		  if((vbd < BSIM3vjdmRev)) 
		    begin
		      evbd = vbd / Nvtm;
		      if(evbd < -`EXP_THRESHOLD)
                        begin
			  evbd = `MIN_EXP;
			  devbddvbd = 0.0;
                        end else begin
			  evbd = exp(evbd);
			  devbddvbd = evbd / Nvtm;
                        end

		      T1 = evbd - 1.0;
		      T2 = BSIM3IVjdmRev + BSIM3DslpRev * (vbd - BSIM3vjdmRev);
		      BSIM3cbd = T1 * T2;
		    end
		  else if (vbd <= BSIM3vjdmFwd) 
		    begin
		      T0 = vbd / Nvtm;
		      if (T0 < -`EXP_THRESHOLD)
			begin
			  evbd = `MIN_EXP;
			  devbddvbd = 0.0;
			end
		      else
			begin
			  evbd = exp(T0);
			  devbddvbd = evbd / Nvtm;
			end
		      
		      T1 = (BSIM3bvd + vbd) / Nvtm;
		      if (T1 > `EXP_THRESHOLD)
			begin
			  T2 = `MIN_EXP;
			  T3 = 0.0;
			end
		      else
			begin
			  T2 = exp(-T1);
			  T3 = -T2 /Nvtm;
			end
		      BSIM3cbd = DrainSatCurrent * (evbd + BSIM3XExpBVD - 1.0
				 - BSIM3xjbvd * T2);
		    end  
		  else
		    begin
                      BSIM3cbd = BSIM3IVjdmFwd + BSIM3DslpFwd * (vbd
				  - BSIM3vjdmFwd);
		    end 
             end
            end 
        end 
        /* End of diode DC model */
        
        T0 = Vbs - BSIM3vbsc - 0.001;
        T1 = `BSIM3_sqrt(T0 * T0 - 0.004 * BSIM3vbsc);
        Vbseff = BSIM3vbsc + 0.5 * (T0 + T1);
        
        if (Vbseff < Vbs)
            Vbseff = Vbs;
        
        if (Vbseff > 0.0) begin
            T0 = BSIM3phi / (BSIM3phi + Vbseff);
            Phis = BSIM3phi * T0;
            sqrtPhis = BSIM3phis3 / (BSIM3phi + 0.5 * Vbseff);
        end 
        else begin
            Phis = BSIM3phi - Vbseff;
            sqrtPhis = `BSIM3_sqrt(Phis);
        end 
       
        Xdep = BSIM3Xdep0 * sqrtPhis / BSIM3sqrtPhi;
        
        Leff = BSIM3leff;
        Vtm = BSIM3vtm;
        
        /* Vth Calculation */
        T3 = `BSIM3_sqrt(Xdep);
        V0 = BSIM3vbi - BSIM3phi;
        T0 = BSIM3dvt2 * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end 
        else begin
            /* Added to avoid any discontinuity problems caused by dvt2 */ 
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4; 
        end 

        lt1 = BSIM3factor1 * T3 * T1;
        T0 = BSIM3dvt2w * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
        end 
        else begin
            /* Added to avoid any discontinuity problems caused by dvt2w */ 
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4; 
        end 

        ltw = BSIM3factor1 * T3 * T1;
        T0 = -0.5 * BSIM3dvt1 * Leff / lt1;
        if (T0 > -`EXP_THRESHOLD) begin
            T1 = exp(T0);
            Theta0 = T1 * (1.0 + 2.0 * T1);
        end 
        else begin
            T1 = `MIN_EXP;
            Theta0 = T1 * (1.0 + 2.0 * T1);
        end 

        BSIM3thetavth = BSIM3dvt0 * Theta0;
        Delt_vth = BSIM3thetavth * V0;
        T0 = -0.5 * BSIM3dvt1w * BSIM3weff * Leff / ltw;
        if (T0 > -`EXP_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 * (1.0 + 2.0 * T1);
        end 
        else begin
            T1 = `MIN_EXP;
            T2 = T1 * (1.0 + 2.0 * T1);
        end 
        T0 = BSIM3dvt0w * T2;
        T2 = T0 * V0;
        TempRatio =  T / BSIM3tnom - 1.0;
        T0 = `BSIM3_sqrt(1.0 + BSIM3nlx / Leff);
        T1 = BSIM3k1ox * (T0 - 1.0) * BSIM3sqrtPhi
              + (BSIM3kt1 + BSIM3kt1l / Leff
              + BSIM3kt2 * Vbseff) * TempRatio;
        tmp2 = BSIM3tox * BSIM3phi
              / (BSIM3weff + BSIM3w0);
        T3 = BSIM3eta0 + BSIM3etab * Vbseff;

        if (T3 < 1.0e-4) begin
            /* avoid  discontinuity problems caused by etab */ 
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end 

        dDIBL_Sft_dVd = T3 * BSIM3theta0vb0;
        DIBL_Sft = dDIBL_Sft_dVd * Vds;
        Vth = BSIM3type * BSIM3vth0 - BSIM3k1
          * BSIM3sqrtPhi + BSIM3k1ox * sqrtPhis
          - BSIM3k2ox * Vbseff - Delt_vth - T2 + (BSIM3k3
          + BSIM3k3b * Vbseff) * tmp2 + T1 - DIBL_Sft;
        
        /* Calculate n */
     
        tmp2 = BSIM3nfactor * `EPSSI / Xdep;
        tmp3 = BSIM3cdsc + BSIM3cdscb * Vbseff
           + BSIM3cdscd * Vds;
        tmp4 = (tmp2 + tmp3 * Theta0 + BSIM3cit) / BSIM3cox;
        if (tmp4 >= -0.5)
            n = 1.0 + tmp4;
        else begin
            /* avoid  discontinuity problems caused by tmp4 */ 
            T0 = 1.0 / (3.0 + 8.0 * tmp4);
            n = (1.0 + 3.0 * tmp4) * T0;
        end 
        if (BSIM3vgslim > 0.0) begin
	  tmp = 0.0001; 
	  T8 = Vgs + tmp;
	  X1 = BSIM3vgslim + T8;
	  T1 = BSIM3vgslim - T8;
	  T2 = T1 * T1;
	  X2 = `BSIM3_sqrt(T2 + 4.0 * tmp * BSIM3vgslim);
	  T3 = 1.0 / (X1 + X2);
	  Vgs_x2 = 2.0 * Vgs;
	  vgsmax_t3 = BSIM3vgslim * T3;
	  Vgs_lim = Vgs_x2 * vgsmax_t3;

          vgslim_t3 = Vgs_lim * T3;
	  T6 = T1/X2;
	  T7 = 2.0 * vgsmax_t3;
	  Vgs = Vgs_lim;
        end

        /* Poly Gate Si Depletion Effect */
        T0 = BSIM3vfb + BSIM3phi;

        if ((BSIM3ngate > 1.0e18) && (BSIM3ngate < 1.0e25) && (Vgs > T0)) begin
            /* added to avoid the problem caused by ngate */
            T1 = 1.0e6 * `P_Q * `EPSSI * BSIM3ngate
                   / (BSIM3cox * BSIM3cox);
            T4 = `BSIM3_sqrt(1.0 + 2.0 * (Vgs - T0) / T1);
            T2 = T1 * (T4 - 1.0);
            T3 = 0.5 * T2 * T2 / T1; /* T3 = Vpoly */
            T7 = 1.12 - T3 - 0.05;
            T6 = `BSIM3_sqrt(T7 * T7 + 0.224);
            T5 = 1.12 - 0.5 * (T7 + T6);
            Vgs_eff = Vgs - T5;
        end 
        else
            Vgs_eff = Vgs;

        Vgst = Vgs_eff - Vth;
        if ((BSIM3ngate > 1.0e18) && (BSIM3ngate < 1.0e25) && (vgd > T0)) 
          begin
              T1 = 1.0e6 * `P_Q * `EPSSI * BSIM3ngate
                 / (BSIM3cox * BSIM3cox);   
              T4 = `BSIM3_sqrt(1.0 + 2.0 * (vgd - T0) / T1);
              T2 = T1 * (T4 - 1.0);

              T3 = 0.5 * T2 * T2 / T1; 
              T7 = 1.07 - T3 ;      

              T6 = `BSIM3_sqrt(T7 * T7 + 0.224);                    
              T5 = 1.12 - 0.5 * (T7 + T6);            
              vgd_eff = vgd - T5;          

          end
          else /* don't calculate poly depletion effect */
	     vgd_eff = vgd;

        /* Effective Vgst (Vgsteff) Calculation */
        T10 = 2.0 * n * Vtm;
        VgstNVt = Vgst / T10;
        ExpArg = (2.0 * BSIM3voff - Vgst) / T10;
        
        /* MCJ: Very small Vgst */
        //T0 = limexp((Vgst - BSIM3voff) / (n * Vtm)); 
        //T2 = limexp(VgstNVt);
        //T3 = limexp(ExpArg);
        if (VgstNVt > `EXP_THRESHOLD)
            Vgsteff = Vgst;
        else if (ExpArg > `EXP_THRESHOLD) begin
            T0 = (Vgst - BSIM3voff) / (n * Vtm);
            ExpVgst = exp(T0);
            Vgsteff = Vtm * BSIM3cdep0 / BSIM3cox * ExpVgst;
        end 
        else begin
            ExpVgst = exp(VgstNVt);
            T1 = T10 * ln(1.0 + ExpVgst);
            dT2_dVg = -BSIM3cox / (Vtm * BSIM3cdep0) * exp(ExpArg);
            T2 = 1.0 - T10 * dT2_dVg;
            Vgsteff = T1 / T2;
        end 
              
        /* Calculate Effective Channel Geometry */
        T9 = sqrtPhis - BSIM3sqrtPhi;
        Weff = BSIM3weff - 2.0 * (BSIM3dwg * Vgsteff + BSIM3dwb * T9); 
        if (Weff < 2.0e-8) begin
            /* to avoid the discontinuity problem due to Weff*/
            T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
            Weff = 2.0e-8 * (4.0e-8 - Weff) * T0;
        end 
        
        T0 = BSIM3prwg * Vgsteff + BSIM3prwb * T9;
        if (T0 >= -0.9)
            Rds = BSIM3rds0 * (1.0 + T0);
        else begin
            /* to avoid the discontinuity problem due to prwg and prwb*/
            T1 = 1.0 / (17.0 + 20.0 * T0);
            Rds = BSIM3rds0 * (0.8 + T0) * T1;
        end 
        
        /* Calculate Abulk */
        T1 = 0.5 * BSIM3k1ox / sqrtPhis;
        T9 = `BSIM3_sqrt(BSIM3xj * Xdep);
        tmp1 = Leff + 2.0 * T9;
        T5 = Leff / tmp1; 
        tmp2 = BSIM3a0 * T5;
        tmp3 = BSIM3weff + BSIM3b1; 
        tmp4 = BSIM3b0 / tmp3;
        T2 = tmp2 + tmp4;
        T6 = T5 * T5;
        T7 = T5 * T6;
        Abulk0 = 1.0 + T1 * T2; 
        T8 = BSIM3ags * BSIM3a0 * T7;
        dAbulk_dVg = -T1 * T8;
        Abulk = Abulk0 + dAbulk_dVg * Vgsteff; 

        if (Abulk0 < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk0);
            Abulk0 = (0.2 - Abulk0) * T9;
        end 
        if (Abulk < 0.1) begin
            /* added to avoid the problems caused by Abulk */
            T9 = 1.0 / (3.0 - 20.0 * Abulk);
            Abulk = (0.2 - Abulk) * T9;
        end 
  
        T2 = BSIM3keta * Vbseff;
        if (T2 >= -0.9) 
            T0 = 1.0 / (1.0 + T2);
        else begin
            /* added to avoid the problems caused by Keta */
            T1 = 1.0 / (0.8 + T2);
            T0 = (17.0 + 20.0 * T2) * T1;
        end 

        Abulk = Abulk * T0;
        Abulk0 = Abulk0 * T0;

`ifdef NOISE
        /* The following derivatives are not calculated!
         * (2nd order effects, will be replaced by ddx() operator
         * in future Verilog-A extension.   */
        doNoise = analysis("noise");
        if (doNoise) begin
            dAbulk_dVb = 0.0;
            dEsatL_dVb = 0.0;
            dEsatL_dVd = 0.0;
            dEsatL_dVg = 0.0;
            dRds_dVb = 0.0;
            dRds_dVg = 0.0;
            dVa_dVb = 0.0;
            dVa_dVd = 0.0;
            dVa_dVg = 0.0;
            dVbseff_dVb = 0.0;
            dVdseff_dVb = 0.0;
            dVdseff_dVd = 0.0;
            dVdseff_dVg = 0.0;
            dVgsteff_dVb = 0.0;
            dVgsteff_dVd = 0.0;
            dVgsteff_dVg = 0.0;
            dWeff_dVb = 0.0;
            dWeff_dVg = 0.0;
            dueff_dVb = 0.0;
            dueff_dVd = 0.0;
            dueff_dVg = 0.0;
        end
`endif
        
        /* Mobility calculation */
        if (BSIM3mobMod == 1) begin
            T0 = Vgsteff + Vth + Vth;
            T2 = BSIM3ua + BSIM3uc * Vbseff;
            T3 = T0 / BSIM3tox;
            T5 = T3 * (T2 + BSIM3ub * T3);
        end 
        else if (BSIM3mobMod == 2)
            T5 = Vgsteff / BSIM3tox * (BSIM3ua + BSIM3uc * Vbseff 
                  + BSIM3ub * Vgsteff / BSIM3tox);
        else begin
            T0 = Vgsteff + Vth + Vth;
            T2 = 1.0 + BSIM3uc * Vbseff;
            T3 = T0 / BSIM3tox;
            T4 = T3 * (BSIM3ua + BSIM3ub * T3);
            T5 = T4 * T2;
        end 
        if (T5 >= -0.8)
            Denomi = 1.0 + T5;
        else begin
            /* Added to avoid the discontinuity problem caused by ua and ub*/ 
            T9 = 1.0 / (7.0 + 10.0 * T5);
            Denomi = (0.6 + T5) * T9;
        end 

        ueff  =  BSIM3u0temp / Denomi;
        
        /* Saturation Drain Voltage  Vdsat */
        WVCox = Weff * BSIM3vsattemp * BSIM3cox;
        WVCoxRds = WVCox * Rds; 
        Esat = 2.0 * BSIM3vsattemp / ueff;
        EsatL = Esat * Leff;
        /* Sqrt() */
        if (BSIM3a1 == 0.0)
            Lambda = BSIM3a2;
        else if (BSIM3a1 > 0.0) begin
            /* Added to avoid the discontinuity problem
             * caused by local_a1 and a2 (Lambda) */
            T0 = 1.0 - BSIM3a2;
            T1 = T0 - BSIM3a1 * Vgsteff - 0.0001;
            T2 = `BSIM3_sqrt(T1 * T1 + 0.0004 * T0);
            Lambda = BSIM3a2 + T0 - 0.5 * (T1 + T2);
        end 
        else begin
            T1 = BSIM3a2 + BSIM3a1 * Vgsteff - 0.0001;
            T2 = `BSIM3_sqrt(T1 * T1 + 0.0004 * BSIM3a2);
            Lambda = 0.5 * (T1 + T2);
        end 

        Vgst2Vtm = Vgsteff + 2.0 * Vtm;

        if ((Rds == 0.0) && (Lambda == 1.0)) begin
            T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
            T3 = EsatL * Vgst2Vtm;
            Vdsat = T3 * T0;
        end 
        else begin
            T9 = Abulk * WVCoxRds;
            T7 = Vgst2Vtm * T9;
            T6 = Vgst2Vtm * WVCoxRds;
            T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda); 
            T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
            T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
            T3 = `BSIM3_sqrt(T1 * T1 - 2.0 * T0 * T2);
            Vdsat = (T1 - T3) / T0;
        end
        
       
        /* Effective Vds (Vdseff) Calculation */
        if(version == 53) begin
          T1 = Vdsat - Vds - BSIM3delta;
          T2 = `BSIM3_sqrt(T1 * T1 + 4.0 * BSIM3delta * Vdsat);
          Vdseff = Vdsat - 0.5 * (T1 + T2);
        end
        else begin
	  X1 = Vdsat + Vds + BSIM3delta;
	  T1 = Vdsat - Vds - BSIM3delta;
	  T2 = T1 * T1;
	  X2 = `BSIM3_sqrt(T2 + 4.0 * BSIM3delta * Vdsat);
	  T3 = 1.0 / (X1 + X2);
	  T4 = 2.0 * Vds;
	  T5 = T4 * T3;
	  Vdseff = T5 * Vdsat;
        end
       
        /* Added to eliminate non-zero Vdseff at Vds=0.0 */
        if (Vds == 0.0)
            Vdseff = 0.0;
      
        /* Calculate VAsat */
        tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
        T9 = WVCoxRds * Vgsteff;
        T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
        T9 = WVCoxRds * Abulk; 
        T1 = 2.0 / Lambda - 1.0 + T9; 
        Vasat = T0 / T1;
        if (Vdseff > Vds)
            Vdseff = Vds;

  
        diffVds = Vds - Vdseff;
        /* Calculate VACLM */
        if ((BSIM3pclm > 0.0) && (diffVds > 1.0e-10)) begin
            T0 = 1.0 / (BSIM3pclm * Abulk * BSIM3litl);
            T2 = Vgsteff / EsatL;
            T1 = Leff * (Abulk + T2); 
            T9 = T0 * T1;
            VACLM = T9 * diffVds;
        end 
        else
            VACLM = `MAX_EXP;

  
        /* Calculate VADIBL */
        if (BSIM3thetaRout > 0.0) begin
            T8 = Abulk * Vdsat;
            T0 = Vgst2Vtm * T8;
            T1 = Vgst2Vtm + T8;

            T2 = BSIM3thetaRout;

            VADIBL = (Vgst2Vtm - T0 / T1) / T2;
            T7 = BSIM3pdiblb * Vbseff;

            if (T7 >= -0.9) begin
                T3 = 1.0 / (1.0 + T7);
                VADIBL = VADIBL * T3;
            end 
            else begin
                /* Added to avoid the discontinuity problem caused by pdiblcb */
                T4 = 1.0 / (0.8 + T7);
                T3 = (17.0 + 20.0 * T7) * T4;
                VADIBL = VADIBL * T3;
            end 
        end 
        else
            VADIBL = `MAX_EXP;
  
        /* Calculate VA */
        T8 = BSIM3pvag / EsatL;
        T9 = T8 * Vgsteff;
        if (T9 > -0.9)
            T0 = 1.0 + T9;
        else begin
            /* Added to avoid the discontinuity problems caused by pvag */
            T1 = 1.0 / (17.0 + 20.0 * T9);
            T0 = (0.8 + T9) * T1;
        end 
        tmp3 = VACLM + VADIBL;
        T1 = VACLM * VADIBL / tmp3;
        Va = Vasat + T0 * T1;
  
        /* Calculate VASCBE */
        if (BSIM3pscbe2 > 0.0 && BSIM3pscbe1>=0.0) begin
            if (diffVds > BSIM3pscbe1 * BSIM3litl / `EXP_THRESHOLD) begin
                T0 =  BSIM3pscbe1 * BSIM3litl / diffVds;
                VASCBE = Leff * exp(T0) / BSIM3pscbe2;
                T1 = T0 * VASCBE / diffVds;
`ifdef NOISE  
                if (doNoise) begin
                    dVASCBE_dVg = T1 * dVdseff_dVg;
                    dVASCBE_dVd = -T1 * (1.0 - dVdseff_dVd);
                    dVASCBE_dVb = T1 * dVdseff_dVb;
                end
`endif
            end 
            else begin
                VASCBE = `MAX_EXP * Leff/BSIM3pscbe2;
`ifdef NOISE  
                if (doNoise) begin
                    dVASCBE_dVg = 0.0;                      
                    dVASCBE_dVd = 0.0;                      
                    dVASCBE_dVb = 0.0;                      
                end
`endif
            end 
        end 
        else begin
            VASCBE = `MAX_EXP;
`ifdef NOISE  
            if (doNoise) begin
                dVASCBE_dVg = 0.0;                      
                dVASCBE_dVd = 0.0;                      
                dVASCBE_dVb = 0.0;                      
            end
`endif
        end 
   
       
        /* Calculate Ids */
        Gm = 0.0;   // Even though not used, set to 0 to prevent
        Gds = 0.0;  // memory state.
        Gmb = 0.0;
        CoxWovL = BSIM3cox * Weff / Leff;
        beta = ueff * CoxWovL;
        T0 = 1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm;
        fgche1 = Vgsteff * T0;
        T9 = Vdseff / EsatL;
        fgche2 = 1.0 + T9;
        gche = beta * fgche1 / fgche2;
        T0 = 1.0 + gche * Rds;
        T9 = Vdseff / T0;
        Idl = gche * T9;
        T9 =  diffVds / Va;
        T0 =  1.0 + T9;
        Idsa = Idl * T0;
        T9 = diffVds / VASCBE;
        T0 = 1.0 + T9;
        Ids = Idsa * T0;    

`ifdef NOISE  
        if (doNoise) begin
            if (BSIM3noiMod == 1 || BSIM3noiMod == 3) begin
                /* These noise modes need certain derivatives for 
                 * Gm, Gds, Gmb  */
                dbeta_dVg = CoxWovL * dueff_dVg + beta * dWeff_dVg / Weff;
                dbeta_dVd = CoxWovL * dueff_dVd;
                dbeta_dVb = CoxWovL * dueff_dVb + beta * dWeff_dVb / Weff;

                T0 = 1.0 - 0.5 * Abulk * Vdseff / Vgst2Vtm;
                dT0_dVg = -0.5 * (Abulk * dVdseff_dVg - Abulk * Vdseff 
                / Vgst2Vtm + Vdseff * dAbulk_dVg) / Vgst2Vtm;
                dT0_dVd = -0.5 * Abulk * dVdseff_dVd / Vgst2Vtm;
                dT0_dVb = -0.5 * (Abulk * dVdseff_dVb + dAbulk_dVb * Vdseff)
                / Vgst2Vtm;

                dfgche1_dVg = Vgsteff * dT0_dVg + T0; 
                dfgche1_dVd = Vgsteff * dT0_dVd; 
                dfgche1_dVb = Vgsteff * dT0_dVb;

                T9 = Vdseff / EsatL;
                dfgche2_dVg = (dVdseff_dVg - T9 * dEsatL_dVg) / EsatL;
                dfgche2_dVd = (dVdseff_dVd - T9 * dEsatL_dVd) / EsatL;
                dfgche2_dVb = (dVdseff_dVb - T9 * dEsatL_dVb) / EsatL;

                dgche_dVg = (beta * dfgche1_dVg + fgche1 * dbeta_dVg -
                    gche * dfgche2_dVg) / fgche2;
                dgche_dVd = (beta * dfgche1_dVd + fgche1 * dbeta_dVd -
                    gche * dfgche2_dVd) / fgche2;
                dgche_dVb = (beta * dfgche1_dVb + fgche1 * dbeta_dVb -
                    gche * dfgche2_dVb) / fgche2;
  
                T0 = 1.0 + gche * Rds;
                T9 = Vdseff / T0;

                dIdl_dVg = (gche * dVdseff_dVg + T9 * dgche_dVg) / T0 -
                    Idl * gche / T0 * dRds_dVg ;

                dIdl_dVd = (gche * dVdseff_dVd + T9 * dgche_dVd) / T0; 
                dIdl_dVb = (gche * dVdseff_dVb + T9 * dgche_dVb - 
                    Idl * dRds_dVb * gche) / T0;

                T9 =  diffVds / Va;
                T0 =  1.0 + T9;
                dIdsa_dVg = T0 * dIdl_dVg - Idl * (dVdseff_dVg + T9 * dVa_dVg) / Va;
                dIdsa_dVd = T0 * dIdl_dVd + Idl * (1.0 - dVdseff_dVd -
                    T9 * dVa_dVd) / Va;
                dIdsa_dVb = T0 * dIdl_dVb - Idl * (dVdseff_dVb + T9 * dVa_dVb) / Va;

                T9 = diffVds / VASCBE;
                T0 = 1.0 + T9;

                Gm = T0 * dIdsa_dVg - Idsa * 
                    (dVdseff_dVg + T9 * dVASCBE_dVg) / VASCBE;
                Gds = T0 * dIdsa_dVd + Idsa * (1.0 - dVdseff_dVd -
                    T9 * dVASCBE_dVd) / VASCBE;
                Gmb = T0 * dIdsa_dVb - Idsa * (dVdseff_dVb +
                    T9 * dVASCBE_dVb) / VASCBE;

                Gds = Gds + Gm * dVgsteff_dVd;
                Gmb = Gmb + Gm * dVgsteff_dVb;
                Gm = Gm * dVgsteff_dVg;
                Gmb = Gmb * dVbseff_dVb;
            end
        end
`endif  
        /* Substrate current begins */
        tmp = BSIM3alpha0 + BSIM3alpha1 * Leff;
        if ((tmp <= 0.0) || (BSIM3beta0 <= 0.0)) begin
            Isub  =  0.0;
        end 
        else begin
            T2 = tmp / Leff;
            if (diffVds > BSIM3beta0 / `EXP_THRESHOLD) begin
                T0 = -BSIM3beta0 / diffVds;
                T1 = T2 * diffVds * exp(T0);
            end 
            else begin
                T3 = T2 * `MIN_EXP;
                T1 = T3 * diffVds;
            end 
            Isub = T1 * Idsa;
        end 


    //New model: bsim4 igcmod and igbmod as hspice compatiable
	 /* GIDL/GISL Models */
        if (gidlmod==0) begin
          T0 = 3.0 * BSIM3toxe;
          T1 = (vds - vgs_eff - BSIM3egidl ) / T0;

        if ((BSIM3agidl <= 0.0) || (BSIM3bgidl <= 0.0)
            || (T1 <= 0.0) || (BSIM3cgidl <= 0.0) || (vbd > 0.0))
            Igidl = 0.0;
        else begin
            T2 = BSIM3bgidl / T1;
            if (T2 < 100.0) begin
                Igidl = BSIM3agidl * BSIM3weffCV * T1 * exp(-T2); //TODO check BSIM3weffCJ->BSIM3weffCV
                T3 = Igidl * (1.0 + T2) / T1;
            end 
            else begin
                Igidl = BSIM3agidl * BSIM3weffCV * 3.720075976e-44;//TODO check BSIM3weffCJ->BSIM3weffCV
                Igidl = Igidl * T1;
            end

            T4 = vbd * vbd;
            T5 = -vbd * T4;
            T6 = BSIM3cgidl + T5;
            T7 = T5 / T6;
            //T8 = 3.0 * BSIM3cgidl * T4 / T6 / T6;
            Igidl = Igidl * T7;
        end 

        /* Calculate GISL current: bugfix recommended by TI  -JX */
        T1 = (-vds - vgd_eff - BSIM3egisl ) / T0;
          
        if ((BSIM3agisl <= 0.0) || (BSIM3bgisl <= 0.0)
            || (T1 <= 0.0) || (BSIM3cgisl <= 0.0) || (vbs > 0.0))
            Igisl = 0.0;
        else begin      
            T2 = BSIM3bgisl / T1;
            if (T2 < 100.0) begin
                Igisl = BSIM3agisl * BSIM3weffCV * T1 * exp(-T2);//TODO check BSIM3weffCJ->BSIM3weffCV
                //T3 = Igisl * (1.0 + T2) / T1;
            end 
            else begin
                Igisl = BSIM3agisl * BSIM3weffCV * 3.720075976e-44;//TODO check BSIM3weffCJ->BSIM3weffCV
                Igisl = Igisl * T1;
            end         
            T4 = vbs * vbs;
            T5 = -vbs * T4;
            T6 = BSIM3cgisl + T5;
            T7 = T5 / T6;
            Igisl = Igisl * T7;
        end 
       end
       else begin //gidlmod>0 
  /* bsimv4.7 New Gidl/GISL model (may not enabled by bsim3 in hspice)*/
	            /* GISL */
                    T1 = (-vds - BSIM3rgisl * vgd_eff - BSIM3egisl) / T0;     
                    
		    if ((BSIM3agisl <= 0.0) ||
                            (BSIM3bgisl <= 0.0) || (T1 <= 0.0) ||
                            (BSIM3cgisl < 0.0)  )
                        Igisl = 0.0; 
                    else
                    begin
                        T2 = BSIM3bgisl / T1;
                        if (T2 < `EXPL_THRESHOLD)
                          Igisl = BSIM3weffCV * BSIM3agisl * T1 * exp(-T2);//TODO check BSIM3weffCJ->BSIM3weffCV
                        else
                        begin
                            T3 = BSIM3weffCV * BSIM3agisl * `MIN_EXPL;//TODO check BSIM3weffCJ->BSIM3weffCV
                            Igisl = T3 * T1 ;
                        
                        end
                        T4 = vbs - BSIM3fgisl;
                        
			if (T4==0)
                            T5 = BSIM3kgisl / T4;
                        if (T5<`EXPL_THRESHOLD)
                            T6 = exp(T5);
                        else
                          T6 = `MAX_EXPL;
                        Igisl=Igisl*T6;

                    end
                    /* End of GISL */
		    
	            /* GIDL */
                    T1 = (vds - BSIM3rgidl * vgs_eff - BSIM3egidl) /  T0;                                           
                    if ((BSIM3agidl <= 0.0) ||
                            (BSIM3bgidl <= 0.0) || (T1 <= 0.0) ||
                            (BSIM3cgidl < 0.0)  )
                        Igidl = 0.0; 
                    else
                    begin
                        T2 = BSIM3bgidl / T1;
                        if (T2 < `EXPL_THRESHOLD)
                        begin
                            Igidl = BSIM3weffCV * BSIM3agidl * T1 * exp(-T2);//TODO check BSIM3weffCJ->BSIM3weffCV
                        end else
                        begin
                            T3 = BSIM3weffCV * BSIM3agidl * `MIN_EXPL;//TODO check BSIM3weffCJ->BSIM3weffCV
                            Igidl = T3 * T1 ;
                        end
                        T4 = vbd - BSIM3fgidl;
                        if (T4==0)
                            T5 = `EXPL_THRESHOLD;
                        else
                            T5 = BSIM3kgidl / T4;
                        if (T5<`EXPL_THRESHOLD)
                          T6 = exp(T5);
                        else
                          T6 = `MAX_EXPL;
                        Igidl = Igidl*T6;
                    end                                        
                /* End of New GIDL */
       end
       if(verbose == 1) begin
          $strobe("Igisl=%e\n", Igisl);
          $strobe("Igidl=%e\n", Igidl);
       end
	   	/*End of Gidl*/
       
        /* Calculate gate tunneling current */
        if ((BSIM3igcMod != 0) || (BSIM3igbMod != 0)) begin
            Vfb = BSIM3vfbzb; //TODO: here_BSIM3vfbzb? impacted by lod_mode
            V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3;
            if (Vfb <= 0.0)
                T0 = `BSIM3_sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
            else
                T0 = `BSIM3_sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);

            T1 = 0.5 * (1.0 + V3 / T0);
            Vfbeff = Vfb - 0.5 * (V3 + T0);

            Voxacc = Vfb - Vfbeff;
            if (Voxacc < 0.0) /* WDLiu: Avoiding numerical instability. */
                Voxacc = 0.0;

            T0 = 0.5 * BSIM3k1ox;
            T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
            if (BSIM3k1ox == 0.0)
                Voxdepinv = 0.0;
            else if (T3 < 0.0)
                Voxdepinv = -T3;
            else begin
                T1 = `BSIM3_sqrt(T0 * T0 + T3);
                //T2 = T0 / T1;
                Voxdepinv = BSIM3k1ox * (T1 - T0);
            end

            Voxdepinv = Voxdepinv + Vgsteff;
        end 
        if(BSIM3tempMod < 2)
            tmp = Vtm;
        else /* BSIM3tempMod = 2 , 3*/
            tmp = Vtm0;

        if (BSIM3igcMod) begin
            T0 = tmp * BSIM3nigc;
            if(BSIM3igcMod == 1) begin
              VxNVt = (Vgs_eff - BSIM3type * BSIM3vth0) / T0; //TODO here_BSIM3vth0->BSIM3vth0
              if (VxNVt > `EXP_THRESHOLD)
                Vaux = Vgs_eff - BSIM3type * BSIM3vth0;//TODO here_BSIM3vth0->BSIM3vth0
	    end else if (BSIM3igcMod == 2) begin
              VxNVt = (Vgs_eff - Vth) / T0;
              if (VxNVt > `EXP_THRESHOLD)
                Vaux = Vgs_eff - Vth;
            end
              if (VxNVt < -`EXP_THRESHOLD)
              begin   
                  Vaux = T0 * ln(1.0 + `MIN_EXP);
              end
              else if ((VxNVt >= -`EXP_THRESHOLD) && (VxNVt <= `EXP_THRESHOLD))
              begin   
                  ExpVxNVt = exp(VxNVt);
                  Vaux = T0 * ln(1.0 + ExpVxNVt);
              end


            T2 = Vgs_eff * Vaux;
            T11 = BSIM3Aechvb;
            T3 = BSIM3aigc * BSIM3cigc - BSIM3bigc;
            T4 = BSIM3bigc * BSIM3cigc;
            T5 = BSIM3Bechvb * (BSIM3aigc + T3 * Voxdepinv
            - T4 * Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igc = T11 * T2 * T6;

            if (BSIM3pigcdGiven)
                Pigcd = BSIM3pigcd;
            else begin
                /*T11 = BSIM3Bechvb * BSIM3toxe; v4.7 TODO use the new fix?*/
                T11 = -BSIM3Bechvb;
                T12 = Vgsteff + 1.0e-20;
                T13 = T11 / T12 / T12;
                T14 = -T13 / T12;
                Pigcd = T13 * (1.0 - 0.5 * Vdseff / T12);
            end

            T7 = -Pigcd * Vdseff;
            T8 = T7 * T7 + 2.0e-4;

            if (T7 > `EXP_THRESHOLD)
                T9 = `MAX_EXP;
            else if (T7 < -`EXP_THRESHOLD)
                T9 = `MIN_EXP;
            else
                T9 = exp(T7);

            T0 = T8 * T8;
            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;

            Igcs = Igc * T10;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            Igcd = Igc * T10;

            T0 = vgs - (BSIM3vfbsd + BSIM3vfbsdoff);
            vgs_eff = `BSIM3_sqrt(T0 * T0 + 1.0e-4);

            T2 = vgs * vgs_eff;
            T11 = BSIM3AechvbEdge; //TODO BSIM3AechvbEdgeS -> BSIM3AechvbEdge, no S/D differ
            T12 = BSIM3BechvbEdge;
            T3 = BSIM3aigs * BSIM3cigs - BSIM3bigs; //TODO gs->gsd DONE
            T4 = BSIM3bigs * BSIM3cigs; //TODO gs->gsd DONE
            T5 = T12 * (BSIM3aigsd + T3 * vgs_eff - T4 * vgs_eff * vgs_eff);
            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);
            Igs = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igs=%e,%e,%e,%e,%e,%e,%e,%e,%e,%e\n", Igs,T11,  T2,  T6, BSIM3aigsd,T5, T3, T4,T12,vgs_eff);

            T0 = vgd - (BSIM3vfbsd + BSIM3vfbsdoff);
            vgd_eff = `BSIM3_sqrt(T0 * T0 + 1.0e-4);

            T2 = vgd * vgd_eff;
            T11 = BSIM3AechvbEdge; //TODO BSIM3AechvbEdgeD -> BSIM3AechvbEdge, no S/D differ
            T3 = BSIM3aigd * BSIM3cigd //TODO gd->gsd DONE
                 - BSIM3bigd;
            T4 = BSIM3bigd * BSIM3cigd; //TODO gd->gsd DONE 
            T5 = T12 * (BSIM3aigd + T3 * vgd_eff - T4 * vgd_eff * vgd_eff); //TODO BSIM3aigd->BSIM3aigsd DONE
            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igd = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igd=%e\n", Igd,T11,  T2,  T6);
        end
        else begin //BSIM3igcMod == 0
          Igcs = 0.0;
          Igs = 0.0;
          Igcd = 0.0;
          Igd = 0.0;
        end
        
        if (BSIM3igbMod) begin
            T0 = tmp * BSIM3nigbacc;
            T1 = -Vgs_eff + Vbseff + Vfb;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD)
                Vaux = T1;
            else if (VxNVt < -`EXP_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = 4.97232e-7 * BSIM3weff * BSIM3leff * BSIM3ToxRatio;
            T12 = -7.45669e11 * BSIM3toxe;
            T3 = BSIM3aigbacc * BSIM3cigbacc - BSIM3bigbacc;
            T4 = BSIM3bigbacc * BSIM3cigbacc;
            T5 = T12 * (BSIM3aigbacc + T3 * Voxacc - T4 * Voxacc * Voxacc);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igbacc = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igbacc=%e\n", Igbacc);

            T0 = tmp * BSIM3nigbinv;
            T1 = Voxdepinv - BSIM3eigbinv;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD)
                Vaux = T1;
            else if (VxNVt < -`EXP_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end        

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = T11 * (0.75610);
            T12 = T12 * (1.31724);
            T3 = BSIM3aigbinv * BSIM3cigbinv - BSIM3bigbinv;
            T4 = BSIM3bigbinv * BSIM3cigbinv;
            T5 = T12 * (BSIM3aigbinv + T3 * Voxdepinv - T4 *
                Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igbinv = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igbinv=%e\n", Igbinv);

            Igb = Igbinv + Igbacc;

        end  
        else
            Igb = 0.0;
/* End of Gate current */

        // Charge computation:
        if (BSIM3xpart < 0) begin 
            qgate = 0.0;
            qdrn = 0.0;
            qbulk = 0.0;
            qsrc = 0.0;
        end // if (BSIM3xpart < 0)
        else begin
            if (BSIM3capMod == 0) begin
                if (Vbseff < 0.0)
                    Vbseff = Vbs;
                else
                    Vbseff = BSIM3phi - Phis;

                Vfb = BSIM3vfbcv;
                Vth = Vfb + BSIM3phi + BSIM3k1ox * sqrtPhis; 
                Vgst = Vgs_eff - Vth;
                CoxWL = BSIM3cox * BSIM3weffCV * BSIM3leffCV;
                Arg1 = Vgs_eff - Vbseff - Vfb;
                if (Arg1 <= 0.0) begin
                    qgate = CoxWL * Arg1;
                    qbulk = -qgate;
                    qdrn = 0.0;
                end 
                else if (Vgst <= 0.0) begin
                    T1 = 0.5 * BSIM3k1ox;
                    T2 = `BSIM3_sqrt(T1 * T1 + Arg1);
                    qgate = CoxWL * BSIM3k1ox * (T2 - T1);
                    qbulk = -qgate;
                    qdrn = 0.0;
                end 
                else begin
                    One_Third_CoxWL = CoxWL / 3.0;
                    Two_Third_CoxWL = 2.0 * One_Third_CoxWL;
                    AbulkCV = Abulk0 * BSIM3abulkCVfactor;
                    Vdsat = Vgst / AbulkCV;
                    if (BSIM3xpart > 0.5) begin
                        /* 0/100 Charge partition model */
                        if (Vdsat <= Vds) begin
                            /* saturation region */
                            T1 = Vdsat / 3.0;
                            qgate = CoxWL * (Vgs_eff - Vfb
                                    - BSIM3phi - T1);
                            T2 = -Two_Third_CoxWL * Vgst;
                            qbulk = -(qgate + T2);
                            qdrn = 0.0;
                        end 
                        else begin
                            /* linear region */
                            Alphaz = Vgst / Vdsat;
                            T1 = 2.0 * Vdsat - Vds;
                            T2 = Vds / (3.0 * T1);
                            T3 = T2 * Vds;
                            T9 = 0.25 * CoxWL;
                            T4 = T9 * Alphaz;
                            T7 = 2.0 * Vds - T1 - 3.0 * T3;
                            T8 = T3 - T1 - 2.0 * Vds;
                            qgate = CoxWL * (Vgs_eff - Vfb 
                                     - BSIM3phi - 0.5 * (Vds - T3));
                            T10 = T4 * T8;
                            qdrn = T4 * T7;
                            qbulk = -(qgate + qdrn + T10);
                        end 
                    end 
                    else if (BSIM3xpart < 0.5) begin
                        /* 40/60 Charge partition model */
                        if (Vds >= Vdsat) begin
                            /* saturation region */
                            T1 = Vdsat / 3.0;
                            qgate = CoxWL * (Vgs_eff - Vfb
                                    - BSIM3phi - T1);
                            T2 = -Two_Third_CoxWL * Vgst;
                            qbulk = -(qgate + T2);
                            qdrn = 0.4 * T2;
                        end 
                        else begin
                            /* linear region  */
                            Alphaz = Vgst / Vdsat;
                            T1 = 2.0 * Vdsat - Vds;
                            T2 = Vds / (3.0 * T1);
                            T3 = T2 * Vds;
                            T9 = 0.25 * CoxWL;
                            T4 = T9 * Alphaz;
                            qgate = CoxWL * (Vgs_eff - Vfb - BSIM3phi
                                     - 0.5 * (Vds - T3));
                            T6 = 8.0 * Vdsat * Vdsat - 6.0 * Vdsat * Vds
                                   + 1.2 * Vds * Vds;
                            T8 = T2 / T1;
                            T7 = Vds - T1 - T8 * T6;
                            qdrn = T4 * T7;
                            T7 = 2.0 * (T1 + T3);
                            qbulk = -(qgate - T4 * T7);
                        end 
                    end 
                    else begin
                        /* 50/50 partitioning */
                        if (Vds >= Vdsat) begin
                            /* saturation region */
                            T1 = Vdsat / 3.0;
                            qgate = CoxWL * (Vgs_eff - Vfb
                                    - BSIM3phi - T1);
                            T2 = -Two_Third_CoxWL * Vgst;
                            qbulk = -(qgate + T2);
                            qdrn = 0.5 * T2;
                        end 
                        else begin
                            /* linear region */
                            Alphaz = Vgst / Vdsat;
                            T1 = 2.0 * Vdsat - Vds;
                            T2 = Vds / (3.0 * T1);
                            T3 = T2 * Vds;
                            T9 = 0.25 * CoxWL;
                            T4 = T9 * Alphaz;
                            qgate = CoxWL * (Vgs_eff - Vfb - BSIM3phi
                                    - 0.5 * (Vds - T3));
                            T7 = T1 + T3;
                            qdrn = -T4 * T7;
                            qbulk = - (qgate + qdrn + qdrn);
                        end 
                    end // else: !if(BSIM3xpart < 0.5)
                end // else: !if(Vgst <= 0.0)
            end // if (BSIM3capMod == 0)
            else begin
                if (Vbseff < 0.0) 
                    VbseffCV = Vbseff;
                else
                 VbseffCV = BSIM3phi - Phis;
                   
                CoxWL = BSIM3cox * BSIM3weffCV * BSIM3leffCV;
        
                /* Separate VgsteffCV with noff and voffcv */
                local_noff = n * BSIM3noff;
                T0 = Vtm * local_noff;
                local_voffcv = BSIM3voffcv;
                VgstNVt = (Vgst - local_voffcv) / T0;
                if (VgstNVt > `EXP_THRESHOLD)
                    Vgsteff = Vgst - local_voffcv;
                else if (VgstNVt < -`EXP_THRESHOLD)
                    Vgsteff = T0 * ln(1.0 + `MIN_EXP);
                else begin
                    ExpVgst = exp(VgstNVt);
                    Vgsteff = T0 * ln(1.0 + ExpVgst);
                end  /* End of VgsteffCV */
        
                if (BSIM3capMod == 1) begin
                    Vfb = BSIM3vfbzb;
                    Arg1 = Vgs_eff - VbseffCV - Vfb - Vgsteff;
        
                    if (Arg1 <= 0.0)
                        qgate = CoxWL * Arg1;
                    else begin
                        T0 = 0.5 * BSIM3k1ox;
                        T1 = `BSIM3_sqrt(T0 * T0 + Arg1);
                        qgate = CoxWL * BSIM3k1ox * (T1 - T0);
                    end 
        
                    qbulk = -qgate;
                     
                    One_Third_CoxWL = CoxWL / 3.0;
                    Two_Third_CoxWL = 2.0 * One_Third_CoxWL;
                    AbulkCV = Abulk0 * BSIM3abulkCVfactor;
                    VdsatCV = Vgsteff / AbulkCV;
        
                    if (VdsatCV < Vds) begin
                        T0 = Vgsteff - VdsatCV / 3.0;
                        qgate = qgate + CoxWL * T0;
                        T0 = VdsatCV - Vgsteff;
                        qbulk = qbulk + One_Third_CoxWL * T0;
                      
                        if (BSIM3xpart > 0.5)
                            T0 = -Two_Third_CoxWL;
                        else if (BSIM3xpart < 0.5)
                            T0 = -0.4 * CoxWL;
                        else
                            T0 = -One_Third_CoxWL;
                        qsrc = T0 * Vgsteff;
                    end 
                    else begin
                        T0 = AbulkCV * Vds;
                        T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
                        T2 = Vds / T1;
                        T3 = T0 * T2;
                       
                        qgate = qgate + CoxWL * (Vgsteff - 0.5 * Vds + T3);
                        qbulk = qbulk + CoxWL * (1.0 - AbulkCV) 
                                 * (0.5 * Vds - T3);
                        if (BSIM3xpart > 0.5) begin
                            /* 0/100 Charge partition model */
                            T1 = T1 + T1;
                            qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0
                                    - T0 * T0 / T1);
                        end 
                        else if (BSIM3xpart < 0.5) begin
                            /* 40/60 Charge partition model */
                            T1 = T1 / 12.0;
                            T2 = 0.5 * CoxWL / (T1 * T1);
                            T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff
                                   * (Vgsteff - 4.0 * T0 / 3.0))
                                   - 2.0 * T0 * T0 * T0 / 15.0;
                            qsrc = -T2 * T3;
                        end 
                        else begin
                            /* 50/50 Charge partition model */
                            qsrc = -0.5 * (qgate + qbulk);
                        end 
                    end 
        
                    qdrn = -(qgate + qbulk + qsrc);
                       
                end 
                else if (BSIM3capMod == 2) begin
                    Vfb = BSIM3vfbzb;
                    V3 = Vfb - Vgs_eff + VbseffCV - `DELTA_3;
                    if (Vfb <= 0.0)
                        T0 = `BSIM3_sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
                    else
                        T0 = `BSIM3_sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);
                    Vfbeff = Vfb - 0.5 * (V3 + T0);
                    Qac0 = CoxWL * (Vfbeff - Vfb);              
                    T0 = 0.5 * BSIM3k1ox;
                    T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
                    if (BSIM3k1ox == 0.0)
                        T1 = 0.0;
                    else if (T3 < 0.0)
                        T1 = T0 + T3 / BSIM3k1ox;
                    else
                        T1 = `BSIM3_sqrt(T0 * T0 + T3);
        
                    Qsub0 = CoxWL * BSIM3k1ox * (T1 - T0);
                       
                    AbulkCV = Abulk0 * BSIM3abulkCVfactor;
                    VdsatCV = Vgsteff / AbulkCV;
                    V4 = VdsatCV - Vds - `DELTA_4;
                    T0 = `BSIM3_sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
                    VdseffCV = VdsatCV - 0.5 * (V4 + T0);
        
                    /* Added to eliminate non-0 VdseffCV at Vds=0.0 */
                    if (Vds == 0.0)
                        VdseffCV = 0.0;
        
                    T0 = AbulkCV * VdseffCV;
                    T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1e-20);
                    T2 = VdseffCV / T1;
                    T3 = T0 * T2;
                    // qinoi = -CoxWL * (Vgsteff - 0.5 * T0 + AbulkCV * T3);
                    qgate = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);
                    T7 = 1.0 - AbulkCV;
                    qbulk = CoxWL * T7 * (0.5 * VdseffCV - T3);
        
                    if (BSIM3xpart > 0.5) begin
                        /* 0/100 Charge partition model */
                        T1 = T1 + T1;
                        qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0
                                - T0 * T0 / T1);
                    end 
                    else if (BSIM3xpart < 0.5) begin
                        /* 40/60 Charge partition model */
                        T1 = T1 / 12.0;
                        T2 = 0.5 * CoxWL / (T1 * T1);
                        T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff
                              * (Vgsteff - 4.0 * T0 / 3.0))
                              - 2.0 * T0 * T0 * T0 / 15.0;
                        qsrc = -T2 * T3;
                    end 
                    else begin
                        /* 50/50 Charge partition model */
                        qsrc = -0.5 * (qgate + qbulk);
                    end
                                 
                    qgate = qgate + Qac0 + Qsub0;
                    qbulk = qbulk - (Qac0 + Qsub0);
                    qdrn = -(qgate + qbulk + qsrc);
        
                end  
                else if (BSIM3capMod == 3) begin
                    /* New Charge-Thickness capMod (CTM) begins */
                    V3 = BSIM3vfbzb - Vgs_eff + VbseffCV - `DELTA_3;
        
                    if (BSIM3vfbzb <= 0.0)
                        T0 = `BSIM3_sqrt(V3 * V3 - 4.0 * `DELTA_3 * BSIM3vfbzb);
                    else
                        T0 = `BSIM3_sqrt(V3 * V3 + 4.0 * `DELTA_3 * BSIM3vfbzb);
        
                    Vfbeff = BSIM3vfbzb - 0.5 * (V3 + T0);
                    Cox = BSIM3cox;
                    Tox = 1.0e8 * BSIM3tox;
                    T0 = (Vgs_eff - VbseffCV - BSIM3vfbzb) / Tox;
                    tmp = T0 * BSIM3acde;
        
                    if ((-`EXP_THRESHOLD < tmp) && (tmp < `EXP_THRESHOLD))
                        Tcen = BSIM3ldeb * exp(tmp);
                    else if (tmp <= -`EXP_THRESHOLD) 
                        Tcen = BSIM3ldeb * `MIN_EXP;
                    else
                        Tcen = BSIM3ldeb * `MAX_EXP;
        
                    LINK = 1.0e-3 * BSIM3tox;
                    V3 = BSIM3ldeb - Tcen - LINK;
                    V4 = `BSIM3_sqrt(V3 * V3 + 4.0 * LINK * BSIM3ldeb);
                    Tcen = BSIM3ldeb - 0.5 * (V3 + V4);
                    Ccen = `EPSSI / Tcen;
                    T2 = Cox / (Cox + Ccen);
                    Coxeff = T2 * Ccen;
                    CoxWLcen = CoxWL * Coxeff / Cox;
                    Qac0 = CoxWLcen * (Vfbeff - BSIM3vfbzb);
                    T0 = 0.5 * BSIM3k1ox;
                    T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
                    if (BSIM3k1ox == 0.0)
                        T1 = 0.0;
                    else if (T3 < 0.0)
                        T1 = T0 + T3 / BSIM3k1ox;
                    else
                        T1 = `BSIM3_sqrt(T0 * T0 + T3);
                        
                    Qsub0 = CoxWLcen * BSIM3k1ox * (T1 - T0);
        
                    /* Gate-bias dependent delta Phis begins */
                    if (BSIM3k1ox <= 0.0) begin
                        Denomi = 0.25 * BSIM3moin * Vtm;
                        T0 = 0.5 * BSIM3sqrtPhi;
                    end
                    else begin
                        Denomi = BSIM3moin * Vtm 
                                 * BSIM3k1ox * BSIM3k1ox;
                        T0 = BSIM3k1ox * BSIM3sqrtPhi;
                    end 
        
                    T1 = 2.0 * T0 + Vgsteff;
                    DeltaPhi = Vtm * ln(1.0 + T1 * Vgsteff / Denomi);

                    // v3.25: VgDP = Vgsteff - DeltaPhi 
                    T0 = Vgsteff - DeltaPhi - 0.001;
                    T1 = `BSIM3_sqrt(T0 * T0 + Vgsteff * 0.004);
                    VgDP = 0.5 * (T0 + T1);
                    // v3.25

                    T3 = 4.0 * (Vth - BSIM3vfbzb - BSIM3phi);
                    Tox = Tox + Tox;
        
                    if (T3 >= 0.0)
                        T0 = (Vgsteff + T3) / Tox;
                    else
                        T0 = (Vgsteff + 1.0e-20) / Tox;
                    
                    tmp = exp(0.7 * ln(T0));
                    T1 = 1.0 + tmp;
                    Tcen = 1.9e-9 / T1;
                    
                    Ccen = `EPSSI / Tcen;
                    T0 = Cox / (Cox + Ccen);
                    Coxeff = T0 * Ccen;
                    CoxWLcen = CoxWL * Coxeff / Cox;
                    AbulkCV = Abulk0 * BSIM3abulkCVfactor;
                    
                    // v3.25:
                    // VdsatCV = (Vgsteff - DeltaPhi) / AbulkCV;
                    // V4 = VdsatCV - Vds - `DELTA_4;
                    // T0 = `BSIM3_sqrt(V4 * V4 + 4.0 * `DELTA_4 * VdsatCV);
                    // VdseffCV = VdsatCV - 0.5 * (V4 + T0);
                    VdsatCV =  VgDP / AbulkCV;
                    T0 = VdsatCV - Vds - `DELTA_4;
                    T1 = `BSIM3_sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
                    if (T0 >= 0.0)
                        VdseffCV = VdsatCV - 0.5 * (T0 + T1);
                    else begin
                        T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                        T4 = 1.0 - T3;
                        VdseffCV = VdsatCV * T4;
                    end // v3.25

                    if (Vds == 0.0)
                        VdseffCV = 0.0;
                     
                    T0 = AbulkCV * VdseffCV;
                    // v3.25 T1 = Vgsteff - DeltaPhi;
                    T1 = VgDP;

                    T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
                    T3 = T0 / T2;
                    
                    qgate  =  CoxWLcen * (T1 - T0 * (0.5 - T3));
                    // qinoi  =  CoxWLcen * (T1 - T0 * (0.5 - T3));
                    
                    T7 = 1.0 - AbulkCV;
                    qbulk = CoxWLcen * T7 * (0.5 * VdseffCV - T0 
		              * VdseffCV / T2);
                    
                    if (BSIM3xpart > 0.5) begin
                        /* 0/100 partition */
                        qsrc = - CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 
                                * T0 * T0 / T2);
                    end 
                    else if (BSIM3xpart < 0.5) begin
                        /* 40/60 partition */
                        T2 = T2 / 12.0;
                        T3 = 0.5 * CoxWLcen / (T2 * T2);
                        T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0 * T0 
                                 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                        qsrc = -T3 * T4;
                    end 
                    else begin
                        /* 50/50 partition */
                        qsrc = -0.5 * qgate;
                    end 
                    qgate = qgate + Qac0 + Qsub0 - qbulk;
                    qbulk = qbulk - (Qac0 + Qsub0);
                    qdrn = -(qgate + qbulk + qsrc);
                end   /* End of CTM */
                  
            end // else: !if(BSIM3capMod == 0)
                 
        end // else: !if(BSIM3xpart < 0)
        if(BSIM3acm <9) begin
          //mos diode model with acm <9, print a warning
          $strobe("Warn: ACM(%d)<9 may not full compatible with hspice...\n", BSIM3acm);
        end
        czbd = BSIM3unitAreaTempJctCap * BSIM3drainArea; 
        czbs = BSIM3unitAreaTempJctCap * BSIM3sourceArea;

        if (BSIM3drainPerimeter < BSIM3weff) begin
            czbdswg = BSIM3unitLengthGateSidewallTempJctCap 
	                * BSIM3drainPerimeter;
            czbdsw = 0.0;
        end 
        else begin
            czbdsw = BSIM3unitLengthSidewallTempJctCap 
                     * (BSIM3drainPerimeter - BSIM3weff);
            czbdswg = BSIM3unitLengthGateSidewallTempJctCap
                     *  BSIM3weff;
        end 
        if (BSIM3sourcePerimeter < BSIM3weff) begin
            czbssw = 0.0; 
            czbsswg = BSIM3unitLengthGateSidewallTempJctCap 
                       * BSIM3sourcePerimeter;
        end 
        else begin
            czbssw = BSIM3unitLengthSidewallTempJctCap 
                      * (BSIM3sourcePerimeter - BSIM3weff);
            czbsswg = BSIM3unitLengthGateSidewallTempJctCap * BSIM3weff;
        end 

        MJ = BSIM3bulkJctBotGradingCoeff;
        MJSW = BSIM3bulkJctSideGradingCoeff;
        MJSWG = BSIM3bulkJctGateSideGradingCoeff;

        /* Source Bulk Junction */
        if (vbs < 0.0) begin
            if (czbs > 0.0) begin
                arg = 1.0 - vbs / BSIM3PhiB;
                if (MJ == 0.5)
                    sarg = 1.0 / `BSIM3_sqrt(arg);
                else
                    sarg = exp(-MJ * ln(arg));
                qbs = BSIM3PhiB * czbs * (1.0 - arg * sarg) / (1.0 - MJ);
            end 
            else begin
                qbs = 0.0;
            end 
            if (czbssw > 0.0) begin
                arg = 1.0 - vbs / BSIM3PhiBSW;
                if (MJSW == 0.5)
                    sarg = 1.0 / `BSIM3_sqrt(arg);
                else
                    sarg = exp(-MJSW * ln(arg));

                qbs = qbs + BSIM3PhiBSW * czbssw * (1.0 - arg * sarg) 
                       / (1.0 - MJSW);
            end 
            if (czbsswg > 0.0) begin
                arg = 1.0 - vbs / BSIM3PhiBSWG;
                if (MJSWG == 0.5)
                    sarg = 1.0 / `BSIM3_sqrt(arg);
                else
                    sarg = exp(-MJSWG * ln(arg));

                qbs = qbs + BSIM3PhiBSWG * czbsswg * (1.0 - arg * sarg) 
                       / (1.0 - MJSWG);
            end

        end 
        else begin //vbs >=0
            T0 = czbs + czbssw + czbsswg;
            T1 = vbs * (czbs * MJ / BSIM3PhiB + czbssw * MJSW 
                   / BSIM3PhiBSW + czbsswg * MJSWG / BSIM3PhiBSWG);    
            qbs = vbs * (T0 + 0.5 * T1);
        end 

        /* Drain Bulk Junction */
        if (vbd < 0.0) begin
            if (czbd > 0.0) begin
                arg = 1.0 - vbd / BSIM3PhiB;
                if (MJ == 0.5)
                    sarg = 1.0 / `BSIM3_sqrt(arg);
                else
                    sarg = exp(-MJ * ln(arg));

                qbd = BSIM3PhiB * czbd  * (1.0 - arg * sarg) / (1.0 - MJ);
            end 
            else begin
                qbd = 0.0;
            end 

            if (czbdsw > 0.0) begin
                arg = 1.0 - vbd / BSIM3PhiBSW;
                if (MJSW == 0.5)
                    sarg = 1.0 / `BSIM3_sqrt(arg);
                else
                    sarg = exp(-MJSW * ln(arg));
                qbd = qbd + BSIM3PhiBSW * czbdsw * (1.0 - arg * sarg) 
                       / (1.0 - MJSW);
            end 
            if (czbdswg > 0.0) begin
                arg = 1.0 - vbd / BSIM3PhiBSWG;
                if (MJSWG == 0.5)
                    sarg = 1.0 / `BSIM3_sqrt(arg);
                else
                    sarg = exp(-MJSWG * ln(1.0 - vbd / BSIM3PhiBSWG));

                qbd = qbd + BSIM3PhiBSWG * czbdswg * (1.0 - arg * sarg) 
                      / (1.0 - MJSWG);
            end 
        end 
        else begin
            T0 = czbd + czbdsw + czbdswg;
            T1 = vbd * (czbd * MJ / BSIM3PhiB + czbdsw * MJSW
                 / BSIM3PhiBSW + czbdswg * MJSWG / BSIM3PhiBSWG);
            qbd = vbd * (T0 + 0.5 * T1);
        end 
        
        /* bulk and channel charge plus overlaps */
        if (BSIM3capMod == 0) begin
            local_cgdo = BSIM3cgdo;
            qgdo = local_cgdo * vgd;
            local_cgso = BSIM3cgso;
            qgso = local_cgso * vgs;
        end 
        else if (BSIM3capMod == 1) begin
            if (vgd < 0.0) begin
                T1 = `BSIM3_sqrt(1.0 - 4.0 * vgd / BSIM3ckappa);
                local_cgdo = BSIM3cgdo + BSIM3weffCV * BSIM3cgdl / T1;
                qgdo = local_cgdo * vgd - BSIM3weffCV * 0.5 * BSIM3cgdl 
                        * BSIM3ckappa * (T1 - 1.0);
            end 
            else begin
                local_cgdo = BSIM3cgdo + BSIM3weffCV * BSIM3cgdl;
                qgdo = (BSIM3weffCV * BSIM3cgdl + local_cgdo) * vgd;
            end 
            if (vgs < 0.0) begin
                T1 = `BSIM3_sqrt(1.0 - 4.0 * vgs / BSIM3ckappa);
                local_cgso = BSIM3cgso + BSIM3weffCV * BSIM3cgsl / T1;
                qgso = local_cgso * vgs - BSIM3weffCV * 0.5 * BSIM3cgsl 
                        * BSIM3ckappa * (T1 - 1.0);
            end 
            else begin
                local_cgso = BSIM3cgso + BSIM3weffCV * BSIM3cgsl;
                qgso = (BSIM3weffCV * BSIM3cgsl + local_cgso) * vgs;
            end 
        end 
        else begin
            T0 = vgd + `DELTA_1;
            T1 = `BSIM3_sqrt(T0 * T0 + 4.0 * `DELTA_1);
            T2 = 0.5 * (T0 - T1);
            T3 = BSIM3weffCV * BSIM3cgdl;
            T4 = `BSIM3_sqrt(1.0 - 4.0 * T2 / BSIM3ckappa);
            local_cgdo = BSIM3cgdo + T3 - T3 * (1.0 - 1.0 / T4) 
                          * (0.5 - 0.5 * T0 / T1);

            qgdo = (local_cgdo + T3) * vgd - T3 * (T2 + 0.5 
                    * BSIM3ckappa * (T4 - 1.0));
            T0 = vgs + `DELTA_1;
            T1 = `BSIM3_sqrt(T0 * T0 + 4.0 * `DELTA_1);
            T2 = 0.5 * (T0 - T1);
            T3 = BSIM3weffCV * BSIM3cgsl;
            T4 = `BSIM3_sqrt(1.0 - 4.0 * T2 / BSIM3ckappa);
            local_cgso = BSIM3cgso + T3 - T3 * (1.0 - 1.0 / T4) 
                          * (0.5 - 0.5 * T0 / T1);
            qgso = (local_cgso + T3) * vgs - T3 * (T2 + 0.5 
                    * BSIM3ckappa * (T4 - 1.0));

        end 

        if (BSIM3mode > 0) begin
            if (BSIM3nqsMod == 0) begin
                qgd = qgdo;
                qgs = qgso;
                qgb = BSIM3cgbo * vgb;

                qgate = qgate + qgd + qgs + qgb;
                qbulk = qbulk - qgb;
                qdrn = qdrn - qgd;
                // qsrc = -(qgate + qbulk + qdrn);
            end 
            else begin
                qgd = qgdo;
                qgs = qgso;
                qgb = BSIM3cgbo * vgb;
                qgate = qgd + qgs + qgb;
                qbulk = -qgb;
                qdrn = -qgd;
                // qsrc = -(qgate + qbulk + qdrn);
            end 
        end 
        else begin  /* idevmod<0 */
            if (BSIM3nqsMod == 0) begin
                qgd = qgdo;
                qgs = qgso;
                qgb = BSIM3cgbo * vgb;
                qgate = qgate + qgd + qgs + qgb;
                qbulk = qbulk - qgb;
                qsrc = qdrn - qgs;
                qdrn = -(qgate + qbulk + qsrc);
            end 
            else begin
                qgd = qgdo;
                qgs = qgso;
                qgb = BSIM3cgbo * vgb;
                qgate = qgd + qgs + qgb;
                qbulk = -qgb;
                qsrc = -qgs;
                qdrn = -(qgate + qbulk + qsrc);
            end
        end // else: !if(BSIM3mode > 0)

        // Contributions:

        if(verbose == 1) begin
          if (BSIM3sourceResistance > 0.0 || BSIM3drainResistance>0.0) 
           $strobe("BSIM3sourceResistance,BSIM3drainResistance,rsh=%e,%e,%e\n", BSIM3sourceResistance,BSIM3drainResistance,rsh);
        end
        // Parasitic resistances
        if (BSIM3sourceResistance > 0.0) begin
            I(s,si) <+ V(s,si) / BSIM3sourceResistance;
        end
        else
            V(s,si) <+ 0.0;

        if (BSIM3drainResistance > 0.0) begin
        //if (rsh > 0.0 && BSIM3drainSquares > 0.0) begin
            I(d,di) <+ V(d,di) / BSIM3drainResistance;
            if(verbose == 1) begin
               $strobe("BSIM3drainResistance=%e\n", BSIM3drainResistance);
            end
        end
        else
            V(d,di) <+ 0.0;
  
        if (BSIM3mode > 0) begin
            Ibs = 0.0;
            Ibd = - BSIM3type * Isub;
        end
        else begin
            Ids = - Ids;
            Ibd = 0.0;      
            Ibs = - BSIM3type * Isub;
        end 
        
        I(di,si)<+ BSIM3type * Ids;
        I(g,si) <+ BSIM3type * Igs;
        I(g,di) <+ BSIM3type * Igd;
        I(di,b) <+ BSIM3type * Igidl;    
        I(si,b) <+ BSIM3type * Igisl;     
        I(g,si) <+ BSIM3type * Igcs;
        I(g,di) <+ BSIM3type * Igcd;
        I(g,b)	<+ BSIM3type * Igb;
        if(verbose == 1) begin
           $strobe("Ids=%e\n", Ids);
           $strobe("Igs,Igd,Igb,Igcs,Igcd=%e,%e,%e,%e,%e\n", Igs,Igd,Igb,Igcs,Igcd);
           $strobe("Isub=%e,%e\n", Ibs,Ibd);
           $strobe("Ibs,Ibd=%e,%e\n", BSIM3cbs,BSIM3cbd);
        end

        // Parasitic diodes
        I(b,si) <+ BSIM3type * BSIM3cbs + Ibs;
        I(b,di) <+ BSIM3type * BSIM3cbd + Ibd;
  
        I(g, si) <+ BSIM3type * ddt(qgate);
        I(b, si) <+ BSIM3type * ddt(qbs + qbulk);
        I(b, di) <+ BSIM3type * ddt(qbd);
        I(di,si) <+ BSIM3type * ddt(qdrn);
       
`ifdef NOISE
        if (doNoise) begin
            case (BSIM3noiMod)
            1, 3:
                thermalNoiseContrib = 8 * `P_K * T * (Gm + Gds + Gmb) / 3;
            2, 4: begin
                Qinv = -Weff * Leff * Cox * Vgsteff 
                        * (1 - Abulk / (2 * (Vgsteff + 2 * Vtm)) * Vdseff);
                        
                thermalNoiseContrib = 4 * `P_K * T * ueff * abs (Qinv) 
                                      / (Leff * Leff + ueff * abs(Qinv) * Rds);
                // VA: error in UCB? * abs (Qinv) / (Leff * Leff);
            end // case: 2, 4
            default: 
                thermalNoiseContrib = 0;
            endcase // case(noimod)
  
            case (BSIM3noiMod)
            1, 4:
                flickerNoiseContrib = BSIM3kf * pow(abs(Ids), BSIM3af) 
                                       / (Cox * Leff * Leff);
            2, 3: begin
                // StrongInversionNoiseEval
                Esat = 2.0 * BSIM3vsattemp / ueff;
                if(BSIM3em<=0.0) 
                    DelClm = 0.0; 
                else begin 
                    T0 = ((((Vds - Vdseff) / BSIM3litl) 
                          + BSIM3em) / Esat);
                    DelClm = BSIM3litl * ln (max(T0, `N_MINLOG));
                end

                T1 = `P_Q * `P_Q * 8.62e-5 * Ids * T * ueff;
                T2 = 1.0e8 * Abulk * Cox * Leff * Leff;

                N0 = Cox * Vgsteff / `P_Q;
                Vgst2Vtm = Vgsteff + 2.0 * Vtm;
                AbovVgst2Vtm = Abulk / Vgst2Vtm;
                Nl = Cox * Vgsteff * (1.0 - AbovVgst2Vtm * Vdseff) / `P_Q;

                T3 = noia * ln(max(((N0 + 2.0e14) / (Nl + 2.0e14)), `N_MINLOG));
                T4 = noib * (N0 - Nl);
                T5 = noic * 0.5 * (N0 * N0 - Nl * Nl);
                T6 = 8.62e-5 * T * Ids * Ids;
                T7 = 1.0e8 * Leff * Leff * Weff;
                T8 = noia + noib * Nl + noic * Nl * Nl;
                T9 = (Nl + 2.0e14) * (Nl + 2.0e14);

                flickerNoiseContrib = T1 / T2 * (T3 + T4 + T5) 
                                       + T6 / T7 * DelClm * T8 / T9;

            end
            default: 
                flickerNoiseContrib = 0.0;
            endcase

            I(di,si) <+ flicker_noise(flickerNoiseContrib, BSIM3ef, "flicker"); 
            I(di,si) <+ white_noise(thermalNoiseContrib, "ids"); 
            if (rsh > 0.0 && BSIM3sourceSquares > 0.0)
                I(s,si)  <+ white_noise(4 * `P_K * T / BSIM3sourceResistance,
                           "Rs"); 
            if (rsh > 0.0 && BSIM3drainSquares > 0.0)
                I(d,di)  <+ white_noise(4 * `P_K * T / BSIM3drainResistance,
                           "Rd"); 
        end

`endif  
   
    end
endmodule 



